
TAS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003464  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000168  00800060  00003464  000034f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000057b  008001c8  008001c8  00003660  2**0
                  ALLOC
  3 .stab         00001ed8  00000000  00000000  00003660  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000006ad  00000000  00000000  00005538  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000002c0  00000000  00000000  00005be8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000048ac  00000000  00000000  00005ea8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000143b  00000000  00000000  0000a754  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000200b  00000000  00000000  0000bb8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000fec  00000000  00000000  0000db9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a9f  00000000  00000000  0000eb88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004459  00000000  00000000  00010627  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  00014a80  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d9 09 	jmp	0x13b2	; 0x13b2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 46 02 	jmp	0x48c	; 0x48c <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e6       	ldi	r30, 0x64	; 100
      68:	f4 e3       	ldi	r31, 0x34	; 52
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 3c       	cpi	r26, 0xC8	; 200
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 ec       	ldi	r26, 0xC8	; 200
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 34       	cpi	r26, 0x43	; 67
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 83 17 	call	0x2f06	; 0x2f06 <main>
      8a:	0c 94 30 1a 	jmp	0x3460	; 0x3460 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_Init>:
#include "ADC.h"

void ADC_Init(void){
	ADC_SelectR->Vref = ADC_VREF_VCC_INT;
      92:	87 b1       	in	r24, 0x07	; 7
      94:	8f 73       	andi	r24, 0x3F	; 63
      96:	80 64       	ori	r24, 0x40	; 64
      98:	87 b9       	out	0x07, r24	; 7
	ADC_CtrlStatusR->prescalar = ADC_PRESC_128;
      9a:	86 b1       	in	r24, 0x06	; 6
      9c:	87 60       	ori	r24, 0x07	; 7
      9e:	86 b9       	out	0x06, r24	; 6
	ADC_CtrlStatusR->enable = 1;
      a0:	37 9a       	sbi	0x06, 7	; 6
}
      a2:	08 95       	ret

000000a4 <ADC_Read>:
u16 ADC_Read(ADC_Channel channel){
	ADC_SelectR->channel = channel;
      a4:	8f 71       	andi	r24, 0x1F	; 31
      a6:	97 b1       	in	r25, 0x07	; 7
      a8:	90 7e       	andi	r25, 0xE0	; 224
      aa:	89 2b       	or	r24, r25
      ac:	87 b9       	out	0x07, r24	; 7
	ADC_CtrlStatusR->start_conv = 1;
      ae:	36 9a       	sbi	0x06, 6	; 6
	while(ADC_CtrlStatusR->start_conv);
      b0:	86 b1       	in	r24, 0x06	; 6
      b2:	86 fd       	sbrc	r24, 6
      b4:	fd cf       	rjmp	.-6      	; 0xb0 <ADC_Read+0xc>
	return ADC_Data;
      b6:	84 b1       	in	r24, 0x04	; 4
      b8:	95 b1       	in	r25, 0x05	; 5
}
      ba:	08 95       	ret

000000bc <Led_On>:
void Led_Init(LED led){
	setBit(LEDS_DDR,led);	/* Out */
	Led_Off(led);			/* Default Off */
}
void Led_On(LED led){
	setBit(LEDS_PORT,led);
      bc:	4b b3       	in	r20, 0x1b	; 27
      be:	21 e0       	ldi	r18, 0x01	; 1
      c0:	30 e0       	ldi	r19, 0x00	; 0
      c2:	b9 01       	movw	r22, r18
      c4:	02 c0       	rjmp	.+4      	; 0xca <Led_On+0xe>
      c6:	66 0f       	add	r22, r22
      c8:	77 1f       	adc	r23, r23
      ca:	8a 95       	dec	r24
      cc:	e2 f7       	brpl	.-8      	; 0xc6 <Led_On+0xa>
      ce:	cb 01       	movw	r24, r22
      d0:	84 2b       	or	r24, r20
      d2:	8b bb       	out	0x1b, r24	; 27
}
      d4:	08 95       	ret

000000d6 <Led_Off>:
void Led_Off(LED led){
	clearBit(LEDS_PORT,led);
      d6:	9b b3       	in	r25, 0x1b	; 27
      d8:	21 e0       	ldi	r18, 0x01	; 1
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	02 c0       	rjmp	.+4      	; 0xe2 <Led_Off+0xc>
      de:	22 0f       	add	r18, r18
      e0:	33 1f       	adc	r19, r19
      e2:	8a 95       	dec	r24
      e4:	e2 f7       	brpl	.-8      	; 0xde <Led_Off+0x8>
      e6:	20 95       	com	r18
      e8:	92 23       	and	r25, r18
      ea:	9b bb       	out	0x1b, r25	; 27
}
      ec:	08 95       	ret

000000ee <Led_Init>:
#include "BasicIO.h"
#include "bit_handle.h"

/* Leds */
void Led_Init(LED led){
	setBit(LEDS_DDR,led);	/* Out */
      ee:	9a b3       	in	r25, 0x1a	; 26
      f0:	41 e0       	ldi	r20, 0x01	; 1
      f2:	50 e0       	ldi	r21, 0x00	; 0
      f4:	9a 01       	movw	r18, r20
      f6:	08 2e       	mov	r0, r24
      f8:	02 c0       	rjmp	.+4      	; 0xfe <Led_Init+0x10>
      fa:	22 0f       	add	r18, r18
      fc:	33 1f       	adc	r19, r19
      fe:	0a 94       	dec	r0
     100:	e2 f7       	brpl	.-8      	; 0xfa <Led_Init+0xc>
     102:	29 2b       	or	r18, r25
     104:	2a bb       	out	0x1a, r18	; 26
	Led_Off(led);			/* Default Off */
     106:	0e 94 6b 00 	call	0xd6	; 0xd6 <Led_Off>
}
     10a:	08 95       	ret

0000010c <Led_Toggle>:
}
void Led_Off(LED led){
	clearBit(LEDS_PORT,led);
}
void Led_Toggle(LED led){
	toggleBit(LEDS_PORT,led);
     10c:	4b b3       	in	r20, 0x1b	; 27
     10e:	21 e0       	ldi	r18, 0x01	; 1
     110:	30 e0       	ldi	r19, 0x00	; 0
     112:	b9 01       	movw	r22, r18
     114:	02 c0       	rjmp	.+4      	; 0x11a <Led_Toggle+0xe>
     116:	66 0f       	add	r22, r22
     118:	77 1f       	adc	r23, r23
     11a:	8a 95       	dec	r24
     11c:	e2 f7       	brpl	.-8      	; 0x116 <Led_Toggle+0xa>
     11e:	cb 01       	movw	r24, r22
     120:	84 27       	eor	r24, r20
     122:	8b bb       	out	0x1b, r24	; 27
}
     124:	08 95       	ret

00000126 <Leds_On>:
void Leds_Init(u8 ledMask){
	LEDS_DDR |= ledMask;	/* Out */
	Leds_Off(ledMask);			/* Default Off */	
}
void Leds_On(u8 ledMask){
	LEDS_PORT |= ledMask;
     126:	9b b3       	in	r25, 0x1b	; 27
     128:	89 2b       	or	r24, r25
     12a:	8b bb       	out	0x1b, r24	; 27
}
     12c:	08 95       	ret

0000012e <Leds_Off>:
void Leds_Off(u8 ledMask){
	LEDS_PORT &= ~ledMask;
     12e:	9b b3       	in	r25, 0x1b	; 27
     130:	80 95       	com	r24
     132:	98 23       	and	r25, r24
     134:	9b bb       	out	0x1b, r25	; 27
}
     136:	08 95       	ret

00000138 <Leds_Init>:
void Led_Toggle(LED led){
	toggleBit(LEDS_PORT,led);
}

void Leds_Init(u8 ledMask){
	LEDS_DDR |= ledMask;	/* Out */
     138:	9a b3       	in	r25, 0x1a	; 26
     13a:	98 2b       	or	r25, r24
     13c:	9a bb       	out	0x1a, r25	; 26
	Leds_Off(ledMask);			/* Default Off */	
     13e:	0e 94 97 00 	call	0x12e	; 0x12e <Leds_Off>
}
     142:	08 95       	ret

00000144 <Leds_Toggle>:
}
void Leds_Off(u8 ledMask){
	LEDS_PORT &= ~ledMask;
}
void Leds_Toggle(u8 ledMask){
	LEDS_PORT ^= ledMask;
     144:	9b b3       	in	r25, 0x1b	; 27
     146:	89 27       	eor	r24, r25
     148:	8b bb       	out	0x1b, r24	; 27
}
     14a:	08 95       	ret

0000014c <Leds_AllOn>:
void Leds_AllInit(void){
	LEDS_DDR |= LEDS_MSK; /* Out */
	Leds_AllOff();
}
void Leds_AllOn(void){
	LEDS_PORT |= LEDS_MSK;
     14c:	8b b3       	in	r24, 0x1b	; 27
     14e:	8f ef       	ldi	r24, 0xFF	; 255
     150:	8b bb       	out	0x1b, r24	; 27
}
     152:	08 95       	ret

00000154 <Leds_AllOff>:
void Leds_AllOff(void){
	LEDS_PORT &= ~LEDS_MSK;
     154:	8b b3       	in	r24, 0x1b	; 27
     156:	1b ba       	out	0x1b, r1	; 27
}
     158:	08 95       	ret

0000015a <Leds_AllInit>:
void Leds_Toggle(u8 ledMask){
	LEDS_PORT ^= ledMask;
}

void Leds_AllInit(void){
	LEDS_DDR |= LEDS_MSK; /* Out */
     15a:	8a b3       	in	r24, 0x1a	; 26
     15c:	8f ef       	ldi	r24, 0xFF	; 255
     15e:	8a bb       	out	0x1a, r24	; 26
	Leds_AllOff();
     160:	0e 94 aa 00 	call	0x154	; 0x154 <Leds_AllOff>
}
     164:	08 95       	ret

00000166 <Leds_AllToggle>:
}
void Leds_AllOff(void){
	LEDS_PORT &= ~LEDS_MSK;
}
void Leds_AllToggle(void){
	LEDS_PORT ^= LEDS_MSK;
     166:	8b b3       	in	r24, 0x1b	; 27
     168:	80 95       	com	r24
     16a:	8b bb       	out	0x1b, r24	; 27
}
     16c:	08 95       	ret

0000016e <Btn_Init>:

/* Buttons */
void Btn_Init(Button btn){
	BUTTONS_DDR  &= ~(1<<btn);	/* in */
     16e:	41 b3       	in	r20, 0x11	; 17
     170:	21 e0       	ldi	r18, 0x01	; 1
     172:	30 e0       	ldi	r19, 0x00	; 0
     174:	b9 01       	movw	r22, r18
     176:	02 c0       	rjmp	.+4      	; 0x17c <Btn_Init+0xe>
     178:	66 0f       	add	r22, r22
     17a:	77 1f       	adc	r23, r23
     17c:	8a 95       	dec	r24
     17e:	e2 f7       	brpl	.-8      	; 0x178 <Btn_Init+0xa>
     180:	cb 01       	movw	r24, r22
     182:	96 2f       	mov	r25, r22
     184:	90 95       	com	r25
     186:	49 23       	and	r20, r25
     188:	41 bb       	out	0x11, r20	; 17
	BUTTONS_PORT |=  (1<<btn);  /* Pullup */
     18a:	22 b3       	in	r18, 0x12	; 18
     18c:	82 2b       	or	r24, r18
     18e:	82 bb       	out	0x12, r24	; 18
}
     190:	08 95       	ret

00000192 <Btn_IsPressed>:
Bool Btn_IsPressed(Button btn){
	return ( (BUTTONS_PINR&(1<<btn)) == 0 );
     192:	20 b3       	in	r18, 0x10	; 16
     194:	30 e0       	ldi	r19, 0x00	; 0
     196:	02 c0       	rjmp	.+4      	; 0x19c <Btn_IsPressed+0xa>
     198:	35 95       	asr	r19
     19a:	27 95       	ror	r18
     19c:	8a 95       	dec	r24
     19e:	e2 f7       	brpl	.-8      	; 0x198 <Btn_IsPressed+0x6>
     1a0:	81 e0       	ldi	r24, 0x01	; 1
     1a2:	20 fd       	sbrc	r18, 0
     1a4:	80 e0       	ldi	r24, 0x00	; 0
}
     1a6:	08 95       	ret

000001a8 <Buz_On>:
void Buz_Init(void){
	BUZZER_DDR |= (1<<BUZZER_PIN);	/* Out */
	Buz_Off();						/* Default Off */	
}
void Buz_On(void){
	BUZZER_PORT |= (1<<BUZZER_PIN);
     1a8:	97 9a       	sbi	0x12, 7	; 18
}
     1aa:	08 95       	ret

000001ac <Buz_Off>:
void Buz_Off(void){
	BUZZER_PORT &= ~(1<<BUZZER_PIN);
     1ac:	97 98       	cbi	0x12, 7	; 18
}
     1ae:	08 95       	ret

000001b0 <Buz_Init>:
	return ( (BUTTONS_PINR&(1<<btn)) == 0 );
}

/* Buzzer */
void Buz_Init(void){
	BUZZER_DDR |= (1<<BUZZER_PIN);	/* Out */
     1b0:	8f 9a       	sbi	0x11, 7	; 17
	Buz_Off();						/* Default Off */	
     1b2:	0e 94 d6 00 	call	0x1ac	; 0x1ac <Buz_Off>
}
     1b6:	08 95       	ret

000001b8 <Buz_Toggle>:
}
void Buz_Off(void){
	BUZZER_PORT &= ~(1<<BUZZER_PIN);
}
void Buz_Toggle(void){
	BUZZER_PORT ^= (1<<BUZZER_PIN);
     1b8:	82 b3       	in	r24, 0x12	; 18
     1ba:	80 58       	subi	r24, 0x80	; 128
     1bc:	82 bb       	out	0x12, r24	; 18
     1be:	08 95       	ret

000001c0 <Int_EEPROM_Write>:
}

Bool Int_EEPROM_Write(u16 address , u8 data)
{
	Bool result = FALSE;
	if(address <= INT_EEPROM_SIZE)
     1c0:	20 e1       	ldi	r18, 0x10	; 16
     1c2:	80 30       	cpi	r24, 0x00	; 0
     1c4:	92 07       	cpc	r25, r18
     1c6:	48 f4       	brcc	.+18     	; 0x1da <Int_EEPROM_Write+0x1a>
	{
		while((EECR & (1<<EEWE)));
     1c8:	e1 99       	sbic	0x1c, 1	; 28
     1ca:	fe cf       	rjmp	.-4      	; 0x1c8 <Int_EEPROM_Write+0x8>
		EEAR = address;
     1cc:	9f bb       	out	0x1f, r25	; 31
     1ce:	8e bb       	out	0x1e, r24	; 30
		EEDR = data;
     1d0:	6d bb       	out	0x1d, r22	; 29
		EECR |= (1<<EEMWE);
     1d2:	e2 9a       	sbi	0x1c, 2	; 28
		EECR |= (1<<EEWE);
     1d4:	e1 9a       	sbi	0x1c, 1	; 28
		result = TRUE;
     1d6:	81 e0       	ldi	r24, 0x01	; 1
     1d8:	08 95       	ret
	return result;
}

Bool Int_EEPROM_Write(u16 address , u8 data)
{
	Bool result = FALSE;
     1da:	80 e0       	ldi	r24, 0x00	; 0
		EECR |= (1<<EEMWE);
		EECR |= (1<<EEWE);
		result = TRUE;
	}
	return result;
}
     1dc:	08 95       	ret

000001de <Int_EEPROM_Read>:
Bool Int_EEPROM_Read(u16 address , u8* data)
{
	Bool result = FALSE;
	if(address <= INT_EEPROM_SIZE)
     1de:	20 e1       	ldi	r18, 0x10	; 16
     1e0:	80 30       	cpi	r24, 0x00	; 0
     1e2:	92 07       	cpc	r25, r18
     1e4:	50 f4       	brcc	.+20     	; 0x1fa <Int_EEPROM_Read+0x1c>
	{
		while((EECR & (1<<EEWE)));
     1e6:	e1 99       	sbic	0x1c, 1	; 28
     1e8:	fe cf       	rjmp	.-4      	; 0x1e6 <Int_EEPROM_Read+0x8>
		EEAR  = address;
     1ea:	9f bb       	out	0x1f, r25	; 31
     1ec:	8e bb       	out	0x1e, r24	; 30
		EECR |= (1<<EERE);
     1ee:	e0 9a       	sbi	0x1c, 0	; 28
		*data = EEDR;
     1f0:	8d b3       	in	r24, 0x1d	; 29
     1f2:	fb 01       	movw	r30, r22
     1f4:	80 83       	st	Z, r24
		result = TRUE;
     1f6:	81 e0       	ldi	r24, 0x01	; 1
     1f8:	08 95       	ret
	}
	return result;
}
Bool Int_EEPROM_Read(u16 address , u8* data)
{
	Bool result = FALSE;
     1fa:	80 e0       	ldi	r24, 0x00	; 0
		EECR |= (1<<EERE);
		*data = EEDR;
		result = TRUE;
	}
	return result;
     1fc:	08 95       	ret

000001fe <EEPROM_Update>:
#include "Internal_EEPROM.h"

Bool EEPROM_Update(u16 address , u8 data)
{
     1fe:	ff 92       	push	r15
     200:	0f 93       	push	r16
     202:	1f 93       	push	r17
     204:	cf 93       	push	r28
     206:	df 93       	push	r29
     208:	0f 92       	push	r0
     20a:	cd b7       	in	r28, 0x3d	; 61
     20c:	de b7       	in	r29, 0x3e	; 62
     20e:	8c 01       	movw	r16, r24
     210:	f6 2e       	mov	r15, r22
	Bool result = FALSE;
	u8 LocalData ;
	Int_EEPROM_Read(address , &LocalData);
     212:	be 01       	movw	r22, r28
     214:	6f 5f       	subi	r22, 0xFF	; 255
     216:	7f 4f       	sbci	r23, 0xFF	; 255
     218:	0e 94 ef 00 	call	0x1de	; 0x1de <Int_EEPROM_Read>
	if(LocalData != data)
     21c:	89 81       	ldd	r24, Y+1	; 0x01
     21e:	8f 15       	cp	r24, r15
     220:	69 f0       	breq	.+26     	; 0x23c <EEPROM_Update+0x3e>
	{
		if(address <= INT_EEPROM_SIZE)
     222:	80 e1       	ldi	r24, 0x10	; 16
     224:	00 30       	cpi	r16, 0x00	; 0
     226:	18 07       	cpc	r17, r24
     228:	58 f4       	brcc	.+22     	; 0x240 <EEPROM_Update+0x42>
		{
			while((EECR & (1<<EEWE)));
     22a:	e1 99       	sbic	0x1c, 1	; 28
     22c:	fe cf       	rjmp	.-4      	; 0x22a <EEPROM_Update+0x2c>
			EEAR = address;
     22e:	1f bb       	out	0x1f, r17	; 31
     230:	0e bb       	out	0x1e, r16	; 30
			EEDR = data;
     232:	fd ba       	out	0x1d, r15	; 29
			EECR |= (1<<EEMWE);
     234:	e2 9a       	sbi	0x1c, 2	; 28
			EECR |= (1<<EEWE);
     236:	e1 9a       	sbi	0x1c, 1	; 28
			result = TRUE;
     238:	81 e0       	ldi	r24, 0x01	; 1
     23a:	03 c0       	rjmp	.+6      	; 0x242 <EEPROM_Update+0x44>
#include "Internal_EEPROM.h"

Bool EEPROM_Update(u16 address , u8 data)
{
	Bool result = FALSE;
     23c:	80 e0       	ldi	r24, 0x00	; 0
     23e:	01 c0       	rjmp	.+2      	; 0x242 <EEPROM_Update+0x44>
     240:	80 e0       	ldi	r24, 0x00	; 0
			EECR |= (1<<EEWE);
			result = TRUE;
		}
	}
	return result;
}
     242:	0f 90       	pop	r0
     244:	df 91       	pop	r29
     246:	cf 91       	pop	r28
     248:	1f 91       	pop	r17
     24a:	0f 91       	pop	r16
     24c:	ff 90       	pop	r15
     24e:	08 95       	ret

00000250 <LCD_Latch>:
	{
		LCD_SendCMD((0x40|0x80) + col -1);
	}
}
static void LCD_Latch(void){
	setBit(LCD_CTRL_PORT, LCD_EN_PIN);
     250:	c0 9a       	sbi	0x18, 0	; 24
	clearBit(LCD_CTRL_PORT, LCD_EN_PIN);
     252:	c0 98       	cbi	0x18, 0	; 24
}
     254:	08 95       	ret

00000256 <LCD_SendCMD>:
void LCD_DispStrXY(u8 row, u8 col, u8* pu8Str){
	LCD_GoToXY(row,col);
	LCD_DispStr(pu8Str);
}

static void LCD_SendCMD(u8 u8CMD){
     256:	cf 93       	push	r28
     258:	c8 2f       	mov	r28, r24
	/* RS = 0 */
	clearBit(LCD_CTRL_PORT, LCD_RS_PIN);
     25a:	c1 98       	cbi	0x18, 1	; 24
	/* upload most 4 bits and then latch */
	LCD_DATA_REG.HN = (u8CMD>>4);
     25c:	98 2f       	mov	r25, r24
     25e:	90 7f       	andi	r25, 0xF0	; 240
     260:	85 b3       	in	r24, 0x15	; 21
     262:	8f 70       	andi	r24, 0x0F	; 15
     264:	89 2b       	or	r24, r25
     266:	85 bb       	out	0x15, r24	; 21
	LCD_Latch();
     268:	0e 94 28 01 	call	0x250	; 0x250 <LCD_Latch>
	/* upload least 4 bits and then latch */
	LCD_DATA_REG.HN = u8CMD;
     26c:	c2 95       	swap	r28
     26e:	c0 7f       	andi	r28, 0xF0	; 240
     270:	85 b3       	in	r24, 0x15	; 21
     272:	8f 70       	andi	r24, 0x0F	; 15
     274:	c8 2b       	or	r28, r24
     276:	c5 bb       	out	0x15, r28	; 21
	LCD_Latch();
     278:	0e 94 28 01 	call	0x250	; 0x250 <LCD_Latch>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     27c:	8a e6       	ldi	r24, 0x6A	; 106
     27e:	8a 95       	dec	r24
     280:	f1 f7       	brne	.-4      	; 0x27e <LCD_SendCMD+0x28>
     282:	00 c0       	rjmp	.+0      	; 0x284 <LCD_SendCMD+0x2e>
	/* delay 40 us */
	_delay_us(40);
}
     284:	cf 91       	pop	r28
     286:	08 95       	ret

00000288 <LCD_GoToXY>:
	LCD_Latch();
	/* delay 40 us */
	_delay_us(40);
}
static void LCD_GoToXY(u8 row, u8 col){
	if (row == 1)
     288:	81 30       	cpi	r24, 0x01	; 1
     28a:	29 f4       	brne	.+10     	; 0x296 <LCD_GoToXY+0xe>
	{
		LCD_SendCMD((0x00|0x80) + col -1);
     28c:	86 2f       	mov	r24, r22
     28e:	81 58       	subi	r24, 0x81	; 129
     290:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
     294:	08 95       	ret
	}
	else
	{
		LCD_SendCMD((0x40|0x80) + col -1);
     296:	86 2f       	mov	r24, r22
     298:	81 54       	subi	r24, 0x41	; 65
     29a:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
     29e:	08 95       	ret

000002a0 <LCD_SendData>:
	LCD_DATA_REG.HN = u8CMD;
	LCD_Latch();
	/* delay 40 us */
	_delay_us(40);
}
static void LCD_SendData(u8 u8Data){
     2a0:	cf 93       	push	r28
     2a2:	c8 2f       	mov	r28, r24
	/* RS = 1 */
	setBit(LCD_CTRL_PORT, LCD_RS_PIN);
     2a4:	c1 9a       	sbi	0x18, 1	; 24
	/* upload most 4 bits and then latch */
	LCD_DATA_REG.HN = (u8Data>>4);
     2a6:	98 2f       	mov	r25, r24
     2a8:	90 7f       	andi	r25, 0xF0	; 240
     2aa:	85 b3       	in	r24, 0x15	; 21
     2ac:	8f 70       	andi	r24, 0x0F	; 15
     2ae:	89 2b       	or	r24, r25
     2b0:	85 bb       	out	0x15, r24	; 21
	LCD_Latch();
     2b2:	0e 94 28 01 	call	0x250	; 0x250 <LCD_Latch>
	/* upload least 4 bits and then latch */
	LCD_DATA_REG.HN = u8Data;
     2b6:	c2 95       	swap	r28
     2b8:	c0 7f       	andi	r28, 0xF0	; 240
     2ba:	85 b3       	in	r24, 0x15	; 21
     2bc:	8f 70       	andi	r24, 0x0F	; 15
     2be:	c8 2b       	or	r28, r24
     2c0:	c5 bb       	out	0x15, r28	; 21
	LCD_Latch();
     2c2:	0e 94 28 01 	call	0x250	; 0x250 <LCD_Latch>
     2c6:	8a e6       	ldi	r24, 0x6A	; 106
     2c8:	8a 95       	dec	r24
     2ca:	f1 f7       	brne	.-4      	; 0x2c8 <LCD_SendData+0x28>
     2cc:	00 c0       	rjmp	.+0      	; 0x2ce <LCD_SendData+0x2e>
	/* delay 40 us */
	_delay_us(40);
}
     2ce:	cf 91       	pop	r28
     2d0:	08 95       	ret

000002d2 <LCD_Clear>:
	LCD_SendCMD(CMD_DISP_ON);
	LCD_SendCMD(CMD_ENTRY_MODE);
	LCD_Clear();
}
void LCD_Clear(void){
	LCD_SendCMD(CMD_CLEAR);
     2d2:	81 e0       	ldi	r24, 0x01	; 1
     2d4:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     2d8:	8f e0       	ldi	r24, 0x0F	; 15
     2da:	97 e2       	ldi	r25, 0x27	; 39
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	f1 f7       	brne	.-4      	; 0x2dc <LCD_Clear+0xa>
     2e0:	00 c0       	rjmp	.+0      	; 0x2e2 <LCD_Clear+0x10>
     2e2:	00 00       	nop
	_delay_ms(5);
}
     2e4:	08 95       	ret

000002e6 <LCD_Init>:
static void LCD_Latch(void);

/* Functions */
void LCD_Init(void){
	/* Out */
	setBits(LCD_DATA_DDR, LCD_DATA_MSK);
     2e6:	84 b3       	in	r24, 0x14	; 20
     2e8:	80 6f       	ori	r24, 0xF0	; 240
     2ea:	84 bb       	out	0x14, r24	; 20
	setBit(LCD_CTRL_DDR, LCD_RS_PIN);
     2ec:	b9 9a       	sbi	0x17, 1	; 23
	setBit(LCD_CTRL_DDR, LCD_EN_PIN);
     2ee:	b8 9a       	sbi	0x17, 0	; 23
     2f0:	8f ef       	ldi	r24, 0xFF	; 255
     2f2:	90 e7       	ldi	r25, 0x70	; 112
     2f4:	a2 e0       	ldi	r26, 0x02	; 2
     2f6:	81 50       	subi	r24, 0x01	; 1
     2f8:	90 40       	sbci	r25, 0x00	; 0
     2fa:	a0 40       	sbci	r26, 0x00	; 0
     2fc:	e1 f7       	brne	.-8      	; 0x2f6 <LCD_Init+0x10>
     2fe:	00 c0       	rjmp	.+0      	; 0x300 <LCD_Init+0x1a>
     300:	00 00       	nop
	_delay_ms(100);
	LCD_SendCMD(CMD_FUN_SET_4BIT);	/* Required: to set 4Bit operation */			
     302:	82 e0       	ldi	r24, 0x02	; 2
     304:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
	LCD_SendCMD(CMD_CFG);			/* Full CFG */		
     308:	88 e2       	ldi	r24, 0x28	; 40
     30a:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
	LCD_SendCMD(CMD_DISP_ON);
     30e:	8c e0       	ldi	r24, 0x0C	; 12
     310:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
	LCD_SendCMD(CMD_ENTRY_MODE);
     314:	86 e0       	ldi	r24, 0x06	; 6
     316:	0e 94 2b 01 	call	0x256	; 0x256 <LCD_SendCMD>
	LCD_Clear();
     31a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <LCD_Clear>
}
     31e:	08 95       	ret

00000320 <LCD_DispChar>:
void LCD_Clear(void){
	LCD_SendCMD(CMD_CLEAR);
	_delay_ms(5);
}
void LCD_DispChar(u8 u8Char){
	LCD_SendData(u8Char);
     320:	0e 94 50 01 	call	0x2a0	; 0x2a0 <LCD_SendData>
}
     324:	08 95       	ret

00000326 <LCD_DispStr>:
void LCD_DispStr(u8* pu8Str){
     326:	0f 93       	push	r16
     328:	1f 93       	push	r17
     32a:	cf 93       	push	r28
     32c:	8c 01       	movw	r16, r24
	u8 ind = 0;
	while(pu8Str[ind]){
     32e:	fc 01       	movw	r30, r24
     330:	80 81       	ld	r24, Z
     332:	88 23       	and	r24, r24
     334:	51 f0       	breq	.+20     	; 0x34a <LCD_DispStr+0x24>
}
void LCD_DispChar(u8 u8Char){
	LCD_SendData(u8Char);
}
void LCD_DispStr(u8* pu8Str){
	u8 ind = 0;
     336:	c0 e0       	ldi	r28, 0x00	; 0
	while(pu8Str[ind]){
		LCD_SendData(pu8Str[ind]);
     338:	0e 94 50 01 	call	0x2a0	; 0x2a0 <LCD_SendData>
		ind++;
     33c:	cf 5f       	subi	r28, 0xFF	; 255
void LCD_DispChar(u8 u8Char){
	LCD_SendData(u8Char);
}
void LCD_DispStr(u8* pu8Str){
	u8 ind = 0;
	while(pu8Str[ind]){
     33e:	f8 01       	movw	r30, r16
     340:	ec 0f       	add	r30, r28
     342:	f1 1d       	adc	r31, r1
     344:	80 81       	ld	r24, Z
     346:	88 23       	and	r24, r24
     348:	b9 f7       	brne	.-18     	; 0x338 <LCD_DispStr+0x12>
		LCD_SendData(pu8Str[ind]);
		ind++;
	}
}
     34a:	cf 91       	pop	r28
     34c:	1f 91       	pop	r17
     34e:	0f 91       	pop	r16
     350:	08 95       	ret

00000352 <LCD_DispCharXY>:
/* row: 1-2  - col: 1-16 */
void LCD_DispCharXY(u8 row, u8 col, u8 u8Char){
     352:	cf 93       	push	r28
     354:	c4 2f       	mov	r28, r20
	LCD_GoToXY(row,col);
     356:	0e 94 44 01 	call	0x288	; 0x288 <LCD_GoToXY>
	LCD_DispChar(u8Char);
     35a:	8c 2f       	mov	r24, r28
     35c:	0e 94 90 01 	call	0x320	; 0x320 <LCD_DispChar>
}
     360:	cf 91       	pop	r28
     362:	08 95       	ret

00000364 <LCD_DispStrXY>:
void LCD_DispStrXY(u8 row, u8 col, u8* pu8Str){
     364:	cf 93       	push	r28
     366:	df 93       	push	r29
     368:	ea 01       	movw	r28, r20
	LCD_GoToXY(row,col);
     36a:	0e 94 44 01 	call	0x288	; 0x288 <LCD_GoToXY>
	LCD_DispStr(pu8Str);
     36e:	ce 01       	movw	r24, r28
     370:	0e 94 93 01 	call	0x326	; 0x326 <LCD_DispStr>
}
     374:	df 91       	pop	r29
     376:	cf 91       	pop	r28
     378:	08 95       	ret

0000037a <LCD_DispInt>:
}
static void LCD_Latch(void){
	setBit(LCD_CTRL_PORT, LCD_EN_PIN);
	clearBit(LCD_CTRL_PORT, LCD_EN_PIN);
}
void LCD_DispInt(u32 data){
     37a:	0f 93       	push	r16
     37c:	1f 93       	push	r17
     37e:	cf 93       	push	r28
     380:	df 93       	push	r29
     382:	cd b7       	in	r28, 0x3d	; 61
     384:	de b7       	in	r29, 0x3e	; 62
     386:	2b 97       	sbiw	r28, 0x0b	; 11
     388:	0f b6       	in	r0, 0x3f	; 63
     38a:	f8 94       	cli
     38c:	de bf       	out	0x3e, r29	; 62
     38e:	0f be       	out	0x3f, r0	; 63
     390:	cd bf       	out	0x3d, r28	; 61
     392:	dc 01       	movw	r26, r24
     394:	cb 01       	movw	r24, r22
	u8 dataStr[11] = {0};
     396:	8e 01       	movw	r16, r28
     398:	0f 5f       	subi	r16, 0xFF	; 255
     39a:	1f 4f       	sbci	r17, 0xFF	; 255
     39c:	2b e0       	ldi	r18, 0x0B	; 11
     39e:	f8 01       	movw	r30, r16
     3a0:	11 92       	st	Z+, r1
     3a2:	2a 95       	dec	r18
     3a4:	e9 f7       	brne	.-6      	; 0x3a0 <LCD_DispInt+0x26>
	itoa(data,dataStr,10);
     3a6:	b8 01       	movw	r22, r16
     3a8:	4a e0       	ldi	r20, 0x0A	; 10
     3aa:	50 e0       	ldi	r21, 0x00	; 0
     3ac:	0e 94 eb 19 	call	0x33d6	; 0x33d6 <itoa>
	LCD_DispStr(dataStr);
     3b0:	c8 01       	movw	r24, r16
     3b2:	0e 94 93 01 	call	0x326	; 0x326 <LCD_DispStr>
}
     3b6:	2b 96       	adiw	r28, 0x0b	; 11
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	1f 91       	pop	r17
     3c8:	0f 91       	pop	r16
     3ca:	08 95       	ret

000003cc <LCD_DispIntXY>:
void LCD_DispIntXY(u8 row, u8 col, u32 data){
     3cc:	cf 92       	push	r12
     3ce:	df 92       	push	r13
     3d0:	ef 92       	push	r14
     3d2:	ff 92       	push	r15
     3d4:	69 01       	movw	r12, r18
     3d6:	7a 01       	movw	r14, r20
	LCD_GoToXY(row,col);
     3d8:	0e 94 44 01 	call	0x288	; 0x288 <LCD_GoToXY>
	LCD_DispInt(data);
     3dc:	c7 01       	movw	r24, r14
     3de:	b6 01       	movw	r22, r12
     3e0:	0e 94 bd 01 	call	0x37a	; 0x37a <LCD_DispInt>
}
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	08 95       	ret

000003ee <Uart_Init>:
#include "uart.h"
/* default: 8N1  */
void	Uart_Init(u32 baudRate){
     3ee:	dc 01       	movw	r26, r24
     3f0:	cb 01       	movw	r24, r22
	/* BR = (clock/(16*baud)) - 1*/
	u32 BRValue = (F_CPU/(16UL*baudRate)) - 1;
     3f2:	88 0f       	add	r24, r24
     3f4:	99 1f       	adc	r25, r25
     3f6:	aa 1f       	adc	r26, r26
     3f8:	bb 1f       	adc	r27, r27
     3fa:	88 0f       	add	r24, r24
     3fc:	99 1f       	adc	r25, r25
     3fe:	aa 1f       	adc	r26, r26
     400:	bb 1f       	adc	r27, r27
     402:	9c 01       	movw	r18, r24
     404:	ad 01       	movw	r20, r26
     406:	22 0f       	add	r18, r18
     408:	33 1f       	adc	r19, r19
     40a:	44 1f       	adc	r20, r20
     40c:	55 1f       	adc	r21, r21
     40e:	22 0f       	add	r18, r18
     410:	33 1f       	adc	r19, r19
     412:	44 1f       	adc	r20, r20
     414:	55 1f       	adc	r21, r21
     416:	60 e0       	ldi	r22, 0x00	; 0
     418:	72 e1       	ldi	r23, 0x12	; 18
     41a:	8a e7       	ldi	r24, 0x7A	; 122
     41c:	90 e0       	ldi	r25, 0x00	; 0
     41e:	0e 94 a5 19 	call	0x334a	; 0x334a <__udivmodsi4>
     422:	da 01       	movw	r26, r20
     424:	c9 01       	movw	r24, r18
     426:	01 97       	sbiw	r24, 0x01	; 1
     428:	a1 09       	sbc	r26, r1
     42a:	b1 09       	sbc	r27, r1
	
	/* Set baud rate */
	UCSRC &= ~(1<<URSEL);
     42c:	20 b5       	in	r18, 0x20	; 32
     42e:	2f 77       	andi	r18, 0x7F	; 127
     430:	20 bd       	out	0x20, r18	; 32
	UBRRH = (u8)(BRValue>>8);
     432:	49 2f       	mov	r20, r25
     434:	5a 2f       	mov	r21, r26
     436:	6b 2f       	mov	r22, r27
     438:	77 27       	eor	r23, r23
     43a:	40 bd       	out	0x20, r20	; 32
	UBRRL = (u8)BRValue;
     43c:	89 b9       	out	0x09, r24	; 9
	
	/* Enable receiver and transmitter */
	UCSRB = (1<<RXEN)|(1<<TXEN);//|(1<<RXCIE);
     43e:	88 e1       	ldi	r24, 0x18	; 24
     440:	8a b9       	out	0x0a, r24	; 10
	/* Set frame format: 8data, 2stop bit */
	UCSRC = (1<<URSEL)|(3<<UCSZ0);
     442:	86 e8       	ldi	r24, 0x86	; 134
     444:	80 bd       	out	0x20, r24	; 32
//	sei();
}
     446:	08 95       	ret

00000448 <Uart_SendByte>:
void	Uart_SendByte(u8 data){
	/* Wait for empty transmit buffer */
	while ( !( UCSRA & (1<<UDRE)) );
     448:	5d 9b       	sbis	0x0b, 5	; 11
     44a:	fe cf       	rjmp	.-4      	; 0x448 <Uart_SendByte>
	/* Put data into buffer, sends the data */
	UDR = data;
     44c:	8c b9       	out	0x0c, r24	; 12
}
     44e:	08 95       	ret

00000450 <Uart_ReceiveByte>:
void	Uart_ReceiveByte(u8* pData){
	/* Wait for data to be received */
	while ( !(UCSRA & (1<<RXC)) );
     450:	5f 9b       	sbis	0x0b, 7	; 11
     452:	fe cf       	rjmp	.-4      	; 0x450 <Uart_ReceiveByte>
	/* Get and return received data from buffer */
	(*pData) =  UDR;
     454:	2c b1       	in	r18, 0x0c	; 12
     456:	fc 01       	movw	r30, r24
     458:	20 83       	st	Z, r18
}
     45a:	08 95       	ret

0000045c <Uart_ReceiveByte_Unblock>:
Bool	Uart_ReceiveByte_Unblock(u8* pData){
	Bool result = FALSE;
	if(UCSRA & (1<<RXC)){
     45c:	5f 9b       	sbis	0x0b, 7	; 11
     45e:	05 c0       	rjmp	.+10     	; 0x46a <Uart_ReceiveByte_Unblock+0xe>
		(*pData) =  UDR;
     460:	2c b1       	in	r18, 0x0c	; 12
     462:	fc 01       	movw	r30, r24
     464:	20 83       	st	Z, r18
		result =  TRUE;
     466:	81 e0       	ldi	r24, 0x01	; 1
     468:	08 95       	ret
	}
	else{
		result = FALSE;
     46a:	80 e0       	ldi	r24, 0x00	; 0
	}
	return result;
}
     46c:	08 95       	ret

0000046e <Uart_SendStr>:
void	Uart_SendStr(u8* str){
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	ec 01       	movw	r28, r24
	u32 ind = 0;
	while(str[ind] != 0){
     474:	88 81       	ld	r24, Y
     476:	88 23       	and	r24, r24
     478:	31 f0       	breq	.+12     	; 0x486 <Uart_SendStr+0x18>
	else{
		result = FALSE;
	}
	return result;
}
void	Uart_SendStr(u8* str){
     47a:	21 96       	adiw	r28, 0x01	; 1
	u32 ind = 0;
	while(str[ind] != 0){
		Uart_SendByte(str[ind]);
     47c:	0e 94 24 02 	call	0x448	; 0x448 <Uart_SendByte>
	}
	return result;
}
void	Uart_SendStr(u8* str){
	u32 ind = 0;
	while(str[ind] != 0){
     480:	89 91       	ld	r24, Y+
     482:	88 23       	and	r24, r24
     484:	d9 f7       	brne	.-10     	; 0x47c <Uart_SendStr+0xe>
		Uart_SendByte(str[ind]);
		ind++;
	}
}
     486:	df 91       	pop	r29
     488:	cf 91       	pop	r28
     48a:	08 95       	ret

0000048c <__vector_13>:

ISR(USART_RXC_vect){
     48c:	1f 92       	push	r1
     48e:	0f 92       	push	r0
     490:	0f b6       	in	r0, 0x3f	; 63
     492:	0f 92       	push	r0
     494:	11 24       	eor	r1, r1
     496:	2f 93       	push	r18
     498:	3f 93       	push	r19
     49a:	4f 93       	push	r20
     49c:	5f 93       	push	r21
     49e:	6f 93       	push	r22
     4a0:	7f 93       	push	r23
     4a2:	8f 93       	push	r24
     4a4:	9f 93       	push	r25
     4a6:	af 93       	push	r26
     4a8:	bf 93       	push	r27
     4aa:	ef 93       	push	r30
     4ac:	ff 93       	push	r31
	LCD_DispCharXY(2,5,UDR);
     4ae:	4c b1       	in	r20, 0x0c	; 12
     4b0:	82 e0       	ldi	r24, 0x02	; 2
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	65 e0       	ldi	r22, 0x05	; 5
     4b6:	70 e0       	ldi	r23, 0x00	; 0
     4b8:	50 e0       	ldi	r21, 0x00	; 0
     4ba:	0e 94 a9 01 	call	0x352	; 0x352 <LCD_DispCharXY>
     4be:	ff 91       	pop	r31
     4c0:	ef 91       	pop	r30
     4c2:	bf 91       	pop	r27
     4c4:	af 91       	pop	r26
     4c6:	9f 91       	pop	r25
     4c8:	8f 91       	pop	r24
     4ca:	7f 91       	pop	r23
     4cc:	6f 91       	pop	r22
     4ce:	5f 91       	pop	r21
     4d0:	4f 91       	pop	r20
     4d2:	3f 91       	pop	r19
     4d4:	2f 91       	pop	r18
     4d6:	0f 90       	pop	r0
     4d8:	0f be       	out	0x3f, r0	; 63
     4da:	0f 90       	pop	r0
     4dc:	1f 90       	pop	r1
     4de:	18 95       	reti

000004e0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     4e0:	af 92       	push	r10
     4e2:	bf 92       	push	r11
     4e4:	cf 92       	push	r12
     4e6:	df 92       	push	r13
     4e8:	ef 92       	push	r14
     4ea:	ff 92       	push	r15
     4ec:	0f 93       	push	r16
     4ee:	1f 93       	push	r17
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	6c 01       	movw	r12, r24
     4f6:	e6 2e       	mov	r14, r22
     4f8:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     4fa:	8a e1       	ldi	r24, 0x1A	; 26
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
     502:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     504:	00 97       	sbiw	r24, 0x00	; 0
     506:	09 f4       	brne	.+2      	; 0x50a <xCoRoutineCreate+0x2a>
     508:	62 c0       	rjmp	.+196    	; 0x5ce <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     50a:	80 91 c8 01 	lds	r24, 0x01C8
     50e:	90 91 c9 01 	lds	r25, 0x01C9
     512:	00 97       	sbiw	r24, 0x00	; 0
     514:	39 f5       	brne	.+78     	; 0x564 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     516:	10 93 c9 01 	sts	0x01C9, r17
     51a:	00 93 c8 01 	sts	0x01C8, r16
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     51e:	cb ec       	ldi	r28, 0xCB	; 203
     520:	d1 e0       	ldi	r29, 0x01	; 1
     522:	ce 01       	movw	r24, r28
     524:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
     528:	ce 01       	movw	r24, r28
     52a:	09 96       	adiw	r24, 0x09	; 9
     52c:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     530:	cd ed       	ldi	r28, 0xDD	; 221
     532:	d1 e0       	ldi	r29, 0x01	; 1
     534:	ce 01       	movw	r24, r28
     536:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     53a:	0f 2e       	mov	r0, r31
     53c:	f6 ee       	ldi	r31, 0xE6	; 230
     53e:	af 2e       	mov	r10, r31
     540:	f1 e0       	ldi	r31, 0x01	; 1
     542:	bf 2e       	mov	r11, r31
     544:	f0 2d       	mov	r31, r0
     546:	c5 01       	movw	r24, r10
     548:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     54c:	8f ee       	ldi	r24, 0xEF	; 239
     54e:	91 e0       	ldi	r25, 0x01	; 1
     550:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     554:	d0 93 f9 01 	sts	0x01F9, r29
     558:	c0 93 f8 01 	sts	0x01F8, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     55c:	b0 92 fb 01 	sts	0x01FB, r11
     560:	a0 92 fa 01 	sts	0x01FA, r10
     564:	ce 2d       	mov	r28, r14
     566:	e1 10       	cpse	r14, r1
     568:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     56a:	f8 01       	movw	r30, r16
     56c:	11 8e       	std	Z+25, r1	; 0x19
     56e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     570:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     572:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     574:	c1 92       	st	Z+, r12
     576:	d1 92       	st	Z+, r13
     578:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     57a:	cf 01       	movw	r24, r30
     57c:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     580:	c8 01       	movw	r24, r16
     582:	0c 96       	adiw	r24, 0x0c	; 12
     584:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     588:	f8 01       	movw	r30, r16
     58a:	11 87       	std	Z+9, r17	; 0x09
     58c:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     58e:	13 8b       	std	Z+19, r17	; 0x13
     590:	02 8b       	std	Z+18, r16	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     592:	82 e0       	ldi	r24, 0x02	; 2
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	8c 1b       	sub	r24, r28
     598:	91 09       	sbc	r25, r1
     59a:	95 87       	std	Z+13, r25	; 0x0d
     59c:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     59e:	86 89       	ldd	r24, Z+22	; 0x16
     5a0:	90 91 ca 01 	lds	r25, 0x01CA
     5a4:	98 17       	cp	r25, r24
     5a6:	10 f4       	brcc	.+4      	; 0x5ac <xCoRoutineCreate+0xcc>
     5a8:	80 93 ca 01 	sts	0x01CA, r24
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	9c 01       	movw	r18, r24
     5b0:	22 0f       	add	r18, r18
     5b2:	33 1f       	adc	r19, r19
     5b4:	22 0f       	add	r18, r18
     5b6:	33 1f       	adc	r19, r19
     5b8:	22 0f       	add	r18, r18
     5ba:	33 1f       	adc	r19, r19
     5bc:	82 0f       	add	r24, r18
     5be:	93 1f       	adc	r25, r19
     5c0:	85 53       	subi	r24, 0x35	; 53
     5c2:	9e 4f       	sbci	r25, 0xFE	; 254
     5c4:	b7 01       	movw	r22, r14
     5c6:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

		xReturn = pdPASS;
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	01 c0       	rjmp	.+2      	; 0x5d0 <xCoRoutineCreate+0xf0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     5ce:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     5d0:	df 91       	pop	r29
     5d2:	cf 91       	pop	r28
     5d4:	1f 91       	pop	r17
     5d6:	0f 91       	pop	r16
     5d8:	ff 90       	pop	r15
     5da:	ef 90       	pop	r14
     5dc:	df 90       	pop	r13
     5de:	cf 90       	pop	r12
     5e0:	bf 90       	pop	r11
     5e2:	af 90       	pop	r10
     5e4:	08 95       	ret

000005e6 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     5e6:	0f 93       	push	r16
     5e8:	1f 93       	push	r17
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     5f0:	c0 91 fc 01 	lds	r28, 0x01FC
     5f4:	d0 91 fd 01 	lds	r29, 0x01FD
     5f8:	c8 0f       	add	r28, r24
     5fa:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     5fc:	80 91 c8 01 	lds	r24, 0x01C8
     600:	90 91 c9 01 	lds	r25, 0x01C9
     604:	02 96       	adiw	r24, 0x02	; 2
     606:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     60a:	e0 91 c8 01 	lds	r30, 0x01C8
     60e:	f0 91 c9 01 	lds	r31, 0x01C9
     612:	d3 83       	std	Z+3, r29	; 0x03
     614:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     616:	80 91 fc 01 	lds	r24, 0x01FC
     61a:	90 91 fd 01 	lds	r25, 0x01FD
     61e:	c8 17       	cp	r28, r24
     620:	d9 07       	cpc	r29, r25
     622:	50 f4       	brcc	.+20     	; 0x638 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     624:	bf 01       	movw	r22, r30
     626:	6e 5f       	subi	r22, 0xFE	; 254
     628:	7f 4f       	sbci	r23, 0xFF	; 255
     62a:	80 91 fa 01 	lds	r24, 0x01FA
     62e:	90 91 fb 01 	lds	r25, 0x01FB
     632:	0e 94 42 07 	call	0xe84	; 0xe84 <vListInsert>
     636:	09 c0       	rjmp	.+18     	; 0x64a <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     638:	bf 01       	movw	r22, r30
     63a:	6e 5f       	subi	r22, 0xFE	; 254
     63c:	7f 4f       	sbci	r23, 0xFF	; 255
     63e:	80 91 f8 01 	lds	r24, 0x01F8
     642:	90 91 f9 01 	lds	r25, 0x01F9
     646:	0e 94 42 07 	call	0xe84	; 0xe84 <vListInsert>
	}

	if( pxEventList )
     64a:	01 15       	cp	r16, r1
     64c:	11 05       	cpc	r17, r1
     64e:	49 f0       	breq	.+18     	; 0x662 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     650:	60 91 c8 01 	lds	r22, 0x01C8
     654:	70 91 c9 01 	lds	r23, 0x01C9
     658:	64 5f       	subi	r22, 0xF4	; 244
     65a:	7f 4f       	sbci	r23, 0xFF	; 255
     65c:	c8 01       	movw	r24, r16
     65e:	0e 94 42 07 	call	0xe84	; 0xe84 <vListInsert>
	}
}
     662:	df 91       	pop	r29
     664:	cf 91       	pop	r28
     666:	1f 91       	pop	r17
     668:	0f 91       	pop	r16
     66a:	08 95       	ret

0000066c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     66c:	ef 92       	push	r14
     66e:	ff 92       	push	r15
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     678:	80 91 ef 01 	lds	r24, 0x01EF
     67c:	88 23       	and	r24, r24
     67e:	91 f1       	breq	.+100    	; 0x6e4 <vCoRoutineSchedule+0x78>
     680:	0f 2e       	mov	r0, r31
     682:	ff ee       	ldi	r31, 0xEF	; 239
     684:	ef 2e       	mov	r14, r31
     686:	f1 e0       	ldi	r31, 0x01	; 1
     688:	ff 2e       	mov	r15, r31
     68a:	f0 2d       	mov	r31, r0
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     68c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     68e:	e0 91 f4 01 	lds	r30, 0x01F4
     692:	f0 91 f5 01 	lds	r31, 0x01F5
     696:	c6 81       	ldd	r28, Z+6	; 0x06
     698:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     69a:	ce 01       	movw	r24, r28
     69c:	0c 96       	adiw	r24, 0x0c	; 12
     69e:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     6a2:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     6a4:	8e 01       	movw	r16, r28
     6a6:	0e 5f       	subi	r16, 0xFE	; 254
     6a8:	1f 4f       	sbci	r17, 0xFF	; 255
     6aa:	c8 01       	movw	r24, r16
     6ac:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     6b0:	8e 89       	ldd	r24, Y+22	; 0x16
     6b2:	90 91 ca 01 	lds	r25, 0x01CA
     6b6:	98 17       	cp	r25, r24
     6b8:	10 f4       	brcc	.+4      	; 0x6be <vCoRoutineSchedule+0x52>
     6ba:	80 93 ca 01 	sts	0x01CA, r24
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	9c 01       	movw	r18, r24
     6c2:	22 0f       	add	r18, r18
     6c4:	33 1f       	adc	r19, r19
     6c6:	22 0f       	add	r18, r18
     6c8:	33 1f       	adc	r19, r19
     6ca:	22 0f       	add	r18, r18
     6cc:	33 1f       	adc	r19, r19
     6ce:	82 0f       	add	r24, r18
     6d0:	93 1f       	adc	r25, r19
     6d2:	85 53       	subi	r24, 0x35	; 53
     6d4:	9e 4f       	sbci	r25, 0xFE	; 254
     6d6:	b8 01       	movw	r22, r16
     6d8:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     6dc:	f7 01       	movw	r30, r14
     6de:	80 81       	ld	r24, Z
     6e0:	88 23       	and	r24, r24
     6e2:	a1 f6       	brne	.-88     	; 0x68c <vCoRoutineSchedule+0x20>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     6e4:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <xTaskGetTickCount>
     6e8:	20 91 fe 01 	lds	r18, 0x01FE
     6ec:	30 91 ff 01 	lds	r19, 0x01FF
     6f0:	82 1b       	sub	r24, r18
     6f2:	93 0b       	sbc	r25, r19
     6f4:	90 93 01 02 	sts	0x0201, r25
     6f8:	80 93 00 02 	sts	0x0200, r24
     6fc:	74 c0       	rjmp	.+232    	; 0x7e6 <vCoRoutineSchedule+0x17a>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     6fe:	20 91 fc 01 	lds	r18, 0x01FC
     702:	30 91 fd 01 	lds	r19, 0x01FD
     706:	2f 5f       	subi	r18, 0xFF	; 255
     708:	3f 4f       	sbci	r19, 0xFF	; 255
     70a:	30 93 fd 01 	sts	0x01FD, r19
     70e:	20 93 fc 01 	sts	0x01FC, r18
		xPassedTicks--;
     712:	01 97       	sbiw	r24, 0x01	; 1
     714:	90 93 01 02 	sts	0x0201, r25
     718:	80 93 00 02 	sts	0x0200, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     71c:	21 15       	cp	r18, r1
     71e:	31 05       	cpc	r19, r1
     720:	81 f4       	brne	.+32     	; 0x742 <vCoRoutineSchedule+0xd6>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     722:	80 91 f8 01 	lds	r24, 0x01F8
     726:	90 91 f9 01 	lds	r25, 0x01F9
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     72a:	20 91 fa 01 	lds	r18, 0x01FA
     72e:	30 91 fb 01 	lds	r19, 0x01FB
     732:	30 93 f9 01 	sts	0x01F9, r19
     736:	20 93 f8 01 	sts	0x01F8, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     73a:	90 93 fb 01 	sts	0x01FB, r25
     73e:	80 93 fa 01 	sts	0x01FA, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     742:	e0 91 f8 01 	lds	r30, 0x01F8
     746:	f0 91 f9 01 	lds	r31, 0x01F9
     74a:	80 81       	ld	r24, Z
     74c:	88 23       	and	r24, r24
     74e:	09 f4       	brne	.+2      	; 0x752 <vCoRoutineSchedule+0xe6>
     750:	4a c0       	rjmp	.+148    	; 0x7e6 <vCoRoutineSchedule+0x17a>
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     752:	05 80       	ldd	r0, Z+5	; 0x05
     754:	f6 81       	ldd	r31, Z+6	; 0x06
     756:	e0 2d       	mov	r30, r0
     758:	c6 81       	ldd	r28, Z+6	; 0x06
     75a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     75c:	2a 81       	ldd	r18, Y+2	; 0x02
     75e:	3b 81       	ldd	r19, Y+3	; 0x03
     760:	80 91 fc 01 	lds	r24, 0x01FC
     764:	90 91 fd 01 	lds	r25, 0x01FD
     768:	82 17       	cp	r24, r18
     76a:	93 07       	cpc	r25, r19
     76c:	78 f4       	brcc	.+30     	; 0x78c <vCoRoutineSchedule+0x120>
     76e:	3b c0       	rjmp	.+118    	; 0x7e6 <vCoRoutineSchedule+0x17a>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     770:	05 80       	ldd	r0, Z+5	; 0x05
     772:	f6 81       	ldd	r31, Z+6	; 0x06
     774:	e0 2d       	mov	r30, r0
     776:	c6 81       	ldd	r28, Z+6	; 0x06
     778:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     77a:	2a 81       	ldd	r18, Y+2	; 0x02
     77c:	3b 81       	ldd	r19, Y+3	; 0x03
     77e:	80 91 fc 01 	lds	r24, 0x01FC
     782:	90 91 fd 01 	lds	r25, 0x01FD
     786:	82 17       	cp	r24, r18
     788:	93 07       	cpc	r25, r19
     78a:	68 f1       	brcs	.+90     	; 0x7e6 <vCoRoutineSchedule+0x17a>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     78c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     78e:	8e 01       	movw	r16, r28
     790:	0e 5f       	subi	r16, 0xFE	; 254
     792:	1f 4f       	sbci	r17, 0xFF	; 255
     794:	c8 01       	movw	r24, r16
     796:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     79a:	8c 89       	ldd	r24, Y+20	; 0x14
     79c:	9d 89       	ldd	r25, Y+21	; 0x15
     79e:	00 97       	sbiw	r24, 0x00	; 0
     7a0:	21 f0       	breq	.+8      	; 0x7aa <vCoRoutineSchedule+0x13e>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     7a2:	ce 01       	movw	r24, r28
     7a4:	0c 96       	adiw	r24, 0x0c	; 12
     7a6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     7aa:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     7ac:	8e 89       	ldd	r24, Y+22	; 0x16
     7ae:	90 91 ca 01 	lds	r25, 0x01CA
     7b2:	98 17       	cp	r25, r24
     7b4:	10 f4       	brcc	.+4      	; 0x7ba <vCoRoutineSchedule+0x14e>
     7b6:	80 93 ca 01 	sts	0x01CA, r24
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	9c 01       	movw	r18, r24
     7be:	22 0f       	add	r18, r18
     7c0:	33 1f       	adc	r19, r19
     7c2:	22 0f       	add	r18, r18
     7c4:	33 1f       	adc	r19, r19
     7c6:	22 0f       	add	r18, r18
     7c8:	33 1f       	adc	r19, r19
     7ca:	82 0f       	add	r24, r18
     7cc:	93 1f       	adc	r25, r19
     7ce:	85 53       	subi	r24, 0x35	; 53
     7d0:	9e 4f       	sbci	r25, 0xFE	; 254
     7d2:	b8 01       	movw	r22, r16
     7d4:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     7d8:	e0 91 f8 01 	lds	r30, 0x01F8
     7dc:	f0 91 f9 01 	lds	r31, 0x01F9
     7e0:	80 81       	ld	r24, Z
     7e2:	88 23       	and	r24, r24
     7e4:	29 f6       	brne	.-118    	; 0x770 <vCoRoutineSchedule+0x104>
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     7e6:	80 91 00 02 	lds	r24, 0x0200
     7ea:	90 91 01 02 	lds	r25, 0x0201
     7ee:	00 97       	sbiw	r24, 0x00	; 0
     7f0:	09 f0       	breq	.+2      	; 0x7f4 <vCoRoutineSchedule+0x188>
     7f2:	85 cf       	rjmp	.-246    	; 0x6fe <vCoRoutineSchedule+0x92>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     7f4:	80 91 fc 01 	lds	r24, 0x01FC
     7f8:	90 91 fd 01 	lds	r25, 0x01FD
     7fc:	90 93 ff 01 	sts	0x01FF, r25
     800:	80 93 fe 01 	sts	0x01FE, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     804:	20 91 ca 01 	lds	r18, 0x01CA
     808:	82 2f       	mov	r24, r18
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	fc 01       	movw	r30, r24
     80e:	ee 0f       	add	r30, r30
     810:	ff 1f       	adc	r31, r31
     812:	ee 0f       	add	r30, r30
     814:	ff 1f       	adc	r31, r31
     816:	ee 0f       	add	r30, r30
     818:	ff 1f       	adc	r31, r31
     81a:	e8 0f       	add	r30, r24
     81c:	f9 1f       	adc	r31, r25
     81e:	e5 53       	subi	r30, 0x35	; 53
     820:	fe 4f       	sbci	r31, 0xFE	; 254
     822:	30 81       	ld	r19, Z
     824:	33 23       	and	r19, r19
     826:	d9 f4       	brne	.+54     	; 0x85e <vCoRoutineSchedule+0x1f2>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     828:	22 23       	and	r18, r18
     82a:	31 f4       	brne	.+12     	; 0x838 <vCoRoutineSchedule+0x1cc>
     82c:	47 c0       	rjmp	.+142    	; 0x8bc <__stack+0x5d>
     82e:	22 23       	and	r18, r18
     830:	19 f4       	brne	.+6      	; 0x838 <vCoRoutineSchedule+0x1cc>
     832:	20 93 ca 01 	sts	0x01CA, r18
     836:	42 c0       	rjmp	.+132    	; 0x8bc <__stack+0x5d>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     838:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     83a:	82 2f       	mov	r24, r18
     83c:	90 e0       	ldi	r25, 0x00	; 0
     83e:	fc 01       	movw	r30, r24
     840:	ee 0f       	add	r30, r30
     842:	ff 1f       	adc	r31, r31
     844:	ee 0f       	add	r30, r30
     846:	ff 1f       	adc	r31, r31
     848:	ee 0f       	add	r30, r30
     84a:	ff 1f       	adc	r31, r31
     84c:	e8 0f       	add	r30, r24
     84e:	f9 1f       	adc	r31, r25
     850:	e5 53       	subi	r30, 0x35	; 53
     852:	fe 4f       	sbci	r31, 0xFE	; 254
     854:	30 81       	ld	r19, Z
     856:	33 23       	and	r19, r19
     858:	51 f3       	breq	.-44     	; 0x82e <vCoRoutineSchedule+0x1c2>
     85a:	20 93 ca 01 	sts	0x01CA, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     85e:	fc 01       	movw	r30, r24
     860:	ee 0f       	add	r30, r30
     862:	ff 1f       	adc	r31, r31
     864:	ee 0f       	add	r30, r30
     866:	ff 1f       	adc	r31, r31
     868:	ee 0f       	add	r30, r30
     86a:	ff 1f       	adc	r31, r31
     86c:	8e 0f       	add	r24, r30
     86e:	9f 1f       	adc	r25, r31
     870:	fc 01       	movw	r30, r24
     872:	e5 53       	subi	r30, 0x35	; 53
     874:	fe 4f       	sbci	r31, 0xFE	; 254
     876:	a1 81       	ldd	r26, Z+1	; 0x01
     878:	b2 81       	ldd	r27, Z+2	; 0x02
     87a:	12 96       	adiw	r26, 0x02	; 2
     87c:	0d 90       	ld	r0, X+
     87e:	bc 91       	ld	r27, X
     880:	a0 2d       	mov	r26, r0
     882:	b2 83       	std	Z+2, r27	; 0x02
     884:	a1 83       	std	Z+1, r26	; 0x01
     886:	cf 01       	movw	r24, r30
     888:	03 96       	adiw	r24, 0x03	; 3
     88a:	a8 17       	cp	r26, r24
     88c:	b9 07       	cpc	r27, r25
     88e:	31 f4       	brne	.+12     	; 0x89c <__stack+0x3d>
     890:	12 96       	adiw	r26, 0x02	; 2
     892:	8d 91       	ld	r24, X+
     894:	9c 91       	ld	r25, X
     896:	13 97       	sbiw	r26, 0x03	; 3
     898:	92 83       	std	Z+2, r25	; 0x02
     89a:	81 83       	std	Z+1, r24	; 0x01
     89c:	01 80       	ldd	r0, Z+1	; 0x01
     89e:	f2 81       	ldd	r31, Z+2	; 0x02
     8a0:	e0 2d       	mov	r30, r0
     8a2:	a6 81       	ldd	r26, Z+6	; 0x06
     8a4:	b7 81       	ldd	r27, Z+7	; 0x07
     8a6:	b0 93 c9 01 	sts	0x01C9, r27
     8aa:	a0 93 c8 01 	sts	0x01C8, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     8ae:	ed 91       	ld	r30, X+
     8b0:	fc 91       	ld	r31, X
     8b2:	11 97       	sbiw	r26, 0x01	; 1
     8b4:	cd 01       	movw	r24, r26
     8b6:	57 96       	adiw	r26, 0x17	; 23
     8b8:	6c 91       	ld	r22, X
     8ba:	09 95       	icall

	return;
}
     8bc:	df 91       	pop	r29
     8be:	cf 91       	pop	r28
     8c0:	1f 91       	pop	r17
     8c2:	0f 91       	pop	r16
     8c4:	ff 90       	pop	r15
     8c6:	ef 90       	pop	r14
     8c8:	08 95       	ret

000008ca <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     8ca:	0f 93       	push	r16
     8cc:	1f 93       	push	r17
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     8d2:	dc 01       	movw	r26, r24
     8d4:	15 96       	adiw	r26, 0x05	; 5
     8d6:	ed 91       	ld	r30, X+
     8d8:	fc 91       	ld	r31, X
     8da:	16 97       	sbiw	r26, 0x06	; 6
     8dc:	06 81       	ldd	r16, Z+6	; 0x06
     8de:	17 81       	ldd	r17, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     8e0:	e8 01       	movw	r28, r16
     8e2:	2c 96       	adiw	r28, 0x0c	; 12
     8e4:	ce 01       	movw	r24, r28
     8e6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     8ea:	8f ee       	ldi	r24, 0xEF	; 239
     8ec:	91 e0       	ldi	r25, 0x01	; 1
     8ee:	be 01       	movw	r22, r28
     8f0:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     8f4:	e0 91 c8 01 	lds	r30, 0x01C8
     8f8:	f0 91 c9 01 	lds	r31, 0x01C9
	{
		xReturn = pdTRUE;
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	d8 01       	movw	r26, r16
     900:	56 96       	adiw	r26, 0x16	; 22
     902:	2c 91       	ld	r18, X
     904:	56 97       	sbiw	r26, 0x16	; 22
     906:	96 89       	ldd	r25, Z+22	; 0x16
     908:	29 17       	cp	r18, r25
     90a:	08 f4       	brcc	.+2      	; 0x90e <xCoRoutineRemoveFromEventList+0x44>
     90c:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     90e:	df 91       	pop	r29
     910:	cf 91       	pop	r28
     912:	1f 91       	pop	r17
     914:	0f 91       	pop	r16
     916:	08 95       	ret

00000918 <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     918:	44 23       	and	r20, r20
     91a:	41 f4       	brne	.+16     	; 0x92c <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     91c:	68 23       	and	r22, r24
     91e:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
     920:	81 e0       	ldi	r24, 0x01	; 1
     922:	61 15       	cp	r22, r1
     924:	71 05       	cpc	r23, r1
     926:	51 f4       	brne	.+20     	; 0x93c <prvTestWaitCondition+0x24>
     928:	80 e0       	ldi	r24, 0x00	; 0
     92a:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     92c:	9b 01       	movw	r18, r22
     92e:	28 23       	and	r18, r24
     930:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	62 17       	cp	r22, r18
     936:	73 07       	cpc	r23, r19
     938:	09 f0       	breq	.+2      	; 0x93c <prvTestWaitCondition+0x24>
     93a:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     93c:	08 95       	ret

0000093e <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
EventGroup_t *pxEventBits;

	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
     942:	8b e0       	ldi	r24, 0x0B	; 11
     944:	90 e0       	ldi	r25, 0x00	; 0
     946:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
     94a:	ec 01       	movw	r28, r24
	if( pxEventBits != NULL )
     94c:	00 97       	sbiw	r24, 0x00	; 0
     94e:	31 f0       	breq	.+12     	; 0x95c <xEventGroupCreate+0x1e>
	{
		pxEventBits->uxEventBits = 0;
     950:	fc 01       	movw	r30, r24
     952:	11 92       	st	Z+, r1
     954:	11 92       	st	Z+, r1
     956:	cf 01       	movw	r24, r30
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     958:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
}
     95c:	8c 2f       	mov	r24, r28
     95e:	9d 2f       	mov	r25, r29
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	08 95       	ret

00000966 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     966:	af 92       	push	r10
     968:	bf 92       	push	r11
     96a:	cf 92       	push	r12
     96c:	df 92       	push	r13
     96e:	ef 92       	push	r14
     970:	ff 92       	push	r15
     972:	0f 93       	push	r16
     974:	1f 93       	push	r17
     976:	cf 93       	push	r28
     978:	df 93       	push	r29
     97a:	5c 01       	movw	r10, r24
     97c:	6b 01       	movw	r12, r22
     97e:	e4 2e       	mov	r14, r20
     980:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     982:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     986:	f5 01       	movw	r30, r10
     988:	c0 81       	ld	r28, Z
     98a:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     98c:	ce 01       	movw	r24, r28
     98e:	b6 01       	movw	r22, r12
     990:	4f 2d       	mov	r20, r15
     992:	0e 94 8c 04 	call	0x918	; 0x918 <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     996:	88 23       	and	r24, r24
     998:	51 f0       	breq	.+20     	; 0x9ae <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     99a:	ee 20       	and	r14, r14
     99c:	01 f1       	breq	.+64     	; 0x9de <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     99e:	c0 94       	com	r12
     9a0:	d0 94       	com	r13
     9a2:	cc 22       	and	r12, r28
     9a4:	dd 22       	and	r13, r29
     9a6:	f5 01       	movw	r30, r10
     9a8:	d1 82       	std	Z+1, r13	; 0x01
     9aa:	c0 82       	st	Z, r12
     9ac:	18 c0       	rjmp	.+48     	; 0x9de <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     9ae:	01 15       	cp	r16, r1
     9b0:	11 05       	cpc	r17, r1
     9b2:	a9 f0       	breq	.+42     	; 0x9de <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     9b4:	ee 20       	and	r14, r14
     9b6:	19 f4       	brne	.+6      	; 0x9be <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	02 c0       	rjmp	.+4      	; 0x9c2 <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     9be:	60 e0       	ldi	r22, 0x00	; 0
     9c0:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     9c2:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     9c4:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     9c6:	6c 29       	or	r22, r12
     9c8:	7d 29       	or	r23, r13
     9ca:	c5 01       	movw	r24, r10
     9cc:	02 96       	adiw	r24, 0x02	; 2
     9ce:	a8 01       	movw	r20, r16
     9d0:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     9d4:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     9d8:	88 23       	and	r24, r24
     9da:	39 f4       	brne	.+14     	; 0x9ea <xEventGroupWaitBits+0x84>
     9dc:	04 c0       	rjmp	.+8      	; 0x9e6 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     9de:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
     9e2:	ce 01       	movw	r24, r28
     9e4:	21 c0       	rjmp	.+66     	; 0xa28 <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     9e6:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     9ea:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <uxTaskResetEventItemValue>
     9ee:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     9f0:	91 fd       	sbrc	r25, 1
     9f2:	18 c0       	rjmp	.+48     	; 0xa24 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     9f4:	0f b6       	in	r0, 0x3f	; 63
     9f6:	f8 94       	cli
     9f8:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     9fa:	f5 01       	movw	r30, r10
     9fc:	c0 81       	ld	r28, Z
     9fe:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     a00:	ce 01       	movw	r24, r28
     a02:	b6 01       	movw	r22, r12
     a04:	4f 2d       	mov	r20, r15
     a06:	0e 94 8c 04 	call	0x918	; 0x918 <prvTestWaitCondition>
     a0a:	88 23       	and	r24, r24
     a0c:	49 f0       	breq	.+18     	; 0xa20 <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     a0e:	ee 20       	and	r14, r14
     a10:	39 f0       	breq	.+14     	; 0xa20 <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a12:	c0 94       	com	r12
     a14:	d0 94       	com	r13
     a16:	cc 22       	and	r12, r28
     a18:	dd 22       	and	r13, r29
     a1a:	f5 01       	movw	r30, r10
     a1c:	d1 82       	std	Z+1, r13	; 0x01
     a1e:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     a20:	0f 90       	pop	r0
     a22:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a24:	ce 01       	movw	r24, r28
     a26:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	ff 90       	pop	r15
     a32:	ef 90       	pop	r14
     a34:	df 90       	pop	r13
     a36:	cf 90       	pop	r12
     a38:	bf 90       	pop	r11
     a3a:	af 90       	pop	r10
     a3c:	08 95       	ret

00000a3e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     a3e:	fc 01       	movw	r30, r24

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     a40:	0f b6       	in	r0, 0x3f	; 63
     a42:	f8 94       	cli
     a44:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     a46:	80 81       	ld	r24, Z
     a48:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     a4a:	60 95       	com	r22
     a4c:	70 95       	com	r23
     a4e:	68 23       	and	r22, r24
     a50:	79 23       	and	r23, r25
     a52:	71 83       	std	Z+1, r23	; 0x01
     a54:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     a56:	0f 90       	pop	r0
     a58:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     a5a:	08 95       	ret

00000a5c <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     a5c:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     a5e:	80 81       	ld	r24, Z
     a60:	91 81       	ldd	r25, Z+1	; 0x01
     a62:	08 95       	ret

00000a64 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     a64:	af 92       	push	r10
     a66:	bf 92       	push	r11
     a68:	cf 92       	push	r12
     a6a:	df 92       	push	r13
     a6c:	ef 92       	push	r14
     a6e:	ff 92       	push	r15
     a70:	0f 93       	push	r16
     a72:	1f 93       	push	r17
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
     a78:	8c 01       	movw	r16, r24
     a7a:	eb 01       	movw	r28, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a7c:	0f 2e       	mov	r0, r31
     a7e:	f5 e0       	ldi	r31, 0x05	; 5
     a80:	cf 2e       	mov	r12, r31
     a82:	dd 24       	eor	r13, r13
     a84:	f0 2d       	mov	r31, r0
     a86:	c8 0e       	add	r12, r24
     a88:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     a8a:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     a8e:	d8 01       	movw	r26, r16
     a90:	17 96       	adiw	r26, 0x07	; 7
     a92:	ed 91       	ld	r30, X+
     a94:	fc 91       	ld	r31, X
     a96:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     a98:	8d 91       	ld	r24, X+
     a9a:	9c 91       	ld	r25, X
     a9c:	11 97       	sbiw	r26, 0x01	; 1
     a9e:	8c 2b       	or	r24, r28
     aa0:	9d 2b       	or	r25, r29
     aa2:	11 96       	adiw	r26, 0x01	; 1
     aa4:	9c 93       	st	X, r25
     aa6:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     aa8:	ce 16       	cp	r12, r30
     aaa:	df 06       	cpc	r13, r31
     aac:	c1 f1       	breq	.+112    	; 0xb1e <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     aae:	aa 24       	eor	r10, r10
     ab0:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     ab2:	ff 24       	eor	r15, r15
     ab4:	f3 94       	inc	r15
     ab6:	ee 24       	eor	r14, r14
     ab8:	01 c0       	rjmp	.+2      	; 0xabc <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     aba:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     abc:	c2 81       	ldd	r28, Z+2	; 0x02
     abe:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     ac0:	80 81       	ld	r24, Z
     ac2:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     ac4:	bc 01       	movw	r22, r24
     ac6:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     ac8:	9c 01       	movw	r18, r24
     aca:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     acc:	92 fd       	sbrc	r25, 2
     ace:	0b c0       	rjmp	.+22     	; 0xae6 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     ad0:	d8 01       	movw	r26, r16
     ad2:	8d 91       	ld	r24, X+
     ad4:	9c 91       	ld	r25, X
     ad6:	11 97       	sbiw	r26, 0x01	; 1
     ad8:	82 23       	and	r24, r18
     ada:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     adc:	4f 2d       	mov	r20, r15
     ade:	00 97       	sbiw	r24, 0x00	; 0
     ae0:	69 f4       	brne	.+26     	; 0xafc <xEventGroupSetBits+0x98>
     ae2:	4e 2d       	mov	r20, r14
     ae4:	0b c0       	rjmp	.+22     	; 0xafc <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     ae6:	d8 01       	movw	r26, r16
     ae8:	8d 91       	ld	r24, X+
     aea:	9c 91       	ld	r25, X
     aec:	11 97       	sbiw	r26, 0x01	; 1
     aee:	82 23       	and	r24, r18
     af0:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     af2:	4f 2d       	mov	r20, r15
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	09 f0       	breq	.+2      	; 0xafc <xEventGroupSetBits+0x98>
     afa:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     afc:	44 23       	and	r20, r20
     afe:	59 f0       	breq	.+22     	; 0xb16 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     b00:	70 ff       	sbrs	r23, 0
     b02:	02 c0       	rjmp	.+4      	; 0xb08 <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     b04:	a2 2a       	or	r10, r18
     b06:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     b08:	d8 01       	movw	r26, r16
     b0a:	6d 91       	ld	r22, X+
     b0c:	7c 91       	ld	r23, X
     b0e:	72 60       	ori	r23, 0x02	; 2
     b10:	cf 01       	movw	r24, r30
     b12:	0e 94 cf 13 	call	0x279e	; 0x279e <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     b16:	cc 16       	cp	r12, r28
     b18:	dd 06       	cpc	r13, r29
     b1a:	79 f6       	brne	.-98     	; 0xaba <xEventGroupSetBits+0x56>
     b1c:	02 c0       	rjmp	.+4      	; 0xb22 <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     b1e:	aa 24       	eor	r10, r10
     b20:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     b22:	c5 01       	movw	r24, r10
     b24:	80 95       	com	r24
     b26:	90 95       	com	r25
     b28:	f8 01       	movw	r30, r16
     b2a:	a0 80       	ld	r10, Z
     b2c:	b1 80       	ldd	r11, Z+1	; 0x01
     b2e:	a8 22       	and	r10, r24
     b30:	b9 22       	and	r11, r25
     b32:	b1 82       	std	Z+1, r11	; 0x01
     b34:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     b36:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     b3a:	d8 01       	movw	r26, r16
     b3c:	8c 91       	ld	r24, X
     b3e:	11 96       	adiw	r26, 0x01	; 1
     b40:	9c 91       	ld	r25, X
     b42:	11 97       	sbiw	r26, 0x01	; 1
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	1f 91       	pop	r17
     b4a:	0f 91       	pop	r16
     b4c:	ff 90       	pop	r15
     b4e:	ef 90       	pop	r14
     b50:	df 90       	pop	r13
     b52:	cf 90       	pop	r12
     b54:	bf 90       	pop	r11
     b56:	af 90       	pop	r10
     b58:	08 95       	ret

00000b5a <xEventGroupSync>:
	return ( EventGroupHandle_t ) pxEventBits;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     b5a:	af 92       	push	r10
     b5c:	bf 92       	push	r11
     b5e:	cf 92       	push	r12
     b60:	df 92       	push	r13
     b62:	ef 92       	push	r14
     b64:	ff 92       	push	r15
     b66:	0f 93       	push	r16
     b68:	1f 93       	push	r17
     b6a:	cf 93       	push	r28
     b6c:	df 93       	push	r29
     b6e:	6c 01       	movw	r12, r24
     b70:	eb 01       	movw	r28, r22
     b72:	7a 01       	movw	r14, r20
     b74:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     b76:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     b7a:	f6 01       	movw	r30, r12
     b7c:	00 81       	ld	r16, Z
     b7e:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     b80:	c6 01       	movw	r24, r12
     b82:	be 01       	movw	r22, r28
     b84:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     b88:	c0 2b       	or	r28, r16
     b8a:	d1 2b       	or	r29, r17
     b8c:	c7 01       	movw	r24, r14
     b8e:	8c 23       	and	r24, r28
     b90:	9d 23       	and	r25, r29
     b92:	8e 15       	cp	r24, r14
     b94:	9f 05       	cpc	r25, r15
     b96:	51 f4       	brne	.+20     	; 0xbac <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b98:	80 95       	com	r24
     b9a:	90 95       	com	r25
     b9c:	f6 01       	movw	r30, r12
     b9e:	20 81       	ld	r18, Z
     ba0:	31 81       	ldd	r19, Z+1	; 0x01
     ba2:	82 23       	and	r24, r18
     ba4:	93 23       	and	r25, r19
     ba6:	91 83       	std	Z+1, r25	; 0x01
     ba8:	80 83       	st	Z, r24
     baa:	12 c0       	rjmp	.+36     	; 0xbd0 <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     bac:	a1 14       	cp	r10, r1
     bae:	b1 04       	cpc	r11, r1
     bb0:	61 f0       	breq	.+24     	; 0xbca <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     bb2:	b7 01       	movw	r22, r14
     bb4:	75 60       	ori	r23, 0x05	; 5
     bb6:	c6 01       	movw	r24, r12
     bb8:	02 96       	adiw	r24, 0x02	; 2
     bba:	a5 01       	movw	r20, r10
     bbc:	0e 94 60 13 	call	0x26c0	; 0x26c0 <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     bc0:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     bc4:	88 23       	and	r24, r24
     bc6:	49 f4       	brne	.+18     	; 0xbda <xEventGroupSync+0x80>
     bc8:	06 c0       	rjmp	.+12     	; 0xbd6 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     bca:	f6 01       	movw	r30, r12
     bcc:	c0 81       	ld	r28, Z
     bce:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     bd0:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
     bd4:	1c c0       	rjmp	.+56     	; 0xc0e <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     bd6:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     bda:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     bde:	91 fd       	sbrc	r25, 1
     be0:	14 c0       	rjmp	.+40     	; 0xc0a <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     be8:	f6 01       	movw	r30, r12
     bea:	80 81       	ld	r24, Z
     bec:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     bee:	97 01       	movw	r18, r14
     bf0:	28 23       	and	r18, r24
     bf2:	39 23       	and	r19, r25
     bf4:	2e 15       	cp	r18, r14
     bf6:	3f 05       	cpc	r19, r15
     bf8:	31 f4       	brne	.+12     	; 0xc06 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     bfa:	20 95       	com	r18
     bfc:	30 95       	com	r19
     bfe:	28 23       	and	r18, r24
     c00:	39 23       	and	r19, r25
     c02:	31 83       	std	Z+1, r19	; 0x01
     c04:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     c06:	0f 90       	pop	r0
     c08:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     c0a:	ec 01       	movw	r28, r24
     c0c:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     c0e:	8c 2f       	mov	r24, r28
     c10:	9d 2f       	mov	r25, r29
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	ef 90       	pop	r14
     c1e:	df 90       	pop	r13
     c20:	cf 90       	pop	r12
     c22:	bf 90       	pop	r11
     c24:	af 90       	pop	r10
     c26:	08 95       	ret

00000c28 <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     c28:	cf 93       	push	r28
     c2a:	df 93       	push	r29
     c2c:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     c2e:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     c32:	8a 81       	ldd	r24, Y+2	; 0x02
     c34:	88 23       	and	r24, r24
     c36:	49 f0       	breq	.+18     	; 0xc4a <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     c38:	8f 81       	ldd	r24, Y+7	; 0x07
     c3a:	98 85       	ldd	r25, Y+8	; 0x08
     c3c:	60 e0       	ldi	r22, 0x00	; 0
     c3e:	72 e0       	ldi	r23, 0x02	; 2
     c40:	0e 94 cf 13 	call	0x279e	; 0x279e <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     c44:	8a 81       	ldd	r24, Y+2	; 0x02
     c46:	88 23       	and	r24, r24
     c48:	b9 f7       	brne	.-18     	; 0xc38 <vEventGroupDelete+0x10>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
     c4a:	ce 01       	movw	r24, r28
     c4c:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>
	}
	( void ) xTaskResumeAll();
     c50:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
}
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	08 95       	ret

00000c5a <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     c5a:	ba 01       	movw	r22, r20
     c5c:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
}
     c60:	08 95       	ret

00000c62 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     c62:	ba 01       	movw	r22, r20
     c64:	0e 94 1f 05 	call	0xa3e	; 0xa3e <xEventGroupClearBits>
}
     c68:	08 95       	ret

00000c6a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
     c6e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     c70:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     c74:	80 91 02 02 	lds	r24, 0x0202
     c78:	90 91 03 02 	lds	r25, 0x0203
     c7c:	00 97       	sbiw	r24, 0x00	; 0
     c7e:	31 f4       	brne	.+12     	; 0xc8c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     c80:	85 e0       	ldi	r24, 0x05	; 5
     c82:	92 e0       	ldi	r25, 0x02	; 2
     c84:	90 93 03 02 	sts	0x0203, r25
     c88:	80 93 02 02 	sts	0x0202, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     c8c:	20 91 b4 06 	lds	r18, 0x06B4
     c90:	30 91 b5 06 	lds	r19, 0x06B5
     c94:	ce 01       	movw	r24, r28
     c96:	82 0f       	add	r24, r18
     c98:	93 1f       	adc	r25, r19
     c9a:	44 e0       	ldi	r20, 0x04	; 4
     c9c:	8f 3a       	cpi	r24, 0xAF	; 175
     c9e:	94 07       	cpc	r25, r20
     ca0:	70 f4       	brcc	.+28     	; 0xcbe <pvPortMalloc+0x54>
     ca2:	28 17       	cp	r18, r24
     ca4:	39 07       	cpc	r19, r25
     ca6:	70 f4       	brcc	.+28     	; 0xcc4 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     ca8:	c0 91 02 02 	lds	r28, 0x0202
     cac:	d0 91 03 02 	lds	r29, 0x0203
     cb0:	c2 0f       	add	r28, r18
     cb2:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     cb4:	90 93 b5 06 	sts	0x06B5, r25
     cb8:	80 93 b4 06 	sts	0x06B4, r24
     cbc:	05 c0       	rjmp	.+10     	; 0xcc8 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     cbe:	c0 e0       	ldi	r28, 0x00	; 0
     cc0:	d0 e0       	ldi	r29, 0x00	; 0
     cc2:	02 c0       	rjmp	.+4      	; 0xcc8 <pvPortMalloc+0x5e>
     cc4:	c0 e0       	ldi	r28, 0x00	; 0
     cc6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     cc8:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     ccc:	8c 2f       	mov	r24, r28
     cce:	9d 2f       	mov	r25, r29
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	08 95       	ret

00000cd6 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     cd6:	08 95       	ret

00000cd8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     cd8:	10 92 b5 06 	sts	0x06B5, r1
     cdc:	10 92 b4 06 	sts	0x06B4, r1
}
     ce0:	08 95       	ret

00000ce2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     ce2:	20 91 b4 06 	lds	r18, 0x06B4
     ce6:	30 91 b5 06 	lds	r19, 0x06B5
     cea:	8f ea       	ldi	r24, 0xAF	; 175
     cec:	94 e0       	ldi	r25, 0x04	; 4
     cee:	82 1b       	sub	r24, r18
     cf0:	93 0b       	sbc	r25, r19
}
     cf2:	08 95       	ret

00000cf4 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
     cf4:	cf 93       	push	r28
     cf6:	df 93       	push	r29
     cf8:	00 d0       	rcall	.+0      	; 0xcfa <vCompeteingIntMathTask+0x6>
     cfa:	00 d0       	rcall	.+0      	; 0xcfc <vCompeteingIntMathTask+0x8>
     cfc:	cd b7       	in	r28, 0x3d	; 61
     cfe:	de b7       	in	r29, 0x3e	; 62
     d00:	1c 01       	movw	r2, r24
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
     d02:	00 e0       	ldi	r16, 0x00	; 0
     d04:	10 e0       	ldi	r17, 0x00	; 0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
     d06:	0f 2e       	mov	r0, r31
     d08:	fb e7       	ldi	r31, 0x7B	; 123
     d0a:	8f 2e       	mov	r8, r31
     d0c:	f0 e0       	ldi	r31, 0x00	; 0
     d0e:	9f 2e       	mov	r9, r31
     d10:	f0 e0       	ldi	r31, 0x00	; 0
     d12:	af 2e       	mov	r10, r31
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	bf 2e       	mov	r11, r31
     d18:	f0 2d       	mov	r31, r0
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
     d1a:	0f 2e       	mov	r0, r31
     d1c:	f7 e0       	ldi	r31, 0x07	; 7
     d1e:	cf 2e       	mov	r12, r31
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	df 2e       	mov	r13, r31
     d24:	f0 e0       	ldi	r31, 0x00	; 0
     d26:	ef 2e       	mov	r14, r31
     d28:	f0 e0       	ldi	r31, 0x00	; 0
     d2a:	ff 2e       	mov	r15, r31
     d2c:	f0 2d       	mov	r31, r0
		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
		{
			sError = pdTRUE;
     d2e:	44 24       	eor	r4, r4
     d30:	55 24       	eor	r5, r5
     d32:	43 94       	inc	r4
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
     d34:	77 24       	eor	r7, r7
     d36:	73 94       	inc	r7
     d38:	01 c0       	rjmp	.+2      	; 0xd3c <vCompeteingIntMathTask+0x48>
		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
		{
			sError = pdTRUE;
     d3a:	82 01       	movw	r16, r4
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
     d3c:	89 82       	std	Y+1, r8	; 0x01
     d3e:	9a 82       	std	Y+2, r9	; 0x02
     d40:	ab 82       	std	Y+3, r10	; 0x03
     d42:	bc 82       	std	Y+4, r11	; 0x04
		lValue += intgCONST2;
     d44:	89 81       	ldd	r24, Y+1	; 0x01
     d46:	9a 81       	ldd	r25, Y+2	; 0x02
     d48:	ab 81       	ldd	r26, Y+3	; 0x03
     d4a:	bc 81       	ldd	r27, Y+4	; 0x04
     d4c:	89 5b       	subi	r24, 0xB9	; 185
     d4e:	9b 46       	sbci	r25, 0x6B	; 107
     d50:	ac 4f       	sbci	r26, 0xFC	; 252
     d52:	bf 4f       	sbci	r27, 0xFF	; 255
     d54:	89 83       	std	Y+1, r24	; 0x01
     d56:	9a 83       	std	Y+2, r25	; 0x02
     d58:	ab 83       	std	Y+3, r26	; 0x03
     d5a:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
     d5c:	89 81       	ldd	r24, Y+1	; 0x01
     d5e:	9a 81       	ldd	r25, Y+2	; 0x02
     d60:	ab 81       	ldd	r26, Y+3	; 0x03
     d62:	bc 81       	ldd	r27, Y+4	; 0x04
     d64:	ac 01       	movw	r20, r24
     d66:	bd 01       	movw	r22, r26
     d68:	44 0f       	add	r20, r20
     d6a:	55 1f       	adc	r21, r21
     d6c:	66 1f       	adc	r22, r22
     d6e:	77 1f       	adc	r23, r23
     d70:	44 0f       	add	r20, r20
     d72:	55 1f       	adc	r21, r21
     d74:	66 1f       	adc	r22, r22
     d76:	77 1f       	adc	r23, r23
     d78:	84 1b       	sub	r24, r20
     d7a:	95 0b       	sbc	r25, r21
     d7c:	a6 0b       	sbc	r26, r22
     d7e:	b7 0b       	sbc	r27, r23
     d80:	89 83       	std	Y+1, r24	; 0x01
     d82:	9a 83       	std	Y+2, r25	; 0x02
     d84:	ab 83       	std	Y+3, r26	; 0x03
     d86:	bc 83       	std	Y+4, r27	; 0x04
		lValue /= intgCONST4;
     d88:	69 81       	ldd	r22, Y+1	; 0x01
     d8a:	7a 81       	ldd	r23, Y+2	; 0x02
     d8c:	8b 81       	ldd	r24, Y+3	; 0x03
     d8e:	9c 81       	ldd	r25, Y+4	; 0x04
     d90:	a7 01       	movw	r20, r14
     d92:	96 01       	movw	r18, r12
     d94:	0e 94 c7 19 	call	0x338e	; 0x338e <__divmodsi4>
     d98:	29 83       	std	Y+1, r18	; 0x01
     d9a:	3a 83       	std	Y+2, r19	; 0x02
     d9c:	4b 83       	std	Y+3, r20	; 0x03
     d9e:	5c 83       	std	Y+4, r21	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
     da0:	89 81       	ldd	r24, Y+1	; 0x01
     da2:	9a 81       	ldd	r25, Y+2	; 0x02
     da4:	ab 81       	ldd	r26, Y+3	; 0x03
     da6:	bc 81       	ldd	r27, Y+4	; 0x04
     da8:	8b 31       	cpi	r24, 0x1B	; 27
     daa:	27 e7       	ldi	r18, 0x77	; 119
     dac:	92 07       	cpc	r25, r18
     dae:	2e ef       	ldi	r18, 0xFE	; 254
     db0:	a2 07       	cpc	r26, r18
     db2:	2f ef       	ldi	r18, 0xFF	; 255
     db4:	b2 07       	cpc	r27, r18
     db6:	09 f6       	brne	.-126    	; 0xd3a <vCompeteingIntMathTask+0x46>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
     db8:	01 15       	cp	r16, r1
     dba:	11 05       	cpc	r17, r1
     dbc:	09 f0       	breq	.+2      	; 0xdc0 <vCompeteingIntMathTask+0xcc>
     dbe:	be cf       	rjmp	.-132    	; 0xd3c <vCompeteingIntMathTask+0x48>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
     dc6:	f1 01       	movw	r30, r2
     dc8:	70 82       	st	Z, r7
			portEXIT_CRITICAL();
     dca:	0f 90       	pop	r0
     dcc:	0f be       	out	0x3f, r0	; 63
     dce:	b6 cf       	rjmp	.-148    	; 0xd3c <vCompeteingIntMathTask+0x48>

00000dd0 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
     dd0:	af 92       	push	r10
     dd2:	bf 92       	push	r11
     dd4:	cf 92       	push	r12
     dd6:	df 92       	push	r13
     dd8:	ef 92       	push	r14
     dda:	ff 92       	push	r15
     ddc:	0f 93       	push	r16
     dde:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
     de0:	8a e7       	ldi	r24, 0x7A	; 122
     de2:	96 e0       	ldi	r25, 0x06	; 6
     de4:	60 e6       	ldi	r22, 0x60	; 96
     de6:	70 e0       	ldi	r23, 0x00	; 0
     de8:	45 e5       	ldi	r20, 0x55	; 85
     dea:	50 e0       	ldi	r21, 0x00	; 0
     dec:	26 eb       	ldi	r18, 0xB6	; 182
     dee:	36 e0       	ldi	r19, 0x06	; 6
     df0:	ee 24       	eor	r14, r14
     df2:	ff 24       	eor	r15, r15
     df4:	cc 24       	eor	r12, r12
     df6:	dd 24       	eor	r13, r13
     df8:	aa 24       	eor	r10, r10
     dfa:	bb 24       	eor	r11, r11
     dfc:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	}
}
     e00:	0f 91       	pop	r16
     e02:	ff 90       	pop	r15
     e04:	ef 90       	pop	r14
     e06:	df 90       	pop	r13
     e08:	cf 90       	pop	r12
     e0a:	bf 90       	pop	r11
     e0c:	af 90       	pop	r10
     e0e:	08 95       	ret

00000e10 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
     e10:	90 91 b6 06 	lds	r25, 0x06B6
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
     e14:	10 92 b6 06 	sts	0x06B6, r1
	}
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
     e18:	81 e0       	ldi	r24, 0x01	; 1
     e1a:	99 23       	and	r25, r25
     e1c:	09 f4       	brne	.+2      	; 0xe20 <xAreIntegerMathsTaskStillRunning+0x10>
     e1e:	80 e0       	ldi	r24, 0x00	; 0
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
}
     e20:	08 95       	ret

00000e22 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     e22:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e24:	03 96       	adiw	r24, 0x03	; 3
     e26:	92 83       	std	Z+2, r25	; 0x02
     e28:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     e2a:	2f ef       	ldi	r18, 0xFF	; 255
     e2c:	3f ef       	ldi	r19, 0xFF	; 255
     e2e:	34 83       	std	Z+4, r19	; 0x04
     e30:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e32:	96 83       	std	Z+6, r25	; 0x06
     e34:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     e36:	90 87       	std	Z+8, r25	; 0x08
     e38:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     e3a:	10 82       	st	Z, r1
}
     e3c:	08 95       	ret

00000e3e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     e3e:	fc 01       	movw	r30, r24
     e40:	11 86       	std	Z+9, r1	; 0x09
     e42:	10 86       	std	Z+8, r1	; 0x08
}
     e44:	08 95       	ret

00000e46 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
     e4a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     e4c:	dc 01       	movw	r26, r24
     e4e:	11 96       	adiw	r26, 0x01	; 1
     e50:	cd 91       	ld	r28, X+
     e52:	dc 91       	ld	r29, X
     e54:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     e56:	d3 83       	std	Z+3, r29	; 0x03
     e58:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     e5a:	2c 81       	ldd	r18, Y+4	; 0x04
     e5c:	3d 81       	ldd	r19, Y+5	; 0x05
     e5e:	35 83       	std	Z+5, r19	; 0x05
     e60:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     e62:	ac 81       	ldd	r26, Y+4	; 0x04
     e64:	bd 81       	ldd	r27, Y+5	; 0x05
     e66:	13 96       	adiw	r26, 0x03	; 3
     e68:	7c 93       	st	X, r23
     e6a:	6e 93       	st	-X, r22
     e6c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     e6e:	7d 83       	std	Y+5, r23	; 0x05
     e70:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e72:	91 87       	std	Z+9, r25	; 0x09
     e74:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e76:	fc 01       	movw	r30, r24
     e78:	20 81       	ld	r18, Z
     e7a:	2f 5f       	subi	r18, 0xFF	; 255
     e7c:	20 83       	st	Z, r18
}
     e7e:	df 91       	pop	r29
     e80:	cf 91       	pop	r28
     e82:	08 95       	ret

00000e84 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     e84:	cf 93       	push	r28
     e86:	df 93       	push	r29
     e88:	ac 01       	movw	r20, r24
     e8a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     e8c:	28 81       	ld	r18, Y
     e8e:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e90:	8f ef       	ldi	r24, 0xFF	; 255
     e92:	2f 3f       	cpi	r18, 0xFF	; 255
     e94:	38 07       	cpc	r19, r24
     e96:	21 f4       	brne	.+8      	; 0xea0 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e98:	fa 01       	movw	r30, r20
     e9a:	a7 81       	ldd	r26, Z+7	; 0x07
     e9c:	b0 85       	ldd	r27, Z+8	; 0x08
     e9e:	0d c0       	rjmp	.+26     	; 0xeba <vListInsert+0x36>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     ea0:	da 01       	movw	r26, r20
     ea2:	13 96       	adiw	r26, 0x03	; 3
     ea4:	01 c0       	rjmp	.+2      	; 0xea8 <vListInsert+0x24>
     ea6:	df 01       	movw	r26, r30
     ea8:	12 96       	adiw	r26, 0x02	; 2
     eaa:	ed 91       	ld	r30, X+
     eac:	fc 91       	ld	r31, X
     eae:	13 97       	sbiw	r26, 0x03	; 3
     eb0:	80 81       	ld	r24, Z
     eb2:	91 81       	ldd	r25, Z+1	; 0x01
     eb4:	28 17       	cp	r18, r24
     eb6:	39 07       	cpc	r19, r25
     eb8:	b0 f7       	brcc	.-20     	; 0xea6 <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     eba:	12 96       	adiw	r26, 0x02	; 2
     ebc:	ed 91       	ld	r30, X+
     ebe:	fc 91       	ld	r31, X
     ec0:	13 97       	sbiw	r26, 0x03	; 3
     ec2:	fb 83       	std	Y+3, r31	; 0x03
     ec4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     ec6:	d5 83       	std	Z+5, r29	; 0x05
     ec8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     eca:	bd 83       	std	Y+5, r27	; 0x05
     ecc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     ece:	13 96       	adiw	r26, 0x03	; 3
     ed0:	dc 93       	st	X, r29
     ed2:	ce 93       	st	-X, r28
     ed4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     ed6:	59 87       	std	Y+9, r21	; 0x09
     ed8:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     eda:	fa 01       	movw	r30, r20
     edc:	80 81       	ld	r24, Z
     ede:	8f 5f       	subi	r24, 0xFF	; 255
     ee0:	80 83       	st	Z, r24
}
     ee2:	df 91       	pop	r29
     ee4:	cf 91       	pop	r28
     ee6:	08 95       	ret

00000ee8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     ee8:	cf 93       	push	r28
     eea:	df 93       	push	r29
     eec:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     eee:	c0 85       	ldd	r28, Z+8	; 0x08
     ef0:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ef2:	a2 81       	ldd	r26, Z+2	; 0x02
     ef4:	b3 81       	ldd	r27, Z+3	; 0x03
     ef6:	84 81       	ldd	r24, Z+4	; 0x04
     ef8:	95 81       	ldd	r25, Z+5	; 0x05
     efa:	15 96       	adiw	r26, 0x05	; 5
     efc:	9c 93       	st	X, r25
     efe:	8e 93       	st	-X, r24
     f00:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     f02:	a4 81       	ldd	r26, Z+4	; 0x04
     f04:	b5 81       	ldd	r27, Z+5	; 0x05
     f06:	82 81       	ldd	r24, Z+2	; 0x02
     f08:	93 81       	ldd	r25, Z+3	; 0x03
     f0a:	13 96       	adiw	r26, 0x03	; 3
     f0c:	9c 93       	st	X, r25
     f0e:	8e 93       	st	-X, r24
     f10:	12 97       	sbiw	r26, 0x02	; 2

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     f12:	a9 81       	ldd	r26, Y+1	; 0x01
     f14:	ba 81       	ldd	r27, Y+2	; 0x02
     f16:	ae 17       	cp	r26, r30
     f18:	bf 07       	cpc	r27, r31
     f1a:	31 f4       	brne	.+12     	; 0xf28 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     f1c:	14 96       	adiw	r26, 0x04	; 4
     f1e:	8d 91       	ld	r24, X+
     f20:	9c 91       	ld	r25, X
     f22:	15 97       	sbiw	r26, 0x05	; 5
     f24:	9a 83       	std	Y+2, r25	; 0x02
     f26:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     f28:	11 86       	std	Z+9, r1	; 0x09
     f2a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     f2c:	88 81       	ld	r24, Y
     f2e:	81 50       	subi	r24, 0x01	; 1
     f30:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	08 95       	ret

00000f38 <vPolledQueueProducer>:
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	00 d0       	rcall	.+0      	; 0xf3e <vPolledQueueProducer+0x6>
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
     f42:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
     f44:	1a 82       	std	Y+2, r1	; 0x02
     f46:	19 82       	std	Y+1, r1	; 0x01
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     f48:	10 e0       	ldi	r17, 0x00	; 0
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;
     f4a:	00 e0       	ldi	r16, 0x00	; 0
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     f4c:	dd 24       	eor	r13, r13
     f4e:	d3 94       	inc	r13
     f50:	21 c0       	rjmp	.+66     	; 0xf94 <vPolledQueueProducer+0x5c>
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
     f52:	f7 01       	movw	r30, r14
     f54:	80 81       	ld	r24, Z
     f56:	91 81       	ldd	r25, Z+1	; 0x01
     f58:	be 01       	movw	r22, r28
     f5a:	6f 5f       	subi	r22, 0xFF	; 255
     f5c:	7f 4f       	sbci	r23, 0xFF	; 255
     f5e:	40 e0       	ldi	r20, 0x00	; 0
     f60:	50 e0       	ldi	r21, 0x00	; 0
     f62:	20 e0       	ldi	r18, 0x00	; 0
     f64:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
     f68:	81 30       	cpi	r24, 0x01	; 1
     f6a:	91 f4       	brne	.+36     	; 0xf90 <vPolledQueueProducer+0x58>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
     f6c:	00 23       	and	r16, r16
     f6e:	51 f4       	brne	.+20     	; 0xf84 <vPolledQueueProducer+0x4c>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
     f70:	0f b6       	in	r0, 0x3f	; 63
     f72:	f8 94       	cli
     f74:	0f 92       	push	r0
						xPollingProducerCount++;
     f76:	80 91 b7 06 	lds	r24, 0x06B7
     f7a:	8f 5f       	subi	r24, 0xFF	; 255
     f7c:	80 93 b7 06 	sts	0x06B7, r24
					portEXIT_CRITICAL();
     f80:	0f 90       	pop	r0
     f82:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
     f84:	89 81       	ldd	r24, Y+1	; 0x01
     f86:	9a 81       	ldd	r25, Y+2	; 0x02
     f88:	01 96       	adiw	r24, 0x01	; 1
     f8a:	9a 83       	std	Y+2, r25	; 0x02
     f8c:	89 83       	std	Y+1, r24	; 0x01
     f8e:	01 c0       	rjmp	.+2      	; 0xf92 <vPolledQueueProducer+0x5a>
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
     f90:	0d 2d       	mov	r16, r13
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     f92:	1f 5f       	subi	r17, 0xFF	; 255
     f94:	13 30       	cpi	r17, 0x03	; 3
     f96:	ec f2       	brlt	.-70     	; 0xf52 <vPolledQueueProducer+0x1a>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
     f98:	88 ec       	ldi	r24, 0xC8	; 200
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskDelay>
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
     fa0:	10 e0       	ldi	r17, 0x00	; 0
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
	}
     fa2:	f8 cf       	rjmp	.-16     	; 0xf94 <vPolledQueueProducer+0x5c>

00000fa4 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	00 d0       	rcall	.+0      	; 0xfaa <vPolledQueueConsumer+0x6>
     faa:	cd b7       	in	r28, 0x3d	; 61
     fac:	de b7       	in	r29, 0x3e	; 62
     fae:	8c 01       	movw	r16, r24
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE;
     fb0:	dd 24       	eor	r13, r13
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
     fb2:	ee 24       	eor	r14, r14
     fb4:	ff 24       	eor	r15, r15
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     fb6:	cc 24       	eor	r12, r12
     fb8:	c3 94       	inc	r12
     fba:	24 c0       	rjmp	.+72     	; 0x1004 <vPolledQueueConsumer+0x60>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
     fbc:	f8 01       	movw	r30, r16
     fbe:	80 81       	ld	r24, Z
     fc0:	91 81       	ldd	r25, Z+1	; 0x01
     fc2:	be 01       	movw	r22, r28
     fc4:	6f 5f       	subi	r22, 0xFF	; 255
     fc6:	7f 4f       	sbci	r23, 0xFF	; 255
     fc8:	40 e0       	ldi	r20, 0x00	; 0
     fca:	50 e0       	ldi	r21, 0x00	; 0
     fcc:	20 e0       	ldi	r18, 0x00	; 0
     fce:	0e 94 3f 0c 	call	0x187e	; 0x187e <xQueueGenericReceive>
     fd2:	81 30       	cpi	r24, 0x01	; 1
     fd4:	b9 f4       	brne	.+46     	; 0x1004 <vPolledQueueConsumer+0x60>
			{
				if( usData != usExpectedValue )
     fd6:	89 81       	ldd	r24, Y+1	; 0x01
     fd8:	9a 81       	ldd	r25, Y+2	; 0x02
     fda:	8e 15       	cp	r24, r14
     fdc:	9f 05       	cpc	r25, r15
     fde:	69 f4       	brne	.+26     	; 0xffa <vPolledQueueConsumer+0x56>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
     fe0:	dd 20       	and	r13, r13
     fe2:	61 f4       	brne	.+24     	; 0xffc <vPolledQueueConsumer+0x58>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	f8 94       	cli
     fe8:	0f 92       	push	r0
							xPollingConsumerCount++;
     fea:	20 91 b8 06 	lds	r18, 0x06B8
     fee:	2f 5f       	subi	r18, 0xFF	; 255
     ff0:	20 93 b8 06 	sts	0x06B8, r18
						portEXIT_CRITICAL();
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	01 c0       	rjmp	.+2      	; 0xffc <vPolledQueueConsumer+0x58>
			{
				if( usData != usExpectedValue )
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
     ffa:	dc 2c       	mov	r13, r12
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
     ffc:	7c 01       	movw	r14, r24
     ffe:	08 94       	sec
    1000:	e1 1c       	adc	r14, r1
    1002:	f1 1c       	adc	r15, r1
BaseType_t xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    1004:	f8 01       	movw	r30, r16
    1006:	80 81       	ld	r24, Z
    1008:	91 81       	ldd	r25, Z+1	; 0x01
    100a:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <uxQueueMessagesWaiting>
    100e:	88 23       	and	r24, r24
    1010:	a9 f6       	brne	.-86     	; 0xfbc <vPolledQueueConsumer+0x18>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    1012:	84 eb       	ldi	r24, 0xB4	; 180
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskDelay>
	}
    101a:	f4 cf       	rjmp	.-24     	; 0x1004 <vPolledQueueConsumer+0x60>

0000101c <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    101c:	8f 92       	push	r8
    101e:	9f 92       	push	r9
    1020:	af 92       	push	r10
    1022:	bf 92       	push	r11
    1024:	cf 92       	push	r12
    1026:	df 92       	push	r13
    1028:	ef 92       	push	r14
    102a:	ff 92       	push	r15
    102c:	0f 93       	push	r16
    102e:	cf 93       	push	r28
    1030:	c8 2f       	mov	r28, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    1032:	8a e0       	ldi	r24, 0x0A	; 10
    1034:	62 e0       	ldi	r22, 0x02	; 2
    1036:	40 e0       	ldi	r20, 0x00	; 0
    1038:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <xQueueGenericCreate>
    103c:	90 93 ba 06 	sts	0x06BA, r25
    1040:	80 93 b9 06 	sts	0x06B9, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    1044:	0f 2e       	mov	r0, r31
    1046:	f9 eb       	ldi	r31, 0xB9	; 185
    1048:	8f 2e       	mov	r8, r31
    104a:	f6 e0       	ldi	r31, 0x06	; 6
    104c:	9f 2e       	mov	r9, r31
    104e:	f0 2d       	mov	r31, r0
    1050:	82 ed       	ldi	r24, 0xD2	; 210
    1052:	97 e0       	ldi	r25, 0x07	; 7
    1054:	68 e6       	ldi	r22, 0x68	; 104
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	45 e5       	ldi	r20, 0x55	; 85
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	94 01       	movw	r18, r8
    105e:	0c 2f       	mov	r16, r28
    1060:	ee 24       	eor	r14, r14
    1062:	ff 24       	eor	r15, r15
    1064:	cc 24       	eor	r12, r12
    1066:	dd 24       	eor	r13, r13
    1068:	aa 24       	eor	r10, r10
    106a:	bb 24       	eor	r11, r11
    106c:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    1070:	8c e9       	ldi	r24, 0x9C	; 156
    1072:	97 e0       	ldi	r25, 0x07	; 7
    1074:	60 e7       	ldi	r22, 0x70	; 112
    1076:	70 e0       	ldi	r23, 0x00	; 0
    1078:	45 e5       	ldi	r20, 0x55	; 85
    107a:	50 e0       	ldi	r21, 0x00	; 0
    107c:	94 01       	movw	r18, r8
    107e:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
}
    1082:	cf 91       	pop	r28
    1084:	0f 91       	pop	r16
    1086:	ff 90       	pop	r15
    1088:	ef 90       	pop	r14
    108a:	df 90       	pop	r13
    108c:	cf 90       	pop	r12
    108e:	bf 90       	pop	r11
    1090:	af 90       	pop	r10
    1092:	9f 90       	pop	r9
    1094:	8f 90       	pop	r8
    1096:	08 95       	ret

00001098 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    1098:	80 91 b8 06 	lds	r24, 0x06B8
    109c:	88 23       	and	r24, r24
    109e:	39 f0       	breq	.+14     	; 0x10ae <xArePollingQueuesStillRunning+0x16>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    10a0:	90 91 b7 06 	lds	r25, 0x06B7
	  )
	{
		xReturn = pdFALSE;
    10a4:	81 e0       	ldi	r24, 0x01	; 1
    10a6:	99 23       	and	r25, r25
    10a8:	19 f4       	brne	.+6      	; 0x10b0 <xArePollingQueuesStillRunning+0x18>
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	01 c0       	rjmp	.+2      	; 0x10b0 <xArePollingQueuesStillRunning+0x18>
    10ae:	80 e0       	ldi	r24, 0x00	; 0
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    10b0:	10 92 b8 06 	sts	0x06B8, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    10b4:	10 92 b7 06 	sts	0x06B7, r1

	return xReturn;
}
    10b8:	08 95       	ret

000010ba <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    10ba:	21 e1       	ldi	r18, 0x11	; 17
    10bc:	fc 01       	movw	r30, r24
    10be:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    10c0:	31 97       	sbiw	r30, 0x01	; 1
    10c2:	32 e2       	ldi	r19, 0x22	; 34
    10c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    10c6:	fc 01       	movw	r30, r24
    10c8:	32 97       	sbiw	r30, 0x02	; 2
    10ca:	a3 e3       	ldi	r26, 0x33	; 51
    10cc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10ce:	fc 01       	movw	r30, r24
    10d0:	33 97       	sbiw	r30, 0x03	; 3
    10d2:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    10d4:	fc 01       	movw	r30, r24
    10d6:	34 97       	sbiw	r30, 0x04	; 4
    10d8:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    10da:	fc 01       	movw	r30, r24
    10dc:	35 97       	sbiw	r30, 0x05	; 5
    10de:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    10e0:	fc 01       	movw	r30, r24
    10e2:	36 97       	sbiw	r30, 0x06	; 6
    10e4:	60 e8       	ldi	r22, 0x80	; 128
    10e6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    10e8:	fc 01       	movw	r30, r24
    10ea:	37 97       	sbiw	r30, 0x07	; 7
    10ec:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    10ee:	fc 01       	movw	r30, r24
    10f0:	38 97       	sbiw	r30, 0x08	; 8
    10f2:	62 e0       	ldi	r22, 0x02	; 2
    10f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    10f6:	fc 01       	movw	r30, r24
    10f8:	39 97       	sbiw	r30, 0x09	; 9
    10fa:	63 e0       	ldi	r22, 0x03	; 3
    10fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    10fe:	fc 01       	movw	r30, r24
    1100:	3a 97       	sbiw	r30, 0x0a	; 10
    1102:	64 e0       	ldi	r22, 0x04	; 4
    1104:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1106:	fc 01       	movw	r30, r24
    1108:	3b 97       	sbiw	r30, 0x0b	; 11
    110a:	65 e0       	ldi	r22, 0x05	; 5
    110c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    110e:	fc 01       	movw	r30, r24
    1110:	3c 97       	sbiw	r30, 0x0c	; 12
    1112:	66 e0       	ldi	r22, 0x06	; 6
    1114:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1116:	fc 01       	movw	r30, r24
    1118:	3d 97       	sbiw	r30, 0x0d	; 13
    111a:	67 e0       	ldi	r22, 0x07	; 7
    111c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    111e:	fc 01       	movw	r30, r24
    1120:	3e 97       	sbiw	r30, 0x0e	; 14
    1122:	68 e0       	ldi	r22, 0x08	; 8
    1124:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1126:	fc 01       	movw	r30, r24
    1128:	3f 97       	sbiw	r30, 0x0f	; 15
    112a:	69 e0       	ldi	r22, 0x09	; 9
    112c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    112e:	fc 01       	movw	r30, r24
    1130:	70 97       	sbiw	r30, 0x10	; 16
    1132:	60 e1       	ldi	r22, 0x10	; 16
    1134:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1136:	fc 01       	movw	r30, r24
    1138:	71 97       	sbiw	r30, 0x11	; 17
    113a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    113c:	fc 01       	movw	r30, r24
    113e:	72 97       	sbiw	r30, 0x12	; 18
    1140:	22 e1       	ldi	r18, 0x12	; 18
    1142:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1144:	fc 01       	movw	r30, r24
    1146:	73 97       	sbiw	r30, 0x13	; 19
    1148:	23 e1       	ldi	r18, 0x13	; 19
    114a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    114c:	fc 01       	movw	r30, r24
    114e:	74 97       	sbiw	r30, 0x14	; 20
    1150:	24 e1       	ldi	r18, 0x14	; 20
    1152:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1154:	fc 01       	movw	r30, r24
    1156:	75 97       	sbiw	r30, 0x15	; 21
    1158:	25 e1       	ldi	r18, 0x15	; 21
    115a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    115c:	fc 01       	movw	r30, r24
    115e:	76 97       	sbiw	r30, 0x16	; 22
    1160:	26 e1       	ldi	r18, 0x16	; 22
    1162:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1164:	fc 01       	movw	r30, r24
    1166:	77 97       	sbiw	r30, 0x17	; 23
    1168:	27 e1       	ldi	r18, 0x17	; 23
    116a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    116c:	fc 01       	movw	r30, r24
    116e:	78 97       	sbiw	r30, 0x18	; 24
    1170:	28 e1       	ldi	r18, 0x18	; 24
    1172:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1174:	fc 01       	movw	r30, r24
    1176:	79 97       	sbiw	r30, 0x19	; 25
    1178:	29 e1       	ldi	r18, 0x19	; 25
    117a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    117c:	fc 01       	movw	r30, r24
    117e:	7a 97       	sbiw	r30, 0x1a	; 26
    1180:	20 e2       	ldi	r18, 0x20	; 32
    1182:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1184:	fc 01       	movw	r30, r24
    1186:	7b 97       	sbiw	r30, 0x1b	; 27
    1188:	21 e2       	ldi	r18, 0x21	; 33
    118a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    118c:	fc 01       	movw	r30, r24
    118e:	7c 97       	sbiw	r30, 0x1c	; 28
    1190:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1192:	fc 01       	movw	r30, r24
    1194:	7d 97       	sbiw	r30, 0x1d	; 29
    1196:	23 e2       	ldi	r18, 0x23	; 35
    1198:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    119a:	fc 01       	movw	r30, r24
    119c:	7e 97       	sbiw	r30, 0x1e	; 30
    119e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    11a0:	fc 01       	movw	r30, r24
    11a2:	7f 97       	sbiw	r30, 0x1f	; 31
    11a4:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    11a6:	fc 01       	movw	r30, r24
    11a8:	b0 97       	sbiw	r30, 0x20	; 32
    11aa:	26 e2       	ldi	r18, 0x26	; 38
    11ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    11ae:	fc 01       	movw	r30, r24
    11b0:	b1 97       	sbiw	r30, 0x21	; 33
    11b2:	27 e2       	ldi	r18, 0x27	; 39
    11b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    11b6:	fc 01       	movw	r30, r24
    11b8:	b2 97       	sbiw	r30, 0x22	; 34
    11ba:	28 e2       	ldi	r18, 0x28	; 40
    11bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    11be:	fc 01       	movw	r30, r24
    11c0:	b3 97       	sbiw	r30, 0x23	; 35
    11c2:	29 e2       	ldi	r18, 0x29	; 41
    11c4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    11c6:	fc 01       	movw	r30, r24
    11c8:	b4 97       	sbiw	r30, 0x24	; 36
    11ca:	20 e3       	ldi	r18, 0x30	; 48
    11cc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    11ce:	fc 01       	movw	r30, r24
    11d0:	b5 97       	sbiw	r30, 0x25	; 37
    11d2:	21 e3       	ldi	r18, 0x31	; 49
    11d4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    11d6:	86 97       	sbiw	r24, 0x26	; 38
}
    11d8:	08 95       	ret

000011da <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    11da:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    11dc:	8c e7       	ldi	r24, 0x7C	; 124
    11de:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    11e0:	8b e0       	ldi	r24, 0x0B	; 11
    11e2:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    11e4:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    11e6:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    11e8:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    11ea:	a0 91 bb 06 	lds	r26, 0x06BB
    11ee:	b0 91 bc 06 	lds	r27, 0x06BC
    11f2:	cd 91       	ld	r28, X+
    11f4:	cd bf       	out	0x3d, r28	; 61
    11f6:	dd 91       	ld	r29, X+
    11f8:	de bf       	out	0x3e, r29	; 62
    11fa:	ff 91       	pop	r31
    11fc:	ef 91       	pop	r30
    11fe:	df 91       	pop	r29
    1200:	cf 91       	pop	r28
    1202:	bf 91       	pop	r27
    1204:	af 91       	pop	r26
    1206:	9f 91       	pop	r25
    1208:	8f 91       	pop	r24
    120a:	7f 91       	pop	r23
    120c:	6f 91       	pop	r22
    120e:	5f 91       	pop	r21
    1210:	4f 91       	pop	r20
    1212:	3f 91       	pop	r19
    1214:	2f 91       	pop	r18
    1216:	1f 91       	pop	r17
    1218:	0f 91       	pop	r16
    121a:	ff 90       	pop	r15
    121c:	ef 90       	pop	r14
    121e:	df 90       	pop	r13
    1220:	cf 90       	pop	r12
    1222:	bf 90       	pop	r11
    1224:	af 90       	pop	r10
    1226:	9f 90       	pop	r9
    1228:	8f 90       	pop	r8
    122a:	7f 90       	pop	r7
    122c:	6f 90       	pop	r6
    122e:	5f 90       	pop	r5
    1230:	4f 90       	pop	r4
    1232:	3f 90       	pop	r3
    1234:	2f 90       	pop	r2
    1236:	1f 90       	pop	r1
    1238:	0f 90       	pop	r0
    123a:	0f be       	out	0x3f, r0	; 63
    123c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    123e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1240:	81 e0       	ldi	r24, 0x01	; 1
    1242:	08 95       	ret

00001244 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1244:	08 95       	ret

00001246 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1246:	0f 92       	push	r0
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	0f 92       	push	r0
    124e:	1f 92       	push	r1
    1250:	11 24       	eor	r1, r1
    1252:	2f 92       	push	r2
    1254:	3f 92       	push	r3
    1256:	4f 92       	push	r4
    1258:	5f 92       	push	r5
    125a:	6f 92       	push	r6
    125c:	7f 92       	push	r7
    125e:	8f 92       	push	r8
    1260:	9f 92       	push	r9
    1262:	af 92       	push	r10
    1264:	bf 92       	push	r11
    1266:	cf 92       	push	r12
    1268:	df 92       	push	r13
    126a:	ef 92       	push	r14
    126c:	ff 92       	push	r15
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	2f 93       	push	r18
    1274:	3f 93       	push	r19
    1276:	4f 93       	push	r20
    1278:	5f 93       	push	r21
    127a:	6f 93       	push	r22
    127c:	7f 93       	push	r23
    127e:	8f 93       	push	r24
    1280:	9f 93       	push	r25
    1282:	af 93       	push	r26
    1284:	bf 93       	push	r27
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	ef 93       	push	r30
    128c:	ff 93       	push	r31
    128e:	a0 91 bb 06 	lds	r26, 0x06BB
    1292:	b0 91 bc 06 	lds	r27, 0x06BC
    1296:	0d b6       	in	r0, 0x3d	; 61
    1298:	0d 92       	st	X+, r0
    129a:	0e b6       	in	r0, 0x3e	; 62
    129c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    129e:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    12a2:	a0 91 bb 06 	lds	r26, 0x06BB
    12a6:	b0 91 bc 06 	lds	r27, 0x06BC
    12aa:	cd 91       	ld	r28, X+
    12ac:	cd bf       	out	0x3d, r28	; 61
    12ae:	dd 91       	ld	r29, X+
    12b0:	de bf       	out	0x3e, r29	; 62
    12b2:	ff 91       	pop	r31
    12b4:	ef 91       	pop	r30
    12b6:	df 91       	pop	r29
    12b8:	cf 91       	pop	r28
    12ba:	bf 91       	pop	r27
    12bc:	af 91       	pop	r26
    12be:	9f 91       	pop	r25
    12c0:	8f 91       	pop	r24
    12c2:	7f 91       	pop	r23
    12c4:	6f 91       	pop	r22
    12c6:	5f 91       	pop	r21
    12c8:	4f 91       	pop	r20
    12ca:	3f 91       	pop	r19
    12cc:	2f 91       	pop	r18
    12ce:	1f 91       	pop	r17
    12d0:	0f 91       	pop	r16
    12d2:	ff 90       	pop	r15
    12d4:	ef 90       	pop	r14
    12d6:	df 90       	pop	r13
    12d8:	cf 90       	pop	r12
    12da:	bf 90       	pop	r11
    12dc:	af 90       	pop	r10
    12de:	9f 90       	pop	r9
    12e0:	8f 90       	pop	r8
    12e2:	7f 90       	pop	r7
    12e4:	6f 90       	pop	r6
    12e6:	5f 90       	pop	r5
    12e8:	4f 90       	pop	r4
    12ea:	3f 90       	pop	r3
    12ec:	2f 90       	pop	r2
    12ee:	1f 90       	pop	r1
    12f0:	0f 90       	pop	r0
    12f2:	0f be       	out	0x3f, r0	; 63
    12f4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12f6:	08 95       	ret

000012f8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12f8:	0f 92       	push	r0
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	0f 92       	push	r0
    1300:	1f 92       	push	r1
    1302:	11 24       	eor	r1, r1
    1304:	2f 92       	push	r2
    1306:	3f 92       	push	r3
    1308:	4f 92       	push	r4
    130a:	5f 92       	push	r5
    130c:	6f 92       	push	r6
    130e:	7f 92       	push	r7
    1310:	8f 92       	push	r8
    1312:	9f 92       	push	r9
    1314:	af 92       	push	r10
    1316:	bf 92       	push	r11
    1318:	cf 92       	push	r12
    131a:	df 92       	push	r13
    131c:	ef 92       	push	r14
    131e:	ff 92       	push	r15
    1320:	0f 93       	push	r16
    1322:	1f 93       	push	r17
    1324:	2f 93       	push	r18
    1326:	3f 93       	push	r19
    1328:	4f 93       	push	r20
    132a:	5f 93       	push	r21
    132c:	6f 93       	push	r22
    132e:	7f 93       	push	r23
    1330:	8f 93       	push	r24
    1332:	9f 93       	push	r25
    1334:	af 93       	push	r26
    1336:	bf 93       	push	r27
    1338:	cf 93       	push	r28
    133a:	df 93       	push	r29
    133c:	ef 93       	push	r30
    133e:	ff 93       	push	r31
    1340:	a0 91 bb 06 	lds	r26, 0x06BB
    1344:	b0 91 bc 06 	lds	r27, 0x06BC
    1348:	0d b6       	in	r0, 0x3d	; 61
    134a:	0d 92       	st	X+, r0
    134c:	0e b6       	in	r0, 0x3e	; 62
    134e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1350:	0e 94 04 11 	call	0x2208	; 0x2208 <xTaskIncrementTick>
    1354:	88 23       	and	r24, r24
    1356:	11 f0       	breq	.+4      	; 0x135c <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1358:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    135c:	a0 91 bb 06 	lds	r26, 0x06BB
    1360:	b0 91 bc 06 	lds	r27, 0x06BC
    1364:	cd 91       	ld	r28, X+
    1366:	cd bf       	out	0x3d, r28	; 61
    1368:	dd 91       	ld	r29, X+
    136a:	de bf       	out	0x3e, r29	; 62
    136c:	ff 91       	pop	r31
    136e:	ef 91       	pop	r30
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	bf 91       	pop	r27
    1376:	af 91       	pop	r26
    1378:	9f 91       	pop	r25
    137a:	8f 91       	pop	r24
    137c:	7f 91       	pop	r23
    137e:	6f 91       	pop	r22
    1380:	5f 91       	pop	r21
    1382:	4f 91       	pop	r20
    1384:	3f 91       	pop	r19
    1386:	2f 91       	pop	r18
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	ff 90       	pop	r15
    138e:	ef 90       	pop	r14
    1390:	df 90       	pop	r13
    1392:	cf 90       	pop	r12
    1394:	bf 90       	pop	r11
    1396:	af 90       	pop	r10
    1398:	9f 90       	pop	r9
    139a:	8f 90       	pop	r8
    139c:	7f 90       	pop	r7
    139e:	6f 90       	pop	r6
    13a0:	5f 90       	pop	r5
    13a2:	4f 90       	pop	r4
    13a4:	3f 90       	pop	r3
    13a6:	2f 90       	pop	r2
    13a8:	1f 90       	pop	r1
    13aa:	0f 90       	pop	r0
    13ac:	0f be       	out	0x3f, r0	; 63
    13ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13b0:	08 95       	ret

000013b2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    13b2:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <vPortYieldFromTick>
		asm volatile ( "reti" );
    13b6:	18 95       	reti

000013b8 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    13b8:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	taskENTER_CRITICAL();
    13ba:	0f b6       	in	r0, 0x3f	; 63
    13bc:	f8 94       	cli
    13be:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    13c0:	22 8d       	ldd	r18, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    13c2:	0f 90       	pop	r0
    13c4:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
		{
			xReturn = pdTRUE;
    13c6:	81 e0       	ldi	r24, 0x01	; 1
    13c8:	93 8d       	ldd	r25, Z+27	; 0x1b
    13ca:	29 13       	cpse	r18, r25
    13cc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    13ce:	08 95       	ret

000013d0 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    13d0:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    13d2:	44 8d       	ldd	r20, Z+28	; 0x1c
    13d4:	44 23       	and	r20, r20
    13d6:	c1 f0       	breq	.+48     	; 0x1408 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    13d8:	26 81       	ldd	r18, Z+6	; 0x06
    13da:	37 81       	ldd	r19, Z+7	; 0x07
    13dc:	24 0f       	add	r18, r20
    13de:	31 1d       	adc	r19, r1
    13e0:	37 83       	std	Z+7, r19	; 0x07
    13e2:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    13e4:	a2 81       	ldd	r26, Z+2	; 0x02
    13e6:	b3 81       	ldd	r27, Z+3	; 0x03
    13e8:	2a 17       	cp	r18, r26
    13ea:	3b 07       	cpc	r19, r27
    13ec:	20 f0       	brcs	.+8      	; 0x13f6 <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    13ee:	20 81       	ld	r18, Z
    13f0:	31 81       	ldd	r19, Z+1	; 0x01
    13f2:	37 83       	std	Z+7, r19	; 0x07
    13f4:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    13f6:	36 81       	ldd	r19, Z+6	; 0x06
    13f8:	27 81       	ldd	r18, Z+7	; 0x07
    13fa:	86 2f       	mov	r24, r22
    13fc:	97 2f       	mov	r25, r23
    13fe:	63 2f       	mov	r22, r19
    1400:	72 2f       	mov	r23, r18
    1402:	50 e0       	ldi	r21, 0x00	; 0
    1404:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <memcpy>
    1408:	08 95       	ret

0000140a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    140a:	1f 93       	push	r17
    140c:	cf 93       	push	r28
    140e:	df 93       	push	r29
    1410:	ec 01       	movw	r28, r24
    1412:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1414:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1416:	44 23       	and	r20, r20
    1418:	61 f4       	brne	.+24     	; 0x1432 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    141a:	88 81       	ld	r24, Y
    141c:	99 81       	ldd	r25, Y+1	; 0x01
    141e:	00 97       	sbiw	r24, 0x00	; 0
    1420:	09 f0       	breq	.+2      	; 0x1424 <prvCopyDataToQueue+0x1a>
    1422:	45 c0       	rjmp	.+138    	; 0x14ae <prvCopyDataToQueue+0xa4>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1424:	8a 81       	ldd	r24, Y+2	; 0x02
    1426:	9b 81       	ldd	r25, Y+3	; 0x03
    1428:	0e 94 aa 14 	call	0x2954	; 0x2954 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    142c:	1b 82       	std	Y+3, r1	; 0x03
    142e:	1a 82       	std	Y+2, r1	; 0x02
    1430:	45 c0       	rjmp	.+138    	; 0x14bc <prvCopyDataToQueue+0xb2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1432:	11 23       	and	r17, r17
    1434:	b9 f4       	brne	.+46     	; 0x1464 <prvCopyDataToQueue+0x5a>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1436:	8c 81       	ldd	r24, Y+4	; 0x04
    1438:	9d 81       	ldd	r25, Y+5	; 0x05
    143a:	50 e0       	ldi	r21, 0x00	; 0
    143c:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1440:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1442:	8c 81       	ldd	r24, Y+4	; 0x04
    1444:	9d 81       	ldd	r25, Y+5	; 0x05
    1446:	82 0f       	add	r24, r18
    1448:	91 1d       	adc	r25, r1
    144a:	9d 83       	std	Y+5, r25	; 0x05
    144c:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    144e:	2a 81       	ldd	r18, Y+2	; 0x02
    1450:	3b 81       	ldd	r19, Y+3	; 0x03
    1452:	82 17       	cp	r24, r18
    1454:	93 07       	cpc	r25, r19
    1456:	68 f1       	brcs	.+90     	; 0x14b2 <prvCopyDataToQueue+0xa8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1458:	88 81       	ld	r24, Y
    145a:	99 81       	ldd	r25, Y+1	; 0x01
    145c:	9d 83       	std	Y+5, r25	; 0x05
    145e:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	2c c0       	rjmp	.+88     	; 0x14bc <prvCopyDataToQueue+0xb2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1464:	8e 81       	ldd	r24, Y+6	; 0x06
    1466:	9f 81       	ldd	r25, Y+7	; 0x07
    1468:	50 e0       	ldi	r21, 0x00	; 0
    146a:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    146e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1470:	50 e0       	ldi	r21, 0x00	; 0
    1472:	50 95       	com	r21
    1474:	41 95       	neg	r20
    1476:	5f 4f       	sbci	r21, 0xFF	; 255
    1478:	8e 81       	ldd	r24, Y+6	; 0x06
    147a:	9f 81       	ldd	r25, Y+7	; 0x07
    147c:	84 0f       	add	r24, r20
    147e:	95 1f       	adc	r25, r21
    1480:	9f 83       	std	Y+7, r25	; 0x07
    1482:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1484:	28 81       	ld	r18, Y
    1486:	39 81       	ldd	r19, Y+1	; 0x01
    1488:	82 17       	cp	r24, r18
    148a:	93 07       	cpc	r25, r19
    148c:	30 f4       	brcc	.+12     	; 0x149a <prvCopyDataToQueue+0x90>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    148e:	8a 81       	ldd	r24, Y+2	; 0x02
    1490:	9b 81       	ldd	r25, Y+3	; 0x03
    1492:	84 0f       	add	r24, r20
    1494:	95 1f       	adc	r25, r21
    1496:	9f 83       	std	Y+7, r25	; 0x07
    1498:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    149a:	12 30       	cpi	r17, 0x02	; 2
    149c:	61 f4       	brne	.+24     	; 0x14b6 <prvCopyDataToQueue+0xac>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    149e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14a0:	88 23       	and	r24, r24
    14a2:	59 f0       	breq	.+22     	; 0x14ba <prvCopyDataToQueue+0xb0>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    14a4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14a6:	81 50       	subi	r24, 0x01	; 1
    14a8:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	07 c0       	rjmp	.+14     	; 0x14bc <prvCopyDataToQueue+0xb2>
    14ae:	80 e0       	ldi	r24, 0x00	; 0
    14b0:	05 c0       	rjmp	.+10     	; 0x14bc <prvCopyDataToQueue+0xb2>
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	03 c0       	rjmp	.+6      	; 0x14bc <prvCopyDataToQueue+0xb2>
    14b6:	80 e0       	ldi	r24, 0x00	; 0
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <prvCopyDataToQueue+0xb2>
    14ba:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    14bc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14be:	9f 5f       	subi	r25, 0xFF	; 255
    14c0:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    14c2:	df 91       	pop	r29
    14c4:	cf 91       	pop	r28
    14c6:	1f 91       	pop	r17
    14c8:	08 95       	ret

000014ca <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    14ca:	0f 93       	push	r16
    14cc:	1f 93       	push	r17
    14ce:	cf 93       	push	r28
    14d0:	df 93       	push	r29
    14d2:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    14d4:	0f b6       	in	r0, 0x3f	; 63
    14d6:	f8 94       	cli
    14d8:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14dc:	18 16       	cp	r1, r24
    14de:	c4 f4       	brge	.+48     	; 0x1510 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14e0:	89 89       	ldd	r24, Y+17	; 0x11
    14e2:	88 23       	and	r24, r24
    14e4:	29 f4       	brne	.+10     	; 0x14f0 <prvUnlockQueue+0x26>
    14e6:	14 c0       	rjmp	.+40     	; 0x1510 <prvUnlockQueue+0x46>
    14e8:	89 89       	ldd	r24, Y+17	; 0x11
    14ea:	88 23       	and	r24, r24
    14ec:	21 f4       	brne	.+8      	; 0x14f6 <prvUnlockQueue+0x2c>
    14ee:	10 c0       	rjmp	.+32     	; 0x1510 <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14f0:	8e 01       	movw	r16, r28
    14f2:	0f 5e       	subi	r16, 0xEF	; 239
    14f4:	1f 4f       	sbci	r17, 0xFF	; 255
    14f6:	c8 01       	movw	r24, r16
    14f8:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    14fc:	88 23       	and	r24, r24
    14fe:	11 f0       	breq	.+4      	; 0x1504 <prvUnlockQueue+0x3a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1500:	0e 94 43 14 	call	0x2886	; 0x2886 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1504:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1506:	81 50       	subi	r24, 0x01	; 1
    1508:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    150a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    150c:	18 16       	cp	r1, r24
    150e:	64 f3       	brlt	.-40     	; 0x14e8 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1510:	8f ef       	ldi	r24, 0xFF	; 255
    1512:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1514:	0f 90       	pop	r0
    1516:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1518:	0f b6       	in	r0, 0x3f	; 63
    151a:	f8 94       	cli
    151c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    151e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1520:	18 16       	cp	r1, r24
    1522:	c4 f4       	brge	.+48     	; 0x1554 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1524:	88 85       	ldd	r24, Y+8	; 0x08
    1526:	88 23       	and	r24, r24
    1528:	29 f4       	brne	.+10     	; 0x1534 <prvUnlockQueue+0x6a>
    152a:	14 c0       	rjmp	.+40     	; 0x1554 <prvUnlockQueue+0x8a>
    152c:	88 85       	ldd	r24, Y+8	; 0x08
    152e:	88 23       	and	r24, r24
    1530:	21 f4       	brne	.+8      	; 0x153a <prvUnlockQueue+0x70>
    1532:	10 c0       	rjmp	.+32     	; 0x1554 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1534:	8e 01       	movw	r16, r28
    1536:	08 5f       	subi	r16, 0xF8	; 248
    1538:	1f 4f       	sbci	r17, 0xFF	; 255
    153a:	c8 01       	movw	r24, r16
    153c:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    1540:	88 23       	and	r24, r24
    1542:	11 f0       	breq	.+4      	; 0x1548 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    1544:	0e 94 43 14 	call	0x2886	; 0x2886 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1548:	8d 8d       	ldd	r24, Y+29	; 0x1d
    154a:	81 50       	subi	r24, 0x01	; 1
    154c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    154e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1550:	18 16       	cp	r1, r24
    1552:	64 f3       	brlt	.-40     	; 0x152c <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1554:	8f ef       	ldi	r24, 0xFF	; 255
    1556:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1558:	0f 90       	pop	r0
    155a:	0f be       	out	0x3f, r0	; 63
}
    155c:	df 91       	pop	r29
    155e:	cf 91       	pop	r28
    1560:	1f 91       	pop	r17
    1562:	0f 91       	pop	r16
    1564:	08 95       	ret

00001566 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1566:	cf 93       	push	r28
    1568:	df 93       	push	r29
    156a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1572:	48 81       	ld	r20, Y
    1574:	59 81       	ldd	r21, Y+1	; 0x01
    1576:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1578:	30 e0       	ldi	r19, 0x00	; 0
    157a:	ec 8d       	ldd	r30, Y+28	; 0x1c
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	2e 9f       	mul	r18, r30
    1580:	c0 01       	movw	r24, r0
    1582:	2f 9f       	mul	r18, r31
    1584:	90 0d       	add	r25, r0
    1586:	3e 9f       	mul	r19, r30
    1588:	90 0d       	add	r25, r0
    158a:	11 24       	eor	r1, r1
    158c:	84 0f       	add	r24, r20
    158e:	95 1f       	adc	r25, r21
    1590:	9b 83       	std	Y+3, r25	; 0x03
    1592:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1594:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1596:	5d 83       	std	Y+5, r21	; 0x05
    1598:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    159a:	c9 01       	movw	r24, r18
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	e8 9f       	mul	r30, r24
    15a0:	90 01       	movw	r18, r0
    15a2:	e9 9f       	mul	r30, r25
    15a4:	30 0d       	add	r19, r0
    15a6:	f8 9f       	mul	r31, r24
    15a8:	30 0d       	add	r19, r0
    15aa:	11 24       	eor	r1, r1
    15ac:	24 0f       	add	r18, r20
    15ae:	35 1f       	adc	r19, r21
    15b0:	3f 83       	std	Y+7, r19	; 0x07
    15b2:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    15b4:	8f ef       	ldi	r24, 0xFF	; 255
    15b6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    15b8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    15ba:	66 23       	and	r22, r22
    15bc:	61 f4       	brne	.+24     	; 0x15d6 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15be:	88 85       	ldd	r24, Y+8	; 0x08
    15c0:	88 23       	and	r24, r24
    15c2:	89 f0       	breq	.+34     	; 0x15e6 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    15c4:	ce 01       	movw	r24, r28
    15c6:	08 96       	adiw	r24, 0x08	; 8
    15c8:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    15cc:	81 30       	cpi	r24, 0x01	; 1
    15ce:	59 f4       	brne	.+22     	; 0x15e6 <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
    15d0:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    15d4:	08 c0       	rjmp	.+16     	; 0x15e6 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    15d6:	ce 01       	movw	r24, r28
    15d8:	08 96       	adiw	r24, 0x08	; 8
    15da:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    15de:	ce 01       	movw	r24, r28
    15e0:	41 96       	adiw	r24, 0x11	; 17
    15e2:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    15e6:	0f 90       	pop	r0
    15e8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	df 91       	pop	r29
    15ee:	cf 91       	pop	r28
    15f0:	08 95       	ret

000015f2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    15f2:	0f 93       	push	r16
    15f4:	1f 93       	push	r17
    15f6:	cf 93       	push	r28
    15f8:	df 93       	push	r29
    15fa:	18 2f       	mov	r17, r24
    15fc:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    15fe:	88 23       	and	r24, r24
    1600:	f9 f0       	breq	.+62     	; 0x1640 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1602:	8f e1       	ldi	r24, 0x1F	; 31
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
    160a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    160c:	00 97       	sbiw	r24, 0x00	; 0
    160e:	d9 f0       	breq	.+54     	; 0x1646 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1610:	01 9f       	mul	r16, r17
    1612:	c0 01       	movw	r24, r0
    1614:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1616:	01 96       	adiw	r24, 0x01	; 1
    1618:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
    161c:	99 83       	std	Y+1, r25	; 0x01
    161e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1620:	00 97       	sbiw	r24, 0x00	; 0
    1622:	41 f0       	breq	.+16     	; 0x1634 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1624:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1626:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1628:	ce 01       	movw	r24, r28
    162a:	61 e0       	ldi	r22, 0x01	; 1
    162c:	0e 94 b3 0a 	call	0x1566	; 0x1566 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1630:	ce 01       	movw	r24, r28
    1632:	0b c0       	rjmp	.+22     	; 0x164a <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1634:	ce 01       	movw	r24, r28
    1636:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    163a:	80 e0       	ldi	r24, 0x00	; 0
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	05 c0       	rjmp	.+10     	; 0x164a <xQueueGenericCreate+0x58>
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	02 c0       	rjmp	.+4      	; 0x164a <xQueueGenericCreate+0x58>
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    164a:	df 91       	pop	r29
    164c:	cf 91       	pop	r28
    164e:	1f 91       	pop	r17
    1650:	0f 91       	pop	r16
    1652:	08 95       	ret

00001654 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    1654:	cf 93       	push	r28
    1656:	c6 2f       	mov	r28, r22
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    1658:	60 e0       	ldi	r22, 0x00	; 0
    165a:	42 e0       	ldi	r20, 0x02	; 2
    165c:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <xQueueGenericCreate>

		if( xHandle != NULL )
    1660:	00 97       	sbiw	r24, 0x00	; 0
    1662:	11 f0       	breq	.+4      	; 0x1668 <xQueueCreateCountingSemaphore+0x14>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    1664:	fc 01       	movw	r30, r24
    1666:	c2 8f       	std	Z+26, r28	; 0x1a
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
	}
    1668:	cf 91       	pop	r28
    166a:	08 95       	ret

0000166c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    166c:	8f 92       	push	r8
    166e:	9f 92       	push	r9
    1670:	bf 92       	push	r11
    1672:	cf 92       	push	r12
    1674:	df 92       	push	r13
    1676:	ef 92       	push	r14
    1678:	ff 92       	push	r15
    167a:	0f 93       	push	r16
    167c:	1f 93       	push	r17
    167e:	cf 93       	push	r28
    1680:	df 93       	push	r29
    1682:	00 d0       	rcall	.+0      	; 0x1684 <xQueueGenericSend+0x18>
    1684:	00 d0       	rcall	.+0      	; 0x1686 <xQueueGenericSend+0x1a>
    1686:	0f 92       	push	r0
    1688:	cd b7       	in	r28, 0x3d	; 61
    168a:	de b7       	in	r29, 0x3e	; 62
    168c:	8c 01       	movw	r16, r24
    168e:	4b 01       	movw	r8, r22
    1690:	5d 83       	std	Y+5, r21	; 0x05
    1692:	4c 83       	std	Y+4, r20	; 0x04
    1694:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1696:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1698:	bb 24       	eor	r11, r11
    169a:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    169c:	cc 24       	eor	r12, r12
    169e:	dd 24       	eor	r13, r13
    16a0:	68 94       	set
    16a2:	c3 f8       	bld	r12, 3
    16a4:	c8 0e       	add	r12, r24
    16a6:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16a8:	0f b6       	in	r0, 0x3f	; 63
    16aa:	f8 94       	cli
    16ac:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    16ae:	f8 01       	movw	r30, r16
    16b0:	92 8d       	ldd	r25, Z+26	; 0x1a
    16b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    16b4:	98 17       	cp	r25, r24
    16b6:	18 f0       	brcs	.+6      	; 0x16be <xQueueGenericSend+0x52>
    16b8:	f2 e0       	ldi	r31, 0x02	; 2
    16ba:	ef 16       	cp	r14, r31
    16bc:	d1 f4       	brne	.+52     	; 0x16f2 <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    16be:	c8 01       	movw	r24, r16
    16c0:	b4 01       	movw	r22, r8
    16c2:	4e 2d       	mov	r20, r14
    16c4:	0e 94 05 0a 	call	0x140a	; 0x140a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16c8:	f8 01       	movw	r30, r16
    16ca:	91 89       	ldd	r25, Z+17	; 0x11
    16cc:	99 23       	and	r25, r25
    16ce:	49 f0       	breq	.+18     	; 0x16e2 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    16d0:	c8 01       	movw	r24, r16
    16d2:	41 96       	adiw	r24, 0x11	; 17
    16d4:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    16d8:	81 30       	cpi	r24, 0x01	; 1
    16da:	39 f4       	brne	.+14     	; 0x16ea <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    16dc:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    16e0:	04 c0       	rjmp	.+8      	; 0x16ea <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    16e2:	88 23       	and	r24, r24
    16e4:	11 f0       	breq	.+4      	; 0x16ea <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    16e6:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    16ea:	0f 90       	pop	r0
    16ec:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	4c c0       	rjmp	.+152    	; 0x178a <xQueueGenericSend+0x11e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    16f2:	8c 81       	ldd	r24, Y+4	; 0x04
    16f4:	9d 81       	ldd	r25, Y+5	; 0x05
    16f6:	00 97       	sbiw	r24, 0x00	; 0
    16f8:	21 f4       	brne	.+8      	; 0x1702 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16fa:	0f 90       	pop	r0
    16fc:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    16fe:	80 e0       	ldi	r24, 0x00	; 0
    1700:	44 c0       	rjmp	.+136    	; 0x178a <xQueueGenericSend+0x11e>
				}
				else if( xEntryTimeSet == pdFALSE )
    1702:	ff 20       	and	r15, r15
    1704:	29 f4       	brne	.+10     	; 0x1710 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1706:	ce 01       	movw	r24, r28
    1708:	01 96       	adiw	r24, 0x01	; 1
    170a:	0e 94 09 14 	call	0x2812	; 0x2812 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    170e:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1710:	0f 90       	pop	r0
    1712:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1714:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1718:	0f b6       	in	r0, 0x3f	; 63
    171a:	f8 94       	cli
    171c:	0f 92       	push	r0
    171e:	f8 01       	movw	r30, r16
    1720:	85 8d       	ldd	r24, Z+29	; 0x1d
    1722:	8f 3f       	cpi	r24, 0xFF	; 255
    1724:	09 f4       	brne	.+2      	; 0x1728 <xQueueGenericSend+0xbc>
    1726:	15 8e       	std	Z+29, r1	; 0x1d
    1728:	f8 01       	movw	r30, r16
    172a:	86 8d       	ldd	r24, Z+30	; 0x1e
    172c:	8f 3f       	cpi	r24, 0xFF	; 255
    172e:	09 f4       	brne	.+2      	; 0x1732 <xQueueGenericSend+0xc6>
    1730:	16 8e       	std	Z+30, r1	; 0x1e
    1732:	0f 90       	pop	r0
    1734:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1736:	ce 01       	movw	r24, r28
    1738:	01 96       	adiw	r24, 0x01	; 1
    173a:	be 01       	movw	r22, r28
    173c:	6c 5f       	subi	r22, 0xFC	; 252
    173e:	7f 4f       	sbci	r23, 0xFF	; 255
    1740:	0e 94 14 14 	call	0x2828	; 0x2828 <xTaskCheckForTimeOut>
    1744:	88 23       	and	r24, r24
    1746:	d9 f4       	brne	.+54     	; 0x177e <xQueueGenericSend+0x112>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1748:	c8 01       	movw	r24, r16
    174a:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <prvIsQueueFull>
    174e:	88 23       	and	r24, r24
    1750:	81 f0       	breq	.+32     	; 0x1772 <xQueueGenericSend+0x106>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1752:	6c 81       	ldd	r22, Y+4	; 0x04
    1754:	7d 81       	ldd	r23, Y+5	; 0x05
    1756:	c6 01       	movw	r24, r12
    1758:	0e 94 43 13 	call	0x2686	; 0x2686 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    175c:	c8 01       	movw	r24, r16
    175e:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1762:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
    1766:	88 23       	and	r24, r24
    1768:	09 f0       	breq	.+2      	; 0x176c <xQueueGenericSend+0x100>
    176a:	9e cf       	rjmp	.-196    	; 0x16a8 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    176c:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    1770:	9b cf       	rjmp	.-202    	; 0x16a8 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1772:	c8 01       	movw	r24, r16
    1774:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1778:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
    177c:	95 cf       	rjmp	.-214    	; 0x16a8 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    177e:	c8 01       	movw	r24, r16
    1780:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1784:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1788:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    178a:	0f 90       	pop	r0
    178c:	0f 90       	pop	r0
    178e:	0f 90       	pop	r0
    1790:	0f 90       	pop	r0
    1792:	0f 90       	pop	r0
    1794:	df 91       	pop	r29
    1796:	cf 91       	pop	r28
    1798:	1f 91       	pop	r17
    179a:	0f 91       	pop	r16
    179c:	ff 90       	pop	r15
    179e:	ef 90       	pop	r14
    17a0:	df 90       	pop	r13
    17a2:	cf 90       	pop	r12
    17a4:	bf 90       	pop	r11
    17a6:	9f 90       	pop	r9
    17a8:	8f 90       	pop	r8
    17aa:	08 95       	ret

000017ac <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    17b0:	8f e1       	ldi	r24, 0x1F	; 31
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
    17b8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    17ba:	00 97       	sbiw	r24, 0x00	; 0
    17bc:	f9 f0       	breq	.+62     	; 0x17fc <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    17be:	1b 82       	std	Y+3, r1	; 0x03
    17c0:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    17c2:	19 82       	std	Y+1, r1	; 0x01
    17c4:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    17c6:	1d 82       	std	Y+5, r1	; 0x05
    17c8:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    17ca:	1f 82       	std	Y+7, r1	; 0x07
    17cc:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17ce:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    17d0:	81 e0       	ldi	r24, 0x01	; 1
    17d2:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    17d4:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    17d6:	8f ef       	ldi	r24, 0xFF	; 255
    17d8:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    17da:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    17dc:	ce 01       	movw	r24, r28
    17de:	08 96       	adiw	r24, 0x08	; 8
    17e0:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    17e4:	ce 01       	movw	r24, r28
    17e6:	41 96       	adiw	r24, 0x11	; 17
    17e8:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    17ec:	ce 01       	movw	r24, r28
    17ee:	60 e0       	ldi	r22, 0x00	; 0
    17f0:	70 e0       	ldi	r23, 0x00	; 0
    17f2:	40 e0       	ldi	r20, 0x00	; 0
    17f4:	50 e0       	ldi	r21, 0x00	; 0
    17f6:	20 e0       	ldi	r18, 0x00	; 0
    17f8:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    17fc:	8c 2f       	mov	r24, r28
    17fe:	9d 2f       	mov	r25, r29
    1800:	df 91       	pop	r29
    1802:	cf 91       	pop	r28
    1804:	08 95       	ret

00001806 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1806:	0f 93       	push	r16
    1808:	1f 93       	push	r17
    180a:	cf 93       	push	r28
    180c:	df 93       	push	r29
    180e:	ec 01       	movw	r28, r24
    1810:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1812:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1814:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1816:	98 17       	cp	r25, r24
    1818:	10 f0       	brcs	.+4      	; 0x181e <xQueueGenericSendFromISR+0x18>
    181a:	22 30       	cpi	r18, 0x02	; 2
    181c:	21 f5       	brne	.+72     	; 0x1866 <xQueueGenericSendFromISR+0x60>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    181e:	ce 01       	movw	r24, r28
    1820:	42 2f       	mov	r20, r18
    1822:	0e 94 05 0a 	call	0x140a	; 0x140a <prvCopyDataToQueue>
    1826:	88 23       	and	r24, r24
    1828:	31 f0       	breq	.+12     	; 0x1836 <xQueueGenericSendFromISR+0x30>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    182a:	01 15       	cp	r16, r1
    182c:	11 05       	cpc	r17, r1
    182e:	19 f0       	breq	.+6      	; 0x1836 <xQueueGenericSendFromISR+0x30>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	f8 01       	movw	r30, r16
    1834:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1836:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1838:	8f 3f       	cpi	r24, 0xFF	; 255
    183a:	81 f4       	brne	.+32     	; 0x185c <xQueueGenericSendFromISR+0x56>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    183c:	89 89       	ldd	r24, Y+17	; 0x11
    183e:	88 23       	and	r24, r24
    1840:	a1 f0       	breq	.+40     	; 0x186a <xQueueGenericSendFromISR+0x64>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1842:	ce 01       	movw	r24, r28
    1844:	41 96       	adiw	r24, 0x11	; 17
    1846:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    184a:	88 23       	and	r24, r24
    184c:	81 f0       	breq	.+32     	; 0x186e <xQueueGenericSendFromISR+0x68>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    184e:	01 15       	cp	r16, r1
    1850:	11 05       	cpc	r17, r1
    1852:	79 f0       	breq	.+30     	; 0x1872 <xQueueGenericSendFromISR+0x6c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	f8 01       	movw	r30, r16
    1858:	80 83       	st	Z, r24
    185a:	0c c0       	rjmp	.+24     	; 0x1874 <xQueueGenericSendFromISR+0x6e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    185c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    185e:	8f 5f       	subi	r24, 0xFF	; 255
    1860:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	07 c0       	rjmp	.+14     	; 0x1874 <xQueueGenericSendFromISR+0x6e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1866:	80 e0       	ldi	r24, 0x00	; 0
    1868:	05 c0       	rjmp	.+10     	; 0x1874 <xQueueGenericSendFromISR+0x6e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    186a:	81 e0       	ldi	r24, 0x01	; 1
    186c:	03 c0       	rjmp	.+6      	; 0x1874 <xQueueGenericSendFromISR+0x6e>
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	01 c0       	rjmp	.+2      	; 0x1874 <xQueueGenericSendFromISR+0x6e>
    1872:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1874:	df 91       	pop	r29
    1876:	cf 91       	pop	r28
    1878:	1f 91       	pop	r17
    187a:	0f 91       	pop	r16
    187c:	08 95       	ret

0000187e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    187e:	8f 92       	push	r8
    1880:	9f 92       	push	r9
    1882:	bf 92       	push	r11
    1884:	cf 92       	push	r12
    1886:	df 92       	push	r13
    1888:	ef 92       	push	r14
    188a:	ff 92       	push	r15
    188c:	0f 93       	push	r16
    188e:	1f 93       	push	r17
    1890:	cf 93       	push	r28
    1892:	df 93       	push	r29
    1894:	00 d0       	rcall	.+0      	; 0x1896 <xQueueGenericReceive+0x18>
    1896:	00 d0       	rcall	.+0      	; 0x1898 <xQueueGenericReceive+0x1a>
    1898:	0f 92       	push	r0
    189a:	cd b7       	in	r28, 0x3d	; 61
    189c:	de b7       	in	r29, 0x3e	; 62
    189e:	8c 01       	movw	r16, r24
    18a0:	4b 01       	movw	r8, r22
    18a2:	5d 83       	std	Y+5, r21	; 0x05
    18a4:	4c 83       	std	Y+4, r20	; 0x04
    18a6:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    18a8:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    18aa:	ee 24       	eor	r14, r14
    18ac:	e3 94       	inc	r14
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18ae:	0f 2e       	mov	r0, r31
    18b0:	f1 e1       	ldi	r31, 0x11	; 17
    18b2:	cf 2e       	mov	r12, r31
    18b4:	dd 24       	eor	r13, r13
    18b6:	f0 2d       	mov	r31, r0
    18b8:	c8 0e       	add	r12, r24
    18ba:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	f8 94       	cli
    18c0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    18c2:	f8 01       	movw	r30, r16
    18c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    18c6:	88 23       	and	r24, r24
    18c8:	a1 f1       	breq	.+104    	; 0x1932 <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    18ca:	e6 80       	ldd	r14, Z+6	; 0x06
    18cc:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18ce:	c8 01       	movw	r24, r16
    18d0:	b4 01       	movw	r22, r8
    18d2:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    18d6:	bb 20       	and	r11, r11
    18d8:	d1 f4       	brne	.+52     	; 0x190e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    18da:	f8 01       	movw	r30, r16
    18dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    18de:	81 50       	subi	r24, 0x01	; 1
    18e0:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18e2:	80 81       	ld	r24, Z
    18e4:	91 81       	ldd	r25, Z+1	; 0x01
    18e6:	00 97       	sbiw	r24, 0x00	; 0
    18e8:	29 f4       	brne	.+10     	; 0x18f4 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    18ea:	0e 94 03 15 	call	0x2a06	; 0x2a06 <pvTaskIncrementMutexHeldCount>
    18ee:	f8 01       	movw	r30, r16
    18f0:	93 83       	std	Z+3, r25	; 0x03
    18f2:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18f4:	f8 01       	movw	r30, r16
    18f6:	80 85       	ldd	r24, Z+8	; 0x08
    18f8:	88 23       	and	r24, r24
    18fa:	b9 f0       	breq	.+46     	; 0x192a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    18fc:	c8 01       	movw	r24, r16
    18fe:	08 96       	adiw	r24, 0x08	; 8
    1900:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    1904:	81 30       	cpi	r24, 0x01	; 1
    1906:	89 f4       	brne	.+34     	; 0x192a <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1908:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    190c:	0e c0       	rjmp	.+28     	; 0x192a <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    190e:	f8 01       	movw	r30, r16
    1910:	f7 82       	std	Z+7, r15	; 0x07
    1912:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1914:	81 89       	ldd	r24, Z+17	; 0x11
    1916:	88 23       	and	r24, r24
    1918:	41 f0       	breq	.+16     	; 0x192a <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    191a:	c8 01       	movw	r24, r16
    191c:	41 96       	adiw	r24, 0x11	; 17
    191e:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    1922:	88 23       	and	r24, r24
    1924:	11 f0       	breq	.+4      	; 0x192a <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1926:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    192a:	0f 90       	pop	r0
    192c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    192e:	81 e0       	ldi	r24, 0x01	; 1
    1930:	5f c0       	rjmp	.+190    	; 0x19f0 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1932:	8c 81       	ldd	r24, Y+4	; 0x04
    1934:	9d 81       	ldd	r25, Y+5	; 0x05
    1936:	00 97       	sbiw	r24, 0x00	; 0
    1938:	21 f4       	brne	.+8      	; 0x1942 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    193a:	0f 90       	pop	r0
    193c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	57 c0       	rjmp	.+174    	; 0x19f0 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    1942:	ff 20       	and	r15, r15
    1944:	29 f4       	brne	.+10     	; 0x1950 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1946:	ce 01       	movw	r24, r28
    1948:	01 96       	adiw	r24, 0x01	; 1
    194a:	0e 94 09 14 	call	0x2812	; 0x2812 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    194e:	fe 2c       	mov	r15, r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1954:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1958:	0f b6       	in	r0, 0x3f	; 63
    195a:	f8 94       	cli
    195c:	0f 92       	push	r0
    195e:	f8 01       	movw	r30, r16
    1960:	85 8d       	ldd	r24, Z+29	; 0x1d
    1962:	8f 3f       	cpi	r24, 0xFF	; 255
    1964:	09 f4       	brne	.+2      	; 0x1968 <xQueueGenericReceive+0xea>
    1966:	15 8e       	std	Z+29, r1	; 0x1d
    1968:	f8 01       	movw	r30, r16
    196a:	86 8d       	ldd	r24, Z+30	; 0x1e
    196c:	8f 3f       	cpi	r24, 0xFF	; 255
    196e:	09 f4       	brne	.+2      	; 0x1972 <xQueueGenericReceive+0xf4>
    1970:	16 8e       	std	Z+30, r1	; 0x1e
    1972:	0f 90       	pop	r0
    1974:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1976:	ce 01       	movw	r24, r28
    1978:	01 96       	adiw	r24, 0x01	; 1
    197a:	be 01       	movw	r22, r28
    197c:	6c 5f       	subi	r22, 0xFC	; 252
    197e:	7f 4f       	sbci	r23, 0xFF	; 255
    1980:	0e 94 14 14 	call	0x2828	; 0x2828 <xTaskCheckForTimeOut>
    1984:	88 23       	and	r24, r24
    1986:	71 f5       	brne	.+92     	; 0x19e4 <xQueueGenericReceive+0x166>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	f8 94       	cli
    198c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    198e:	f8 01       	movw	r30, r16
    1990:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1992:	0f 90       	pop	r0
    1994:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1996:	88 23       	and	r24, r24
    1998:	f9 f4       	brne	.+62     	; 0x19d8 <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    199a:	f8 01       	movw	r30, r16
    199c:	80 81       	ld	r24, Z
    199e:	91 81       	ldd	r25, Z+1	; 0x01
    19a0:	00 97       	sbiw	r24, 0x00	; 0
    19a2:	51 f4       	brne	.+20     	; 0x19b8 <xQueueGenericReceive+0x13a>
					{
						taskENTER_CRITICAL();
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    19aa:	f8 01       	movw	r30, r16
    19ac:	82 81       	ldd	r24, Z+2	; 0x02
    19ae:	93 81       	ldd	r25, Z+3	; 0x03
    19b0:	0e 94 4c 14 	call	0x2898	; 0x2898 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    19b4:	0f 90       	pop	r0
    19b6:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19b8:	6c 81       	ldd	r22, Y+4	; 0x04
    19ba:	7d 81       	ldd	r23, Y+5	; 0x05
    19bc:	c6 01       	movw	r24, r12
    19be:	0e 94 43 13 	call	0x2686	; 0x2686 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19c2:	c8 01       	movw	r24, r16
    19c4:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19c8:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
    19cc:	88 23       	and	r24, r24
    19ce:	09 f0       	breq	.+2      	; 0x19d2 <xQueueGenericReceive+0x154>
    19d0:	75 cf       	rjmp	.-278    	; 0x18bc <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    19d2:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    19d6:	72 cf       	rjmp	.-284    	; 0x18bc <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19d8:	c8 01       	movw	r24, r16
    19da:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19de:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
    19e2:	6c cf       	rjmp	.-296    	; 0x18bc <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    19e4:	c8 01       	movw	r24, r16
    19e6:	0e 94 65 0a 	call	0x14ca	; 0x14ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19ea:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    19ee:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    19f0:	0f 90       	pop	r0
    19f2:	0f 90       	pop	r0
    19f4:	0f 90       	pop	r0
    19f6:	0f 90       	pop	r0
    19f8:	0f 90       	pop	r0
    19fa:	df 91       	pop	r29
    19fc:	cf 91       	pop	r28
    19fe:	1f 91       	pop	r17
    1a00:	0f 91       	pop	r16
    1a02:	ff 90       	pop	r15
    1a04:	ef 90       	pop	r14
    1a06:	df 90       	pop	r13
    1a08:	cf 90       	pop	r12
    1a0a:	bf 90       	pop	r11
    1a0c:	9f 90       	pop	r9
    1a0e:	8f 90       	pop	r8
    1a10:	08 95       	ret

00001a12 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a12:	0f 93       	push	r16
    1a14:	1f 93       	push	r17
    1a16:	cf 93       	push	r28
    1a18:	df 93       	push	r29
    1a1a:	ec 01       	movw	r28, r24
    1a1c:	8a 01       	movw	r16, r20
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a1e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a20:	88 23       	and	r24, r24
    1a22:	f1 f0       	breq	.+60     	; 0x1a60 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a24:	ce 01       	movw	r24, r28
    1a26:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1a2a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a2c:	81 50       	subi	r24, 0x01	; 1
    1a2e:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1a30:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1a32:	8f 3f       	cpi	r24, 0xFF	; 255
    1a34:	81 f4       	brne	.+32     	; 0x1a56 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a36:	88 85       	ldd	r24, Y+8	; 0x08
    1a38:	88 23       	and	r24, r24
    1a3a:	a1 f0       	breq	.+40     	; 0x1a64 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a3c:	ce 01       	movw	r24, r28
    1a3e:	08 96       	adiw	r24, 0x08	; 8
    1a40:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskRemoveFromEventList>
    1a44:	88 23       	and	r24, r24
    1a46:	81 f0       	breq	.+32     	; 0x1a68 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a48:	01 15       	cp	r16, r1
    1a4a:	11 05       	cpc	r17, r1
    1a4c:	79 f0       	breq	.+30     	; 0x1a6c <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	f8 01       	movw	r30, r16
    1a52:	80 83       	st	Z, r24
    1a54:	0c c0       	rjmp	.+24     	; 0x1a6e <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1a56:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1a58:	8f 5f       	subi	r24, 0xFF	; 255
    1a5a:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	07 c0       	rjmp	.+14     	; 0x1a6e <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1a60:	80 e0       	ldi	r24, 0x00	; 0
    1a62:	05 c0       	rjmp	.+10     	; 0x1a6e <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	03 c0       	rjmp	.+6      	; 0x1a6e <xQueueReceiveFromISR+0x5c>
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	01 c0       	rjmp	.+2      	; 0x1a6e <xQueueReceiveFromISR+0x5c>
    1a6c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	1f 91       	pop	r17
    1a74:	0f 91       	pop	r16
    1a76:	08 95       	ret

00001a78 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1a78:	0f 93       	push	r16
    1a7a:	1f 93       	push	r17
    1a7c:	cf 93       	push	r28
    1a7e:	df 93       	push	r29
    1a80:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a82:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a84:	88 23       	and	r24, r24
    1a86:	49 f0       	breq	.+18     	; 0x1a9a <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a88:	0e 81       	ldd	r16, Y+6	; 0x06
    1a8a:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a8c:	ce 01       	movw	r24, r28
    1a8e:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a92:	1f 83       	std	Y+7, r17	; 0x07
    1a94:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1a96:	81 e0       	ldi	r24, 0x01	; 1
    1a98:	01 c0       	rjmp	.+2      	; 0x1a9c <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1a9a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a9c:	df 91       	pop	r29
    1a9e:	cf 91       	pop	r28
    1aa0:	1f 91       	pop	r17
    1aa2:	0f 91       	pop	r16
    1aa4:	08 95       	ret

00001aa6 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1aa6:	0f b6       	in	r0, 0x3f	; 63
    1aa8:	f8 94       	cli
    1aaa:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1aac:	fc 01       	movw	r30, r24
    1aae:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1ab0:	0f 90       	pop	r0
    1ab2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ab4:	08 95       	ret

00001ab6 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1ab6:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ab8:	0f b6       	in	r0, 0x3f	; 63
    1aba:	f8 94       	cli
    1abc:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1abe:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1ac0:	0f 90       	pop	r0
    1ac2:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1ac4:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ac6:	89 1b       	sub	r24, r25
    1ac8:	08 95       	ret

00001aca <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1aca:	fc 01       	movw	r30, r24
    1acc:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ace:	08 95       	ret

00001ad0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1ad0:	cf 93       	push	r28
    1ad2:	df 93       	push	r29
    1ad4:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	if( pxQueue->pcHead != NULL )
    1ad6:	88 81       	ld	r24, Y
    1ad8:	99 81       	ldd	r25, Y+1	; 0x01
    1ada:	00 97       	sbiw	r24, 0x00	; 0
    1adc:	11 f0       	breq	.+4      	; 0x1ae2 <vQueueDelete+0x12>
	{
		vPortFree( pxQueue->pcHead );
    1ade:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>
	}
	vPortFree( pxQueue );
    1ae2:	ce 01       	movw	r24, r28
    1ae4:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>
}
    1ae8:	df 91       	pop	r29
    1aea:	cf 91       	pop	r28
    1aec:	08 95       	ret

00001aee <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1aee:	fc 01       	movw	r30, r24
    1af0:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	91 11       	cpse	r25, r1
    1af6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1af8:	08 95       	ret

00001afa <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1afa:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    1afc:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b02:	29 13       	cpse	r18, r25
    1b04:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1b06:	08 95       	ret

00001b08 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1b08:	ef 92       	push	r14
    1b0a:	ff 92       	push	r15
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	ec 01       	movw	r28, r24
    1b16:	7b 01       	movw	r14, r22
    1b18:	8a 01       	movw	r16, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b1a:	f8 94       	cli
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b1c:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <prvIsQueueFull>
    1b20:	88 23       	and	r24, r24
    1b22:	79 f0       	breq	.+30     	; 0x1b42 <xQueueCRSend+0x3a>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b24:	01 15       	cp	r16, r1
    1b26:	11 05       	cpc	r17, r1
    1b28:	49 f0       	breq	.+18     	; 0x1b3c <xQueueCRSend+0x34>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1b2a:	be 01       	movw	r22, r28
    1b2c:	68 5f       	subi	r22, 0xF8	; 248
    1b2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b30:	c8 01       	movw	r24, r16
    1b32:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b36:	78 94       	sei
					return errQUEUE_BLOCKED;
    1b38:	8c ef       	ldi	r24, 0xFC	; 252
    1b3a:	1f c0       	rjmp	.+62     	; 0x1b7a <xQueueCRSend+0x72>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b3c:	78 94       	sei
					return errQUEUE_FULL;
    1b3e:	80 e0       	ldi	r24, 0x00	; 0
    1b40:	1c c0       	rjmp	.+56     	; 0x1b7a <xQueueCRSend+0x72>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1b42:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b44:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b46:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b4a:	98 17       	cp	r25, r24
    1b4c:	80 f4       	brcc	.+32     	; 0x1b6e <xQueueCRSend+0x66>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b4e:	ce 01       	movw	r24, r28
    1b50:	b7 01       	movw	r22, r14
    1b52:	40 e0       	ldi	r20, 0x00	; 0
    1b54:	0e 94 05 0a 	call	0x140a	; 0x140a <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b58:	89 89       	ldd	r24, Y+17	; 0x11
    1b5a:	88 23       	and	r24, r24
    1b5c:	51 f0       	breq	.+20     	; 0x1b72 <xQueueCRSend+0x6a>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b5e:	ce 01       	movw	r24, r28
    1b60:	41 96       	adiw	r24, 0x11	; 17
    1b62:	0e 94 65 04 	call	0x8ca	; 0x8ca <xCoRoutineRemoveFromEventList>
    1b66:	88 23       	and	r24, r24
    1b68:	31 f4       	brne	.+12     	; 0x1b76 <xQueueCRSend+0x6e>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1b6a:	81 e0       	ldi	r24, 0x01	; 1
    1b6c:	05 c0       	rjmp	.+10     	; 0x1b78 <xQueueCRSend+0x70>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1b6e:	80 e0       	ldi	r24, 0x00	; 0
    1b70:	03 c0       	rjmp	.+6      	; 0x1b78 <xQueueCRSend+0x70>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1b72:	81 e0       	ldi	r24, 0x01	; 1
    1b74:	01 c0       	rjmp	.+2      	; 0x1b78 <xQueueCRSend+0x70>
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1b76:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    1b78:	78 94       	sei

		return xReturn;
	}
    1b7a:	df 91       	pop	r29
    1b7c:	cf 91       	pop	r28
    1b7e:	1f 91       	pop	r17
    1b80:	0f 91       	pop	r16
    1b82:	ff 90       	pop	r15
    1b84:	ef 90       	pop	r14
    1b86:	08 95       	ret

00001b88 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1b88:	cf 93       	push	r28
    1b8a:	df 93       	push	r29
    1b8c:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b8e:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1b90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b92:	88 23       	and	r24, r24
    1b94:	79 f4       	brne	.+30     	; 0x1bb4 <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b96:	41 15       	cp	r20, r1
    1b98:	51 05       	cpc	r21, r1
    1b9a:	49 f0       	breq	.+18     	; 0x1bae <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1b9c:	be 01       	movw	r22, r28
    1b9e:	6f 5e       	subi	r22, 0xEF	; 239
    1ba0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba2:	ca 01       	movw	r24, r20
    1ba4:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1ba8:	78 94       	sei
					return errQUEUE_BLOCKED;
    1baa:	8c ef       	ldi	r24, 0xFC	; 252
    1bac:	35 c0       	rjmp	.+106    	; 0x1c18 <xQueueCRReceive+0x90>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1bae:	78 94       	sei
					return errQUEUE_FULL;
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	32 c0       	rjmp	.+100    	; 0x1c18 <xQueueCRReceive+0x90>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1bb4:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1bb6:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bb8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bba:	88 23       	and	r24, r24
    1bbc:	39 f1       	breq	.+78     	; 0x1c0c <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1bbe:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1bc0:	2e 81       	ldd	r18, Y+6	; 0x06
    1bc2:	3f 81       	ldd	r19, Y+7	; 0x07
    1bc4:	24 0f       	add	r18, r20
    1bc6:	31 1d       	adc	r19, r1
    1bc8:	3f 83       	std	Y+7, r19	; 0x07
    1bca:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1bcc:	ea 81       	ldd	r30, Y+2	; 0x02
    1bce:	fb 81       	ldd	r31, Y+3	; 0x03
    1bd0:	2e 17       	cp	r18, r30
    1bd2:	3f 07       	cpc	r19, r31
    1bd4:	20 f0       	brcs	.+8      	; 0x1bde <xQueueCRReceive+0x56>
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1bd6:	88 81       	ld	r24, Y
    1bd8:	99 81       	ldd	r25, Y+1	; 0x01
    1bda:	9f 83       	std	Y+7, r25	; 0x07
    1bdc:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1bde:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1be0:	81 50       	subi	r24, 0x01	; 1
    1be2:	8a 8f       	std	Y+26, r24	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1be4:	3e 81       	ldd	r19, Y+6	; 0x06
    1be6:	2f 81       	ldd	r18, Y+7	; 0x07
    1be8:	86 2f       	mov	r24, r22
    1bea:	97 2f       	mov	r25, r23
    1bec:	63 2f       	mov	r22, r19
    1bee:	72 2f       	mov	r23, r18
    1bf0:	50 e0       	ldi	r21, 0x00	; 0
    1bf2:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bf6:	88 85       	ldd	r24, Y+8	; 0x08
    1bf8:	88 23       	and	r24, r24
    1bfa:	51 f0       	breq	.+20     	; 0x1c10 <xQueueCRReceive+0x88>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bfc:	ce 01       	movw	r24, r28
    1bfe:	08 96       	adiw	r24, 0x08	; 8
    1c00:	0e 94 65 04 	call	0x8ca	; 0x8ca <xCoRoutineRemoveFromEventList>
    1c04:	88 23       	and	r24, r24
    1c06:	31 f4       	brne	.+12     	; 0x1c14 <xQueueCRReceive+0x8c>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1c08:	81 e0       	ldi	r24, 0x01	; 1
    1c0a:	05 c0       	rjmp	.+10     	; 0x1c16 <xQueueCRReceive+0x8e>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
    1c0e:	03 c0       	rjmp	.+6      	; 0x1c16 <xQueueCRReceive+0x8e>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	01 c0       	rjmp	.+2      	; 0x1c16 <xQueueCRReceive+0x8e>
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
					{
						xReturn = errQUEUE_YIELD;
    1c14:	8b ef       	ldi	r24, 0xFB	; 251
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    1c16:	78 94       	sei

		return xReturn;
	}
    1c18:	df 91       	pop	r29
    1c1a:	cf 91       	pop	r28
    1c1c:	08 95       	ret

00001c1e <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1c1e:	1f 93       	push	r17
    1c20:	cf 93       	push	r28
    1c22:	df 93       	push	r29
    1c24:	ec 01       	movw	r28, r24
    1c26:	14 2f       	mov	r17, r20
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c28:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c2a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c2c:	98 17       	cp	r25, r24
    1c2e:	88 f4       	brcc	.+34     	; 0x1c52 <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1c30:	ce 01       	movw	r24, r28
    1c32:	40 e0       	ldi	r20, 0x00	; 0
    1c34:	0e 94 05 0a 	call	0x140a	; 0x140a <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1c38:	11 23       	and	r17, r17
    1c3a:	59 f4       	brne	.+22     	; 0x1c52 <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c3c:	89 89       	ldd	r24, Y+17	; 0x11
    1c3e:	88 23       	and	r24, r24
    1c40:	41 f0       	breq	.+16     	; 0x1c52 <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c42:	ce 01       	movw	r24, r28
    1c44:	41 96       	adiw	r24, 0x11	; 17
    1c46:	0e 94 65 04 	call	0x8ca	; 0x8ca <xCoRoutineRemoveFromEventList>
#endif /* configUSE_CO_ROUTINES */
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
    1c4a:	11 e0       	ldi	r17, 0x01	; 1
    1c4c:	88 23       	and	r24, r24
    1c4e:	09 f4       	brne	.+2      	; 0x1c52 <xQueueCRSendFromISR+0x34>
    1c50:	10 e0       	ldi	r17, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1c52:	81 2f       	mov	r24, r17
    1c54:	df 91       	pop	r29
    1c56:	cf 91       	pop	r28
    1c58:	1f 91       	pop	r17
    1c5a:	08 95       	ret

00001c5c <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1c5c:	0f 93       	push	r16
    1c5e:	1f 93       	push	r17
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	ec 01       	movw	r28, r24
    1c66:	86 2f       	mov	r24, r22
    1c68:	97 2f       	mov	r25, r23
    1c6a:	8a 01       	movw	r16, r20
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c6c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1c6e:	22 23       	and	r18, r18
    1c70:	49 f1       	breq	.+82     	; 0x1cc4 <xQueueCRReceiveFromISR+0x68>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1c72:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1c74:	2e 81       	ldd	r18, Y+6	; 0x06
    1c76:	3f 81       	ldd	r19, Y+7	; 0x07
    1c78:	24 0f       	add	r18, r20
    1c7a:	31 1d       	adc	r19, r1
    1c7c:	3f 83       	std	Y+7, r19	; 0x07
    1c7e:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
    1c80:	ea 81       	ldd	r30, Y+2	; 0x02
    1c82:	fb 81       	ldd	r31, Y+3	; 0x03
    1c84:	2e 17       	cp	r18, r30
    1c86:	3f 07       	cpc	r19, r31
    1c88:	20 f0       	brcs	.+8      	; 0x1c92 <xQueueCRReceiveFromISR+0x36>
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1c8a:	28 81       	ld	r18, Y
    1c8c:	39 81       	ldd	r19, Y+1	; 0x01
    1c8e:	3f 83       	std	Y+7, r19	; 0x07
    1c90:	2e 83       	std	Y+6, r18	; 0x06
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1c92:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1c94:	21 50       	subi	r18, 0x01	; 1
    1c96:	2a 8f       	std	Y+26, r18	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c98:	6e 81       	ldd	r22, Y+6	; 0x06
    1c9a:	7f 81       	ldd	r23, Y+7	; 0x07
    1c9c:	50 e0       	ldi	r21, 0x00	; 0
    1c9e:	0e 94 e2 19 	call	0x33c4	; 0x33c4 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1ca2:	f8 01       	movw	r30, r16
    1ca4:	80 81       	ld	r24, Z
    1ca6:	88 23       	and	r24, r24
    1ca8:	79 f4       	brne	.+30     	; 0x1cc8 <xQueueCRReceiveFromISR+0x6c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1caa:	88 85       	ldd	r24, Y+8	; 0x08
    1cac:	88 23       	and	r24, r24
    1cae:	71 f0       	breq	.+28     	; 0x1ccc <xQueueCRReceiveFromISR+0x70>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	08 96       	adiw	r24, 0x08	; 8
    1cb4:	0e 94 65 04 	call	0x8ca	; 0x8ca <xCoRoutineRemoveFromEventList>
    1cb8:	88 23       	and	r24, r24
    1cba:	51 f0       	breq	.+20     	; 0x1cd0 <xQueueCRReceiveFromISR+0x74>
					{
						*pxCoRoutineWoken = pdTRUE;
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	f8 01       	movw	r30, r16
    1cc0:	80 83       	st	Z, r24
    1cc2:	07 c0       	rjmp	.+14     	; 0x1cd2 <xQueueCRReceiveFromISR+0x76>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	05 c0       	rjmp	.+10     	; 0x1cd2 <xQueueCRReceiveFromISR+0x76>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	03 c0       	rjmp	.+6      	; 0x1cd2 <xQueueCRReceiveFromISR+0x76>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	01 c0       	rjmp	.+2      	; 0x1cd2 <xQueueCRReceiveFromISR+0x76>
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1cd2:	df 91       	pop	r29
    1cd4:	cf 91       	pop	r28
    1cd6:	1f 91       	pop	r17
    1cd8:	0f 91       	pop	r16
    1cda:	08 95       	ret

00001cdc <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1cdc:	e0 91 c9 06 	lds	r30, 0x06C9
    1ce0:	f0 91 ca 06 	lds	r31, 0x06CA
    1ce4:	80 81       	ld	r24, Z
    1ce6:	88 23       	and	r24, r24
    1ce8:	39 f4       	brne	.+14     	; 0x1cf8 <prvResetNextTaskUnblockTime+0x1c>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1cea:	8f ef       	ldi	r24, 0xFF	; 255
    1cec:	9f ef       	ldi	r25, 0xFF	; 255
    1cee:	90 93 7e 00 	sts	0x007E, r25
    1cf2:	80 93 7d 00 	sts	0x007D, r24
    1cf6:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1cf8:	e0 91 c9 06 	lds	r30, 0x06C9
    1cfc:	f0 91 ca 06 	lds	r31, 0x06CA
    1d00:	05 80       	ldd	r0, Z+5	; 0x05
    1d02:	f6 81       	ldd	r31, Z+6	; 0x06
    1d04:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    1d06:	06 80       	ldd	r0, Z+6	; 0x06
    1d08:	f7 81       	ldd	r31, Z+7	; 0x07
    1d0a:	e0 2d       	mov	r30, r0
    1d0c:	82 81       	ldd	r24, Z+2	; 0x02
    1d0e:	93 81       	ldd	r25, Z+3	; 0x03
    1d10:	90 93 7e 00 	sts	0x007E, r25
    1d14:	80 93 7d 00 	sts	0x007D, r24
    1d18:	08 95       	ret

00001d1a <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1d20:	e0 91 bb 06 	lds	r30, 0x06BB
    1d24:	f0 91 bc 06 	lds	r31, 0x06BC
    1d28:	93 83       	std	Z+3, r25	; 0x03
    1d2a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1d2c:	80 91 c3 06 	lds	r24, 0x06C3
    1d30:	90 91 c4 06 	lds	r25, 0x06C4
    1d34:	c8 17       	cp	r28, r24
    1d36:	d9 07       	cpc	r29, r25
    1d38:	68 f4       	brcc	.+26     	; 0x1d54 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d3a:	80 91 c7 06 	lds	r24, 0x06C7
    1d3e:	90 91 c8 06 	lds	r25, 0x06C8
    1d42:	60 91 bb 06 	lds	r22, 0x06BB
    1d46:	70 91 bc 06 	lds	r23, 0x06BC
    1d4a:	6e 5f       	subi	r22, 0xFE	; 254
    1d4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4e:	0e 94 42 07 	call	0xe84	; 0xe84 <vListInsert>
    1d52:	17 c0       	rjmp	.+46     	; 0x1d82 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1d54:	80 91 c9 06 	lds	r24, 0x06C9
    1d58:	90 91 ca 06 	lds	r25, 0x06CA
    1d5c:	60 91 bb 06 	lds	r22, 0x06BB
    1d60:	70 91 bc 06 	lds	r23, 0x06BC
    1d64:	6e 5f       	subi	r22, 0xFE	; 254
    1d66:	7f 4f       	sbci	r23, 0xFF	; 255
    1d68:	0e 94 42 07 	call	0xe84	; 0xe84 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1d6c:	80 91 7d 00 	lds	r24, 0x007D
    1d70:	90 91 7e 00 	lds	r25, 0x007E
    1d74:	c8 17       	cp	r28, r24
    1d76:	d9 07       	cpc	r29, r25
    1d78:	20 f4       	brcc	.+8      	; 0x1d82 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1d7a:	d0 93 7e 00 	sts	0x007E, r29
    1d7e:	c0 93 7d 00 	sts	0x007D, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1d82:	df 91       	pop	r29
    1d84:	cf 91       	pop	r28
    1d86:	08 95       	ret

00001d88 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1d88:	2f 92       	push	r2
    1d8a:	3f 92       	push	r3
    1d8c:	4f 92       	push	r4
    1d8e:	5f 92       	push	r5
    1d90:	6f 92       	push	r6
    1d92:	7f 92       	push	r7
    1d94:	8f 92       	push	r8
    1d96:	9f 92       	push	r9
    1d98:	bf 92       	push	r11
    1d9a:	cf 92       	push	r12
    1d9c:	df 92       	push	r13
    1d9e:	ef 92       	push	r14
    1da0:	ff 92       	push	r15
    1da2:	0f 93       	push	r16
    1da4:	1f 93       	push	r17
    1da6:	cf 93       	push	r28
    1da8:	df 93       	push	r29
    1daa:	1c 01       	movw	r2, r24
    1dac:	4b 01       	movw	r8, r22
    1dae:	ea 01       	movw	r28, r20
    1db0:	29 01       	movw	r4, r18
    1db2:	b0 2e       	mov	r11, r16
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    1db4:	8f e2       	ldi	r24, 0x2F	; 47
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
    1dbc:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1dbe:	00 97       	sbiw	r24, 0x00	; 0
    1dc0:	09 f4       	brne	.+2      	; 0x1dc4 <xTaskGenericCreate+0x3c>
    1dc2:	d0 c0       	rjmp	.+416    	; 0x1f64 <xTaskGenericCreate+0x1dc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1dc4:	c1 14       	cp	r12, r1
    1dc6:	d1 04       	cpc	r13, r1
    1dc8:	09 f0       	breq	.+2      	; 0x1dcc <xTaskGenericCreate+0x44>
    1dca:	e3 c0       	rjmp	.+454    	; 0x1f92 <xTaskGenericCreate+0x20a>
    1dcc:	ce 01       	movw	r24, r28
    1dce:	0e 94 35 06 	call	0xc6a	; 0xc6a <pvPortMalloc>
    1dd2:	f8 01       	movw	r30, r16
    1dd4:	90 8f       	std	Z+24, r25	; 0x18
    1dd6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1dd8:	00 97       	sbiw	r24, 0x00	; 0
    1dda:	09 f0       	breq	.+2      	; 0x1dde <xTaskGenericCreate+0x56>
    1ddc:	dd c0       	rjmp	.+442    	; 0x1f98 <xTaskGenericCreate+0x210>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1dde:	c8 01       	movw	r24, r16
    1de0:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1de4:	8f ef       	ldi	r24, 0xFF	; 255
    1de6:	c3 c0       	rjmp	.+390    	; 0x1f6e <xTaskGenericCreate+0x1e6>
 */
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    1de8:	fd 01       	movw	r30, r26
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1dea:	9d 91       	ld	r25, X+
    1dec:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1dee:	90 81       	ld	r25, Z
    1df0:	99 23       	and	r25, r25
    1df2:	11 f0       	breq	.+4      	; 0x1df8 <xTaskGenericCreate+0x70>
    1df4:	81 50       	subi	r24, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1df6:	c1 f7       	brne	.-16     	; 0x1de8 <xTaskGenericCreate+0x60>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1df8:	f8 01       	movw	r30, r16
    1dfa:	14 a6       	lds	r17, 0xb4
    1dfc:	cb 2d       	mov	r28, r11
    1dfe:	f6 e0       	ldi	r31, 0x06	; 6
    1e00:	fb 15       	cp	r31, r11
    1e02:	08 f4       	brcc	.+2      	; 0x1e06 <xTaskGenericCreate+0x7e>
    1e04:	c6 e0       	ldi	r28, 0x06	; 6
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    1e06:	f8 01       	movw	r30, r16
    1e08:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    1e0a:	c5 a7       	lds	r28, 0x75
		pxTCB->uxMutexesHeld = 0;
    1e0c:	16 a6       	lds	r17, 0xb6
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1e0e:	cc 24       	eor	r12, r12
    1e10:	dd 24       	eor	r13, r13
    1e12:	68 94       	set
    1e14:	c1 f8       	bld	r12, 1
    1e16:	c0 0e       	add	r12, r16
    1e18:	d1 1e       	adc	r13, r17
    1e1a:	c6 01       	movw	r24, r12
    1e1c:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1e20:	c8 01       	movw	r24, r16
    1e22:	0c 96       	adiw	r24, 0x0c	; 12
    1e24:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1e28:	f8 01       	movw	r30, r16
    1e2a:	11 87       	std	Z+9, r17	; 0x09
    1e2c:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e2e:	87 e0       	ldi	r24, 0x07	; 7
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	8c 1b       	sub	r24, r28
    1e34:	91 09       	sbc	r25, r1
    1e36:	95 87       	std	Z+13, r25	; 0x0d
    1e38:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1e3a:	13 8b       	std	Z+19, r17	; 0x13
    1e3c:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e3e:	c3 01       	movw	r24, r6
    1e40:	b1 01       	movw	r22, r2
    1e42:	a2 01       	movw	r20, r4
    1e44:	0e 94 5d 08 	call	0x10ba	; 0x10ba <pxPortInitialiseStack>
    1e48:	f8 01       	movw	r30, r16
    1e4a:	91 83       	std	Z+1, r25	; 0x01
    1e4c:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1e4e:	e1 14       	cp	r14, r1
    1e50:	f1 04       	cpc	r15, r1
    1e52:	19 f0       	breq	.+6      	; 0x1e5a <xTaskGenericCreate+0xd2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1e54:	f7 01       	movw	r30, r14
    1e56:	11 83       	std	Z+1, r17	; 0x01
    1e58:	00 83       	st	Z, r16
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1e5a:	0f b6       	in	r0, 0x3f	; 63
    1e5c:	f8 94       	cli
    1e5e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1e60:	80 91 c5 06 	lds	r24, 0x06C5
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	80 93 c5 06 	sts	0x06C5, r24
			if( pxCurrentTCB == NULL )
    1e6a:	80 91 bb 06 	lds	r24, 0x06BB
    1e6e:	90 91 bc 06 	lds	r25, 0x06BC
    1e72:	00 97       	sbiw	r24, 0x00	; 0
    1e74:	d9 f5       	brne	.+118    	; 0x1eec <xTaskGenericCreate+0x164>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e76:	10 93 bc 06 	sts	0x06BC, r17
    1e7a:	00 93 bb 06 	sts	0x06BB, r16

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1e7e:	80 91 c5 06 	lds	r24, 0x06C5
    1e82:	81 30       	cpi	r24, 0x01	; 1
    1e84:	09 f0       	breq	.+2      	; 0x1e88 <xTaskGenericCreate+0x100>
    1e86:	41 c0       	rjmp	.+130    	; 0x1f0a <xTaskGenericCreate+0x182>
    1e88:	c0 e0       	ldi	r28, 0x00	; 0
    1e8a:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1e8c:	ce 01       	movw	r24, r28
    1e8e:	88 0f       	add	r24, r24
    1e90:	99 1f       	adc	r25, r25
    1e92:	88 0f       	add	r24, r24
    1e94:	99 1f       	adc	r25, r25
    1e96:	88 0f       	add	r24, r24
    1e98:	99 1f       	adc	r25, r25
    1e9a:	8c 0f       	add	r24, r28
    1e9c:	9d 1f       	adc	r25, r29
    1e9e:	84 53       	subi	r24, 0x34	; 52
    1ea0:	99 4f       	sbci	r25, 0xF9	; 249
    1ea2:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
    1ea6:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1ea8:	c7 30       	cpi	r28, 0x07	; 7
    1eaa:	d1 05       	cpc	r29, r1
    1eac:	79 f7       	brne	.-34     	; 0x1e8c <xTaskGenericCreate+0x104>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1eae:	cb e0       	ldi	r28, 0x0B	; 11
    1eb0:	d7 e0       	ldi	r29, 0x07	; 7
    1eb2:	ce 01       	movw	r24, r28
    1eb4:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    1eb8:	0f 2e       	mov	r0, r31
    1eba:	f4 e1       	ldi	r31, 0x14	; 20
    1ebc:	ef 2e       	mov	r14, r31
    1ebe:	f7 e0       	ldi	r31, 0x07	; 7
    1ec0:	ff 2e       	mov	r15, r31
    1ec2:	f0 2d       	mov	r31, r0
    1ec4:	c7 01       	movw	r24, r14
    1ec6:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    1eca:	8d e1       	ldi	r24, 0x1D	; 29
    1ecc:	97 e0       	ldi	r25, 0x07	; 7
    1ece:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1ed2:	86 e2       	ldi	r24, 0x26	; 38
    1ed4:	97 e0       	ldi	r25, 0x07	; 7
    1ed6:	0e 94 11 07 	call	0xe22	; 0xe22 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1eda:	d0 93 ca 06 	sts	0x06CA, r29
    1ede:	c0 93 c9 06 	sts	0x06C9, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1ee2:	f0 92 c8 06 	sts	0x06C8, r15
    1ee6:	e0 92 c7 06 	sts	0x06C7, r14
    1eea:	0f c0       	rjmp	.+30     	; 0x1f0a <xTaskGenericCreate+0x182>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1eec:	80 91 c1 06 	lds	r24, 0x06C1
    1ef0:	88 23       	and	r24, r24
    1ef2:	59 f4       	brne	.+22     	; 0x1f0a <xTaskGenericCreate+0x182>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1ef4:	e0 91 bb 06 	lds	r30, 0x06BB
    1ef8:	f0 91 bc 06 	lds	r31, 0x06BC
    1efc:	86 89       	ldd	r24, Z+22	; 0x16
    1efe:	b8 16       	cp	r11, r24
    1f00:	20 f0       	brcs	.+8      	; 0x1f0a <xTaskGenericCreate+0x182>
					{
						pxCurrentTCB = pxNewTCB;
    1f02:	10 93 bc 06 	sts	0x06BC, r17
    1f06:	00 93 bb 06 	sts	0x06BB, r16
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1f0a:	80 91 cb 06 	lds	r24, 0x06CB
    1f0e:	8f 5f       	subi	r24, 0xFF	; 255
    1f10:	80 93 cb 06 	sts	0x06CB, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1f14:	f8 01       	movw	r30, r16
    1f16:	86 89       	ldd	r24, Z+22	; 0x16
    1f18:	90 91 c2 06 	lds	r25, 0x06C2
    1f1c:	98 17       	cp	r25, r24
    1f1e:	10 f4       	brcc	.+4      	; 0x1f24 <xTaskGenericCreate+0x19c>
    1f20:	80 93 c2 06 	sts	0x06C2, r24
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	9c 01       	movw	r18, r24
    1f28:	22 0f       	add	r18, r18
    1f2a:	33 1f       	adc	r19, r19
    1f2c:	22 0f       	add	r18, r18
    1f2e:	33 1f       	adc	r19, r19
    1f30:	22 0f       	add	r18, r18
    1f32:	33 1f       	adc	r19, r19
    1f34:	82 0f       	add	r24, r18
    1f36:	93 1f       	adc	r25, r19
    1f38:	84 53       	subi	r24, 0x34	; 52
    1f3a:	99 4f       	sbci	r25, 0xF9	; 249
    1f3c:	b6 01       	movw	r22, r12
    1f3e:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1f42:	0f 90       	pop	r0
    1f44:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1f46:	80 91 c1 06 	lds	r24, 0x06C1
    1f4a:	88 23       	and	r24, r24
    1f4c:	69 f0       	breq	.+26     	; 0x1f68 <xTaskGenericCreate+0x1e0>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f4e:	e0 91 bb 06 	lds	r30, 0x06BB
    1f52:	f0 91 bc 06 	lds	r31, 0x06BC
    1f56:	86 89       	ldd	r24, Z+22	; 0x16
    1f58:	8b 15       	cp	r24, r11
    1f5a:	40 f4       	brcc	.+16     	; 0x1f6c <xTaskGenericCreate+0x1e4>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1f5c:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	05 c0       	rjmp	.+10     	; 0x1f6e <xTaskGenericCreate+0x1e6>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f64:	8f ef       	ldi	r24, 0xFF	; 255
    1f66:	03 c0       	rjmp	.+6      	; 0x1f6e <xTaskGenericCreate+0x1e6>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
    1f68:	81 e0       	ldi	r24, 0x01	; 1
    1f6a:	01 c0       	rjmp	.+2      	; 0x1f6e <xTaskGenericCreate+0x1e6>
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    1f6e:	df 91       	pop	r29
    1f70:	cf 91       	pop	r28
    1f72:	1f 91       	pop	r17
    1f74:	0f 91       	pop	r16
    1f76:	ff 90       	pop	r15
    1f78:	ef 90       	pop	r14
    1f7a:	df 90       	pop	r13
    1f7c:	cf 90       	pop	r12
    1f7e:	bf 90       	pop	r11
    1f80:	9f 90       	pop	r9
    1f82:	8f 90       	pop	r8
    1f84:	7f 90       	pop	r7
    1f86:	6f 90       	pop	r6
    1f88:	5f 90       	pop	r5
    1f8a:	4f 90       	pop	r4
    1f8c:	3f 90       	pop	r3
    1f8e:	2f 90       	pop	r2
    1f90:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f92:	fc 01       	movw	r30, r24
    1f94:	d0 8e       	std	Z+24, r13	; 0x18
    1f96:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1f98:	9e 01       	movw	r18, r28
    1f9a:	21 50       	subi	r18, 0x01	; 1
    1f9c:	30 40       	sbci	r19, 0x00	; 0
    1f9e:	f8 01       	movw	r30, r16
    1fa0:	87 89       	ldd	r24, Z+23	; 0x17
    1fa2:	90 8d       	ldd	r25, Z+24	; 0x18
    1fa4:	3c 01       	movw	r6, r24
    1fa6:	62 0e       	add	r6, r18
    1fa8:	73 1e       	adc	r7, r19
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    1faa:	f4 01       	movw	r30, r8
    1fac:	80 81       	ld	r24, Z
    1fae:	f8 01       	movw	r30, r16
    1fb0:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1fb2:	f4 01       	movw	r30, r8
    1fb4:	80 81       	ld	r24, Z
    1fb6:	88 23       	and	r24, r24
    1fb8:	09 f4       	brne	.+2      	; 0x1fbc <xTaskGenericCreate+0x234>
    1fba:	1e cf       	rjmp	.-452    	; 0x1df8 <xTaskGenericCreate+0x70>
 */
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    1fbc:	e8 01       	movw	r28, r16
    1fbe:	6a 96       	adiw	r28, 0x1a	; 26
    1fc0:	d4 01       	movw	r26, r8
    1fc2:	11 96       	adiw	r26, 0x01	; 1
    1fc4:	83 e1       	ldi	r24, 0x13	; 19
    1fc6:	10 cf       	rjmp	.-480    	; 0x1de8 <xTaskGenericCreate+0x60>

00001fc8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1fc8:	0f 93       	push	r16
    1fca:	1f 93       	push	r17
    1fcc:	cf 93       	push	r28
    1fce:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1fd0:	0f b6       	in	r0, 0x3f	; 63
    1fd2:	f8 94       	cli
    1fd4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1fd6:	00 97       	sbiw	r24, 0x00	; 0
    1fd8:	29 f4       	brne	.+10     	; 0x1fe4 <vTaskDelete+0x1c>
    1fda:	00 91 bb 06 	lds	r16, 0x06BB
    1fde:	10 91 bc 06 	lds	r17, 0x06BC
    1fe2:	01 c0       	rjmp	.+2      	; 0x1fe6 <vTaskDelete+0x1e>
    1fe4:	8c 01       	movw	r16, r24

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1fe6:	e8 01       	movw	r28, r16
    1fe8:	22 96       	adiw	r28, 0x02	; 2
    1fea:	ce 01       	movw	r24, r28
    1fec:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1ff0:	f8 01       	movw	r30, r16
    1ff2:	84 89       	ldd	r24, Z+20	; 0x14
    1ff4:	95 89       	ldd	r25, Z+21	; 0x15
    1ff6:	00 97       	sbiw	r24, 0x00	; 0
    1ff8:	21 f0       	breq	.+8      	; 0x2002 <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1ffa:	c8 01       	movw	r24, r16
    1ffc:	0c 96       	adiw	r24, 0x0c	; 12
    1ffe:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2002:	86 e2       	ldi	r24, 0x26	; 38
    2004:	97 e0       	ldi	r25, 0x07	; 7
    2006:	be 01       	movw	r22, r28
    2008:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    200c:	80 91 c6 06 	lds	r24, 0x06C6
    2010:	8f 5f       	subi	r24, 0xFF	; 255
    2012:	80 93 c6 06 	sts	0x06C6, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2016:	80 91 cb 06 	lds	r24, 0x06CB
    201a:	8f 5f       	subi	r24, 0xFF	; 255
    201c:	80 93 cb 06 	sts	0x06CB, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2020:	0f 90       	pop	r0
    2022:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2024:	80 91 c1 06 	lds	r24, 0x06C1
    2028:	88 23       	and	r24, r24
    202a:	89 f0       	breq	.+34     	; 0x204e <vTaskDelete+0x86>
		{
			if( pxTCB == pxCurrentTCB )
    202c:	80 91 bb 06 	lds	r24, 0x06BB
    2030:	90 91 bc 06 	lds	r25, 0x06BC
    2034:	08 17       	cp	r16, r24
    2036:	19 07       	cpc	r17, r25
    2038:	19 f4       	brne	.+6      	; 0x2040 <vTaskDelete+0x78>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    203a:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    203e:	07 c0       	rjmp	.+14     	; 0x204e <vTaskDelete+0x86>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    2040:	0f b6       	in	r0, 0x3f	; 63
    2042:	f8 94       	cli
    2044:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    2046:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    204e:	df 91       	pop	r29
    2050:	cf 91       	pop	r28
    2052:	1f 91       	pop	r17
    2054:	0f 91       	pop	r16
    2056:	08 95       	ret

00002058 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    2058:	0f b6       	in	r0, 0x3f	; 63
    205a:	f8 94       	cli
    205c:	0f 92       	push	r0
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
    205e:	00 97       	sbiw	r24, 0x00	; 0
    2060:	29 f4       	brne	.+10     	; 0x206c <uxTaskPriorityGet+0x14>
    2062:	e0 91 bb 06 	lds	r30, 0x06BB
    2066:	f0 91 bc 06 	lds	r31, 0x06BC
    206a:	01 c0       	rjmp	.+2      	; 0x206e <uxTaskPriorityGet+0x16>
    206c:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    206e:	0f 90       	pop	r0
    2070:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    2072:	86 89       	ldd	r24, Z+22	; 0x16
    2074:	08 95       	ret

00002076 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    2076:	ef 92       	push	r14
    2078:	ff 92       	push	r15
    207a:	1f 93       	push	r17
    207c:	cf 93       	push	r28
    207e:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    2080:	67 30       	cpi	r22, 0x07	; 7
    2082:	08 f0       	brcs	.+2      	; 0x2086 <vTaskPrioritySet+0x10>
    2084:	66 e0       	ldi	r22, 0x06	; 6
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    2086:	0f b6       	in	r0, 0x3f	; 63
    2088:	f8 94       	cli
    208a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    208c:	00 97       	sbiw	r24, 0x00	; 0
    208e:	29 f4       	brne	.+10     	; 0x209a <vTaskPrioritySet+0x24>
    2090:	c0 91 bb 06 	lds	r28, 0x06BB
    2094:	d0 91 bc 06 	lds	r29, 0x06BC
    2098:	01 c0       	rjmp	.+2      	; 0x209c <vTaskPrioritySet+0x26>
    209a:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    209c:	2d a5       	lds	r18, 0x6d
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    209e:	26 17       	cp	r18, r22
    20a0:	09 f4       	brne	.+2      	; 0x20a4 <vTaskPrioritySet+0x2e>
    20a2:	61 c0       	rjmp	.+194    	; 0x2166 <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    20a4:	26 17       	cp	r18, r22
    20a6:	88 f4       	brcc	.+34     	; 0x20ca <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    20a8:	80 91 bb 06 	lds	r24, 0x06BB
    20ac:	90 91 bc 06 	lds	r25, 0x06BC
    20b0:	c8 17       	cp	r28, r24
    20b2:	d9 07       	cpc	r29, r25
    20b4:	a1 f0       	breq	.+40     	; 0x20de <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    20b6:	e0 91 bb 06 	lds	r30, 0x06BB
    20ba:	f0 91 bc 06 	lds	r31, 0x06BC
						{
							xYieldRequired = pdTRUE;
    20be:	11 e0       	ldi	r17, 0x01	; 1
    20c0:	86 89       	ldd	r24, Z+22	; 0x16
    20c2:	68 17       	cp	r22, r24
    20c4:	68 f4       	brcc	.+26     	; 0x20e0 <vTaskPrioritySet+0x6a>
    20c6:	10 e0       	ldi	r17, 0x00	; 0
    20c8:	0b c0       	rjmp	.+22     	; 0x20e0 <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    20ca:	80 91 bb 06 	lds	r24, 0x06BB
    20ce:	90 91 bc 06 	lds	r25, 0x06BC
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    20d2:	11 e0       	ldi	r17, 0x01	; 1
    20d4:	c8 17       	cp	r28, r24
    20d6:	d9 07       	cpc	r29, r25
    20d8:	19 f0       	breq	.+6      	; 0x20e0 <vTaskPrioritySet+0x6a>
    20da:	10 e0       	ldi	r17, 0x00	; 0
    20dc:	01 c0       	rjmp	.+2      	; 0x20e0 <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    20de:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    20e0:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    20e2:	28 17       	cp	r18, r24
    20e4:	09 f4       	brne	.+2      	; 0x20e8 <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    20e6:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    20e8:	6d a7       	lds	r22, 0x7d
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    20ea:	2c 85       	ldd	r18, Y+12	; 0x0c
    20ec:	3d 85       	ldd	r19, Y+13	; 0x0d
    20ee:	33 23       	and	r19, r19
    20f0:	34 f0       	brlt	.+12     	; 0x20fe <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20f2:	27 e0       	ldi	r18, 0x07	; 7
    20f4:	30 e0       	ldi	r19, 0x00	; 0
    20f6:	26 1b       	sub	r18, r22
    20f8:	31 09       	sbc	r19, r1
    20fa:	3d 87       	std	Y+13, r19	; 0x0d
    20fc:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    20fe:	90 e0       	ldi	r25, 0x00	; 0
    2100:	9c 01       	movw	r18, r24
    2102:	22 0f       	add	r18, r18
    2104:	33 1f       	adc	r19, r19
    2106:	22 0f       	add	r18, r18
    2108:	33 1f       	adc	r19, r19
    210a:	22 0f       	add	r18, r18
    210c:	33 1f       	adc	r19, r19
    210e:	82 0f       	add	r24, r18
    2110:	93 1f       	adc	r25, r19
    2112:	84 53       	subi	r24, 0x34	; 52
    2114:	99 4f       	sbci	r25, 0xF9	; 249
    2116:	2a 85       	ldd	r18, Y+10	; 0x0a
    2118:	3b 85       	ldd	r19, Y+11	; 0x0b
    211a:	28 17       	cp	r18, r24
    211c:	39 07       	cpc	r19, r25
    211e:	f9 f4       	brne	.+62     	; 0x215e <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2120:	ee 24       	eor	r14, r14
    2122:	ff 24       	eor	r15, r15
    2124:	68 94       	set
    2126:	e1 f8       	bld	r14, 1
    2128:	ec 0e       	add	r14, r28
    212a:	fd 1e       	adc	r15, r29
    212c:	c7 01       	movw	r24, r14
    212e:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    2132:	8e 89       	ldd	r24, Y+22	; 0x16
    2134:	90 91 c2 06 	lds	r25, 0x06C2
    2138:	98 17       	cp	r25, r24
    213a:	10 f4       	brcc	.+4      	; 0x2140 <vTaskPrioritySet+0xca>
    213c:	80 93 c2 06 	sts	0x06C2, r24
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	9c 01       	movw	r18, r24
    2144:	22 0f       	add	r18, r18
    2146:	33 1f       	adc	r19, r19
    2148:	22 0f       	add	r18, r18
    214a:	33 1f       	adc	r19, r19
    214c:	22 0f       	add	r18, r18
    214e:	33 1f       	adc	r19, r19
    2150:	82 0f       	add	r24, r18
    2152:	93 1f       	adc	r25, r19
    2154:	84 53       	subi	r24, 0x34	; 52
    2156:	99 4f       	sbci	r25, 0xF9	; 249
    2158:	b7 01       	movw	r22, r14
    215a:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    215e:	11 30       	cpi	r17, 0x01	; 1
    2160:	11 f4       	brne	.+4      	; 0x2166 <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    2162:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    2166:	0f 90       	pop	r0
    2168:	0f be       	out	0x3f, r0	; 63
	}
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	1f 91       	pop	r17
    2170:	ff 90       	pop	r15
    2172:	ef 90       	pop	r14
    2174:	08 95       	ret

00002176 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2176:	af 92       	push	r10
    2178:	bf 92       	push	r11
    217a:	cf 92       	push	r12
    217c:	df 92       	push	r13
    217e:	ef 92       	push	r14
    2180:	ff 92       	push	r15
    2182:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    2184:	87 e4       	ldi	r24, 0x47	; 71
    2186:	92 e1       	ldi	r25, 0x12	; 18
    2188:	68 e7       	ldi	r22, 0x78	; 120
    218a:	70 e0       	ldi	r23, 0x00	; 0
    218c:	45 e5       	ldi	r20, 0x55	; 85
    218e:	50 e0       	ldi	r21, 0x00	; 0
    2190:	20 e0       	ldi	r18, 0x00	; 0
    2192:	30 e0       	ldi	r19, 0x00	; 0
    2194:	00 e0       	ldi	r16, 0x00	; 0
    2196:	ee 24       	eor	r14, r14
    2198:	ff 24       	eor	r15, r15
    219a:	cc 24       	eor	r12, r12
    219c:	dd 24       	eor	r13, r13
    219e:	aa 24       	eor	r10, r10
    21a0:	bb 24       	eor	r11, r11
    21a2:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    21a6:	81 30       	cpi	r24, 0x01	; 1
    21a8:	49 f4       	brne	.+18     	; 0x21bc <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    21aa:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    21ac:	80 93 c1 06 	sts	0x06C1, r24
		xTickCount = ( TickType_t ) 0U;
    21b0:	10 92 c4 06 	sts	0x06C4, r1
    21b4:	10 92 c3 06 	sts	0x06C3, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    21b8:	0e 94 ed 08 	call	0x11da	; 0x11da <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    21bc:	0f 91       	pop	r16
    21be:	ff 90       	pop	r15
    21c0:	ef 90       	pop	r14
    21c2:	df 90       	pop	r13
    21c4:	cf 90       	pop	r12
    21c6:	bf 90       	pop	r11
    21c8:	af 90       	pop	r10
    21ca:	08 95       	ret

000021cc <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    21cc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    21ce:	10 92 c1 06 	sts	0x06C1, r1
	vPortEndScheduler();
    21d2:	0e 94 22 09 	call	0x1244	; 0x1244 <vPortEndScheduler>
}
    21d6:	08 95       	ret

000021d8 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    21d8:	80 91 bd 06 	lds	r24, 0x06BD
    21dc:	8f 5f       	subi	r24, 0xFF	; 255
    21de:	80 93 bd 06 	sts	0x06BD, r24
}
    21e2:	08 95       	ret

000021e4 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    21e4:	0f b6       	in	r0, 0x3f	; 63
    21e6:	f8 94       	cli
    21e8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    21ea:	80 91 c3 06 	lds	r24, 0x06C3
    21ee:	90 91 c4 06 	lds	r25, 0x06C4
	}
	taskEXIT_CRITICAL();
    21f2:	0f 90       	pop	r0
    21f4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    21f6:	08 95       	ret

000021f8 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    21f8:	80 91 c3 06 	lds	r24, 0x06C3
    21fc:	90 91 c4 06 	lds	r25, 0x06C4
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2200:	08 95       	ret

00002202 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2202:	80 91 c5 06 	lds	r24, 0x06C5
}
    2206:	08 95       	ret

00002208 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    2208:	cf 92       	push	r12
    220a:	df 92       	push	r13
    220c:	ef 92       	push	r14
    220e:	ff 92       	push	r15
    2210:	0f 93       	push	r16
    2212:	1f 93       	push	r17
    2214:	cf 93       	push	r28
    2216:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2218:	80 91 bd 06 	lds	r24, 0x06BD
    221c:	88 23       	and	r24, r24
    221e:	09 f0       	breq	.+2      	; 0x2222 <xTaskIncrementTick+0x1a>
    2220:	9a c0       	rjmp	.+308    	; 0x2356 <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    2222:	80 91 c3 06 	lds	r24, 0x06C3
    2226:	90 91 c4 06 	lds	r25, 0x06C4
    222a:	01 96       	adiw	r24, 0x01	; 1
    222c:	90 93 c4 06 	sts	0x06C4, r25
    2230:	80 93 c3 06 	sts	0x06C3, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2234:	c0 90 c3 06 	lds	r12, 0x06C3
    2238:	d0 90 c4 06 	lds	r13, 0x06C4

			if( xConstTickCount == ( TickType_t ) 0U )
    223c:	c1 14       	cp	r12, r1
    223e:	d1 04       	cpc	r13, r1
    2240:	b9 f4       	brne	.+46     	; 0x2270 <xTaskIncrementTick+0x68>
			{
				taskSWITCH_DELAYED_LISTS();
    2242:	80 91 c9 06 	lds	r24, 0x06C9
    2246:	90 91 ca 06 	lds	r25, 0x06CA
    224a:	20 91 c7 06 	lds	r18, 0x06C7
    224e:	30 91 c8 06 	lds	r19, 0x06C8
    2252:	30 93 ca 06 	sts	0x06CA, r19
    2256:	20 93 c9 06 	sts	0x06C9, r18
    225a:	90 93 c8 06 	sts	0x06C8, r25
    225e:	80 93 c7 06 	sts	0x06C7, r24
    2262:	80 91 be 06 	lds	r24, 0x06BE
    2266:	8f 5f       	subi	r24, 0xFF	; 255
    2268:	80 93 be 06 	sts	0x06BE, r24
    226c:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2270:	80 91 7d 00 	lds	r24, 0x007D
    2274:	90 91 7e 00 	lds	r25, 0x007E
    2278:	c8 16       	cp	r12, r24
    227a:	d9 06       	cpc	r13, r25
    227c:	20 f4       	brcc	.+8      	; 0x2286 <xTaskIncrementTick+0x7e>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    227e:	ff 24       	eor	r15, r15
    2280:	54 c0       	rjmp	.+168    	; 0x232a <xTaskIncrementTick+0x122>
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    2282:	fe 2c       	mov	r15, r14
    2284:	03 c0       	rjmp	.+6      	; 0x228c <xTaskIncrementTick+0x84>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2286:	ff 24       	eor	r15, r15
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    2288:	ee 24       	eor	r14, r14
    228a:	e3 94       	inc	r14
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    228c:	e0 91 c9 06 	lds	r30, 0x06C9
    2290:	f0 91 ca 06 	lds	r31, 0x06CA
    2294:	80 81       	ld	r24, Z
    2296:	88 23       	and	r24, r24
    2298:	39 f4       	brne	.+14     	; 0x22a8 <xTaskIncrementTick+0xa0>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    229a:	8f ef       	ldi	r24, 0xFF	; 255
    229c:	9f ef       	ldi	r25, 0xFF	; 255
    229e:	90 93 7e 00 	sts	0x007E, r25
    22a2:	80 93 7d 00 	sts	0x007D, r24
						break;
    22a6:	41 c0       	rjmp	.+130    	; 0x232a <xTaskIncrementTick+0x122>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    22a8:	e0 91 c9 06 	lds	r30, 0x06C9
    22ac:	f0 91 ca 06 	lds	r31, 0x06CA
    22b0:	05 80       	ldd	r0, Z+5	; 0x05
    22b2:	f6 81       	ldd	r31, Z+6	; 0x06
    22b4:	e0 2d       	mov	r30, r0
    22b6:	c6 81       	ldd	r28, Z+6	; 0x06
    22b8:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    22ba:	8a 81       	ldd	r24, Y+2	; 0x02
    22bc:	9b 81       	ldd	r25, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    22be:	c8 16       	cp	r12, r24
    22c0:	d9 06       	cpc	r13, r25
    22c2:	28 f4       	brcc	.+10     	; 0x22ce <xTaskIncrementTick+0xc6>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    22c4:	90 93 7e 00 	sts	0x007E, r25
    22c8:	80 93 7d 00 	sts	0x007D, r24
							break;
    22cc:	2e c0       	rjmp	.+92     	; 0x232a <xTaskIncrementTick+0x122>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    22ce:	8e 01       	movw	r16, r28
    22d0:	0e 5f       	subi	r16, 0xFE	; 254
    22d2:	1f 4f       	sbci	r17, 0xFF	; 255
    22d4:	c8 01       	movw	r24, r16
    22d6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    22da:	8c 89       	ldd	r24, Y+20	; 0x14
    22dc:	9d 89       	ldd	r25, Y+21	; 0x15
    22de:	00 97       	sbiw	r24, 0x00	; 0
    22e0:	21 f0       	breq	.+8      	; 0x22ea <xTaskIncrementTick+0xe2>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    22e2:	ce 01       	movw	r24, r28
    22e4:	0c 96       	adiw	r24, 0x0c	; 12
    22e6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    22ea:	8e 89       	ldd	r24, Y+22	; 0x16
    22ec:	90 91 c2 06 	lds	r25, 0x06C2
    22f0:	98 17       	cp	r25, r24
    22f2:	10 f4       	brcc	.+4      	; 0x22f8 <xTaskIncrementTick+0xf0>
    22f4:	80 93 c2 06 	sts	0x06C2, r24
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	9c 01       	movw	r18, r24
    22fc:	22 0f       	add	r18, r18
    22fe:	33 1f       	adc	r19, r19
    2300:	22 0f       	add	r18, r18
    2302:	33 1f       	adc	r19, r19
    2304:	22 0f       	add	r18, r18
    2306:	33 1f       	adc	r19, r19
    2308:	82 0f       	add	r24, r18
    230a:	93 1f       	adc	r25, r19
    230c:	84 53       	subi	r24, 0x34	; 52
    230e:	99 4f       	sbci	r25, 0xF9	; 249
    2310:	b8 01       	movw	r22, r16
    2312:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2316:	e0 91 bb 06 	lds	r30, 0x06BB
    231a:	f0 91 bc 06 	lds	r31, 0x06BC
    231e:	9e 89       	ldd	r25, Y+22	; 0x16
    2320:	86 89       	ldd	r24, Z+22	; 0x16
    2322:	98 17       	cp	r25, r24
    2324:	08 f0       	brcs	.+2      	; 0x2328 <xTaskIncrementTick+0x120>
    2326:	ad cf       	rjmp	.-166    	; 0x2282 <xTaskIncrementTick+0x7a>
    2328:	b1 cf       	rjmp	.-158    	; 0x228c <xTaskIncrementTick+0x84>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    232a:	e0 91 bb 06 	lds	r30, 0x06BB
    232e:	f0 91 bc 06 	lds	r31, 0x06BC
    2332:	86 89       	ldd	r24, Z+22	; 0x16
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	fc 01       	movw	r30, r24
    2338:	ee 0f       	add	r30, r30
    233a:	ff 1f       	adc	r31, r31
    233c:	ee 0f       	add	r30, r30
    233e:	ff 1f       	adc	r31, r31
    2340:	ee 0f       	add	r30, r30
    2342:	ff 1f       	adc	r31, r31
    2344:	8e 0f       	add	r24, r30
    2346:	9f 1f       	adc	r25, r31
    2348:	fc 01       	movw	r30, r24
    234a:	e4 53       	subi	r30, 0x34	; 52
    234c:	f9 4f       	sbci	r31, 0xF9	; 249
    234e:	80 81       	ld	r24, Z
    2350:	82 30       	cpi	r24, 0x02	; 2
    2352:	40 f4       	brcc	.+16     	; 0x2364 <xTaskIncrementTick+0x15c>
    2354:	09 c0       	rjmp	.+18     	; 0x2368 <xTaskIncrementTick+0x160>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2356:	80 91 c0 06 	lds	r24, 0x06C0
    235a:	8f 5f       	subi	r24, 0xFF	; 255
    235c:	80 93 c0 06 	sts	0x06C0, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    2360:	ff 24       	eor	r15, r15
    2362:	02 c0       	rjmp	.+4      	; 0x2368 <xTaskIncrementTick+0x160>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    2364:	ff 24       	eor	r15, r15
    2366:	f3 94       	inc	r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2368:	80 91 bf 06 	lds	r24, 0x06BF
    236c:	88 23       	and	r24, r24
    236e:	11 f0       	breq	.+4      	; 0x2374 <xTaskIncrementTick+0x16c>
		{
			xSwitchRequired = pdTRUE;
    2370:	ff 24       	eor	r15, r15
    2372:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    2374:	8f 2d       	mov	r24, r15
    2376:	df 91       	pop	r29
    2378:	cf 91       	pop	r28
    237a:	1f 91       	pop	r17
    237c:	0f 91       	pop	r16
    237e:	ff 90       	pop	r15
    2380:	ef 90       	pop	r14
    2382:	df 90       	pop	r13
    2384:	cf 90       	pop	r12
    2386:	08 95       	ret

00002388 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2388:	df 92       	push	r13
    238a:	ef 92       	push	r14
    238c:	ff 92       	push	r15
    238e:	0f 93       	push	r16
    2390:	1f 93       	push	r17
    2392:	cf 93       	push	r28
    2394:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    239c:	80 91 bd 06 	lds	r24, 0x06BD
    23a0:	81 50       	subi	r24, 0x01	; 1
    23a2:	80 93 bd 06 	sts	0x06BD, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    23a6:	80 91 bd 06 	lds	r24, 0x06BD
    23aa:	88 23       	and	r24, r24
    23ac:	09 f0       	breq	.+2      	; 0x23b0 <xTaskResumeAll+0x28>
    23ae:	62 c0       	rjmp	.+196    	; 0x2474 <xTaskResumeAll+0xec>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    23b0:	80 91 c5 06 	lds	r24, 0x06C5
    23b4:	88 23       	and	r24, r24
    23b6:	91 f5       	brne	.+100    	; 0x241c <xTaskResumeAll+0x94>
    23b8:	60 c0       	rjmp	.+192    	; 0x247a <xTaskResumeAll+0xf2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    23ba:	e0 91 22 07 	lds	r30, 0x0722
    23be:	f0 91 23 07 	lds	r31, 0x0723
    23c2:	c6 81       	ldd	r28, Z+6	; 0x06
    23c4:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    23c6:	ce 01       	movw	r24, r28
    23c8:	0c 96       	adiw	r24, 0x0c	; 12
    23ca:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    23ce:	8e 01       	movw	r16, r28
    23d0:	0e 5f       	subi	r16, 0xFE	; 254
    23d2:	1f 4f       	sbci	r17, 0xFF	; 255
    23d4:	c8 01       	movw	r24, r16
    23d6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    23da:	8e 89       	ldd	r24, Y+22	; 0x16
    23dc:	90 91 c2 06 	lds	r25, 0x06C2
    23e0:	98 17       	cp	r25, r24
    23e2:	10 f4       	brcc	.+4      	; 0x23e8 <xTaskResumeAll+0x60>
    23e4:	80 93 c2 06 	sts	0x06C2, r24
    23e8:	90 e0       	ldi	r25, 0x00	; 0
    23ea:	9c 01       	movw	r18, r24
    23ec:	22 0f       	add	r18, r18
    23ee:	33 1f       	adc	r19, r19
    23f0:	22 0f       	add	r18, r18
    23f2:	33 1f       	adc	r19, r19
    23f4:	22 0f       	add	r18, r18
    23f6:	33 1f       	adc	r19, r19
    23f8:	82 0f       	add	r24, r18
    23fa:	93 1f       	adc	r25, r19
    23fc:	84 53       	subi	r24, 0x34	; 52
    23fe:	99 4f       	sbci	r25, 0xF9	; 249
    2400:	b8 01       	movw	r22, r16
    2402:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2406:	e0 91 bb 06 	lds	r30, 0x06BB
    240a:	f0 91 bc 06 	lds	r31, 0x06BC
    240e:	9e 89       	ldd	r25, Y+22	; 0x16
    2410:	86 89       	ldd	r24, Z+22	; 0x16
    2412:	98 17       	cp	r25, r24
    2414:	58 f0       	brcs	.+22     	; 0x242c <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
    2416:	d0 92 bf 06 	sts	0x06BF, r13
    241a:	08 c0       	rjmp	.+16     	; 0x242c <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    241c:	0f 2e       	mov	r0, r31
    241e:	fd e1       	ldi	r31, 0x1D	; 29
    2420:	ef 2e       	mov	r14, r31
    2422:	f7 e0       	ldi	r31, 0x07	; 7
    2424:	ff 2e       	mov	r15, r31
    2426:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    2428:	dd 24       	eor	r13, r13
    242a:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    242c:	f7 01       	movw	r30, r14
    242e:	80 81       	ld	r24, Z
    2430:	88 23       	and	r24, r24
    2432:	19 f6       	brne	.-122    	; 0x23ba <xTaskResumeAll+0x32>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2434:	80 91 c0 06 	lds	r24, 0x06C0
    2438:	88 23       	and	r24, r24
    243a:	a1 f0       	breq	.+40     	; 0x2464 <xTaskResumeAll+0xdc>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    243c:	80 91 c0 06 	lds	r24, 0x06C0
    2440:	88 23       	and	r24, r24
    2442:	81 f0       	breq	.+32     	; 0x2464 <xTaskResumeAll+0xdc>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    2444:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    2446:	0e 94 04 11 	call	0x2208	; 0x2208 <xTaskIncrementTick>
    244a:	88 23       	and	r24, r24
    244c:	11 f0       	breq	.+4      	; 0x2452 <xTaskResumeAll+0xca>
						{
							xYieldPending = pdTRUE;
    244e:	c0 93 bf 06 	sts	0x06BF, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2452:	80 91 c0 06 	lds	r24, 0x06C0
    2456:	81 50       	subi	r24, 0x01	; 1
    2458:	80 93 c0 06 	sts	0x06C0, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    245c:	80 91 c0 06 	lds	r24, 0x06C0
    2460:	88 23       	and	r24, r24
    2462:	89 f7       	brne	.-30     	; 0x2446 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2464:	80 91 bf 06 	lds	r24, 0x06BF
    2468:	81 30       	cpi	r24, 0x01	; 1
    246a:	31 f4       	brne	.+12     	; 0x2478 <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    246c:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2470:	81 e0       	ldi	r24, 0x01	; 1
    2472:	03 c0       	rjmp	.+6      	; 0x247a <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	01 c0       	rjmp	.+2      	; 0x247a <xTaskResumeAll+0xf2>
    2478:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    247a:	0f 90       	pop	r0
    247c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    247e:	df 91       	pop	r29
    2480:	cf 91       	pop	r28
    2482:	1f 91       	pop	r17
    2484:	0f 91       	pop	r16
    2486:	ff 90       	pop	r15
    2488:	ef 90       	pop	r14
    248a:	df 90       	pop	r13
    248c:	08 95       	ret

0000248e <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    248e:	06 e2       	ldi	r16, 0x26	; 38
    2490:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2492:	0f 2e       	mov	r0, r31
    2494:	fc ec       	ldi	r31, 0xCC	; 204
    2496:	ef 2e       	mov	r14, r31
    2498:	f6 e0       	ldi	r31, 0x06	; 6
    249a:	ff 2e       	mov	r15, r31
    249c:	f0 2d       	mov	r31, r0
    249e:	28 c0       	rjmp	.+80     	; 0x24f0 <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    24a0:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    24a4:	f8 01       	movw	r30, r16
    24a6:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    24a8:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    24ac:	cc 23       	and	r28, r28
    24ae:	01 f1       	breq	.+64     	; 0x24f0 <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    24b0:	0f b6       	in	r0, 0x3f	; 63
    24b2:	f8 94       	cli
    24b4:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    24b6:	e0 91 2b 07 	lds	r30, 0x072B
    24ba:	f0 91 2c 07 	lds	r31, 0x072C
    24be:	c6 81       	ldd	r28, Z+6	; 0x06
    24c0:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    24c2:	ce 01       	movw	r24, r28
    24c4:	02 96       	adiw	r24, 0x02	; 2
    24c6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
					--uxCurrentNumberOfTasks;
    24ca:	80 91 c5 06 	lds	r24, 0x06C5
    24ce:	81 50       	subi	r24, 0x01	; 1
    24d0:	80 93 c5 06 	sts	0x06C5, r24
					--uxTasksDeleted;
    24d4:	80 91 c6 06 	lds	r24, 0x06C6
    24d8:	81 50       	subi	r24, 0x01	; 1
    24da:	80 93 c6 06 	sts	0x06C6, r24
				}
				taskEXIT_CRITICAL();
    24de:	0f 90       	pop	r0
    24e0:	0f be       	out	0x3f, r0	; 63
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
    24e2:	8f 89       	ldd	r24, Y+23	; 0x17
    24e4:	98 8d       	ldd	r25, Y+24	; 0x18
    24e6:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>
		vPortFree( pxTCB );
    24ea:	ce 01       	movw	r24, r28
    24ec:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    24f0:	80 91 c6 06 	lds	r24, 0x06C6
    24f4:	88 23       	and	r24, r24
    24f6:	a1 f6       	brne	.-88     	; 0x24a0 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    24f8:	f7 01       	movw	r30, r14
    24fa:	80 81       	ld	r24, Z
    24fc:	82 30       	cpi	r24, 0x02	; 2
    24fe:	c0 f3       	brcs	.-16     	; 0x24f0 <prvIdleTask+0x62>
			{
				taskYIELD();
    2500:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    2504:	f5 cf       	rjmp	.-22     	; 0x24f0 <prvIdleTask+0x62>

00002506 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2506:	cf 93       	push	r28
    2508:	df 93       	push	r29
    250a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    250c:	00 97       	sbiw	r24, 0x00	; 0
    250e:	b1 f0       	breq	.+44     	; 0x253c <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2510:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2514:	80 91 c3 06 	lds	r24, 0x06C3
    2518:	90 91 c4 06 	lds	r25, 0x06C4
    251c:	c8 0f       	add	r28, r24
    251e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2520:	80 91 bb 06 	lds	r24, 0x06BB
    2524:	90 91 bc 06 	lds	r25, 0x06BC
    2528:	02 96       	adiw	r24, 0x02	; 2
    252a:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    252e:	ce 01       	movw	r24, r28
    2530:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2534:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2538:	88 23       	and	r24, r24
    253a:	11 f4       	brne	.+4      	; 0x2540 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    253c:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2540:	df 91       	pop	r29
    2542:	cf 91       	pop	r28
    2544:	08 95       	ret

00002546 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2546:	0f 93       	push	r16
    2548:	1f 93       	push	r17
    254a:	cf 93       	push	r28
    254c:	df 93       	push	r29
    254e:	8c 01       	movw	r16, r24
    2550:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2552:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2556:	20 91 c3 06 	lds	r18, 0x06C3
    255a:	30 91 c4 06 	lds	r19, 0x06C4

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    255e:	f8 01       	movw	r30, r16
    2560:	80 81       	ld	r24, Z
    2562:	91 81       	ldd	r25, Z+1	; 0x01
    2564:	c8 0f       	add	r28, r24
    2566:	d9 1f       	adc	r29, r25

			if( xConstTickCount < *pxPreviousWakeTime )
    2568:	28 17       	cp	r18, r24
    256a:	39 07       	cpc	r19, r25
    256c:	48 f4       	brcc	.+18     	; 0x2580 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    256e:	c8 17       	cp	r28, r24
    2570:	d9 07       	cpc	r29, r25
    2572:	10 f5       	brcc	.+68     	; 0x25b8 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2574:	d1 83       	std	Z+1, r29	; 0x01
    2576:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    2578:	2c 17       	cp	r18, r28
    257a:	3d 07       	cpc	r19, r29
    257c:	90 f4       	brcc	.+36     	; 0x25a2 <vTaskDelayUntil+0x5c>
    257e:	07 c0       	rjmp	.+14     	; 0x258e <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2580:	c8 17       	cp	r28, r24
    2582:	d9 07       	cpc	r29, r25
    2584:	a8 f0       	brcs	.+42     	; 0x25b0 <vTaskDelayUntil+0x6a>
    2586:	2c 17       	cp	r18, r28
    2588:	3d 07       	cpc	r19, r29
    258a:	90 f0       	brcs	.+36     	; 0x25b0 <vTaskDelayUntil+0x6a>
    258c:	15 c0       	rjmp	.+42     	; 0x25b8 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    258e:	80 91 bb 06 	lds	r24, 0x06BB
    2592:	90 91 bc 06 	lds	r25, 0x06BC
    2596:	02 96       	adiw	r24, 0x02	; 2
    2598:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    259c:	ce 01       	movw	r24, r28
    259e:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    25a2:	0e 94 c4 11 	call	0x2388	; 0x2388 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    25a6:	88 23       	and	r24, r24
    25a8:	59 f4       	brne	.+22     	; 0x25c0 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
    25aa:	0e 94 23 09 	call	0x1246	; 0x1246 <vPortYield>
    25ae:	08 c0       	rjmp	.+16     	; 0x25c0 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    25b0:	f8 01       	movw	r30, r16
    25b2:	d1 83       	std	Z+1, r29	; 0x01
    25b4:	c0 83       	st	Z, r28
    25b6:	eb cf       	rjmp	.-42     	; 0x258e <vTaskDelayUntil+0x48>
    25b8:	f8 01       	movw	r30, r16
    25ba:	d1 83       	std	Z+1, r29	; 0x01
    25bc:	c0 83       	st	Z, r28
    25be:	f1 cf       	rjmp	.-30     	; 0x25a2 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    25c0:	df 91       	pop	r29
    25c2:	cf 91       	pop	r28
    25c4:	1f 91       	pop	r17
    25c6:	0f 91       	pop	r16
    25c8:	08 95       	ret

000025ca <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    25ca:	80 91 bd 06 	lds	r24, 0x06BD
    25ce:	88 23       	and	r24, r24
    25d0:	21 f0       	breq	.+8      	; 0x25da <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	80 93 bf 06 	sts	0x06BF, r24
    25d8:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    25da:	10 92 bf 06 	sts	0x06BF, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    25de:	80 91 c2 06 	lds	r24, 0x06C2
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	fc 01       	movw	r30, r24
    25e6:	ee 0f       	add	r30, r30
    25e8:	ff 1f       	adc	r31, r31
    25ea:	ee 0f       	add	r30, r30
    25ec:	ff 1f       	adc	r31, r31
    25ee:	ee 0f       	add	r30, r30
    25f0:	ff 1f       	adc	r31, r31
    25f2:	8e 0f       	add	r24, r30
    25f4:	9f 1f       	adc	r25, r31
    25f6:	fc 01       	movw	r30, r24
    25f8:	e4 53       	subi	r30, 0x34	; 52
    25fa:	f9 4f       	sbci	r31, 0xF9	; 249
    25fc:	80 81       	ld	r24, Z
    25fe:	88 23       	and	r24, r24
    2600:	b9 f4       	brne	.+46     	; 0x2630 <vTaskSwitchContext+0x66>
    2602:	80 91 c2 06 	lds	r24, 0x06C2
    2606:	81 50       	subi	r24, 0x01	; 1
    2608:	80 93 c2 06 	sts	0x06C2, r24
    260c:	80 91 c2 06 	lds	r24, 0x06C2
    2610:	90 e0       	ldi	r25, 0x00	; 0
    2612:	fc 01       	movw	r30, r24
    2614:	ee 0f       	add	r30, r30
    2616:	ff 1f       	adc	r31, r31
    2618:	ee 0f       	add	r30, r30
    261a:	ff 1f       	adc	r31, r31
    261c:	ee 0f       	add	r30, r30
    261e:	ff 1f       	adc	r31, r31
    2620:	8e 0f       	add	r24, r30
    2622:	9f 1f       	adc	r25, r31
    2624:	fc 01       	movw	r30, r24
    2626:	e4 53       	subi	r30, 0x34	; 52
    2628:	f9 4f       	sbci	r31, 0xF9	; 249
    262a:	80 81       	ld	r24, Z
    262c:	88 23       	and	r24, r24
    262e:	49 f3       	breq	.-46     	; 0x2602 <vTaskSwitchContext+0x38>
    2630:	80 91 c2 06 	lds	r24, 0x06C2
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	fc 01       	movw	r30, r24
    2638:	ee 0f       	add	r30, r30
    263a:	ff 1f       	adc	r31, r31
    263c:	ee 0f       	add	r30, r30
    263e:	ff 1f       	adc	r31, r31
    2640:	ee 0f       	add	r30, r30
    2642:	ff 1f       	adc	r31, r31
    2644:	e8 0f       	add	r30, r24
    2646:	f9 1f       	adc	r31, r25
    2648:	e4 53       	subi	r30, 0x34	; 52
    264a:	f9 4f       	sbci	r31, 0xF9	; 249
    264c:	a1 81       	ldd	r26, Z+1	; 0x01
    264e:	b2 81       	ldd	r27, Z+2	; 0x02
    2650:	12 96       	adiw	r26, 0x02	; 2
    2652:	0d 90       	ld	r0, X+
    2654:	bc 91       	ld	r27, X
    2656:	a0 2d       	mov	r26, r0
    2658:	b2 83       	std	Z+2, r27	; 0x02
    265a:	a1 83       	std	Z+1, r26	; 0x01
    265c:	cf 01       	movw	r24, r30
    265e:	03 96       	adiw	r24, 0x03	; 3
    2660:	a8 17       	cp	r26, r24
    2662:	b9 07       	cpc	r27, r25
    2664:	31 f4       	brne	.+12     	; 0x2672 <vTaskSwitchContext+0xa8>
    2666:	12 96       	adiw	r26, 0x02	; 2
    2668:	8d 91       	ld	r24, X+
    266a:	9c 91       	ld	r25, X
    266c:	13 97       	sbiw	r26, 0x03	; 3
    266e:	92 83       	std	Z+2, r25	; 0x02
    2670:	81 83       	std	Z+1, r24	; 0x01
    2672:	01 80       	ldd	r0, Z+1	; 0x01
    2674:	f2 81       	ldd	r31, Z+2	; 0x02
    2676:	e0 2d       	mov	r30, r0
    2678:	86 81       	ldd	r24, Z+6	; 0x06
    267a:	97 81       	ldd	r25, Z+7	; 0x07
    267c:	90 93 bc 06 	sts	0x06BC, r25
    2680:	80 93 bb 06 	sts	0x06BB, r24
    2684:	08 95       	ret

00002686 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2686:	cf 93       	push	r28
    2688:	df 93       	push	r29
    268a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    268c:	60 91 bb 06 	lds	r22, 0x06BB
    2690:	70 91 bc 06 	lds	r23, 0x06BC
    2694:	64 5f       	subi	r22, 0xF4	; 244
    2696:	7f 4f       	sbci	r23, 0xFF	; 255
    2698:	0e 94 42 07 	call	0xe84	; 0xe84 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    269c:	80 91 bb 06 	lds	r24, 0x06BB
    26a0:	90 91 bc 06 	lds	r25, 0x06BC
    26a4:	02 96       	adiw	r24, 0x02	; 2
    26a6:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    26aa:	80 91 c3 06 	lds	r24, 0x06C3
    26ae:	90 91 c4 06 	lds	r25, 0x06C4
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    26b2:	8c 0f       	add	r24, r28
    26b4:	9d 1f       	adc	r25, r29
    26b6:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	08 95       	ret

000026c0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    26c0:	cf 93       	push	r28
    26c2:	df 93       	push	r29
    26c4:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    26c6:	e0 91 bb 06 	lds	r30, 0x06BB
    26ca:	f0 91 bc 06 	lds	r31, 0x06BC
    26ce:	70 68       	ori	r23, 0x80	; 128
    26d0:	75 87       	std	Z+13, r23	; 0x0d
    26d2:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    26d4:	60 91 bb 06 	lds	r22, 0x06BB
    26d8:	70 91 bc 06 	lds	r23, 0x06BC
    26dc:	64 5f       	subi	r22, 0xF4	; 244
    26de:	7f 4f       	sbci	r23, 0xFF	; 255
    26e0:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    26e4:	80 91 bb 06 	lds	r24, 0x06BB
    26e8:	90 91 bc 06 	lds	r25, 0x06BC
    26ec:	02 96       	adiw	r24, 0x02	; 2
    26ee:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    26f2:	80 91 c3 06 	lds	r24, 0x06C3
    26f6:	90 91 c4 06 	lds	r25, 0x06C4
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    26fa:	8c 0f       	add	r24, r28
    26fc:	9d 1f       	adc	r25, r29
    26fe:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2702:	df 91       	pop	r29
    2704:	cf 91       	pop	r28
    2706:	08 95       	ret

00002708 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2708:	0f 93       	push	r16
    270a:	1f 93       	push	r17
    270c:	cf 93       	push	r28
    270e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2710:	dc 01       	movw	r26, r24
    2712:	15 96       	adiw	r26, 0x05	; 5
    2714:	ed 91       	ld	r30, X+
    2716:	fc 91       	ld	r31, X
    2718:	16 97       	sbiw	r26, 0x06	; 6
    271a:	06 81       	ldd	r16, Z+6	; 0x06
    271c:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    271e:	e8 01       	movw	r28, r16
    2720:	2c 96       	adiw	r28, 0x0c	; 12
    2722:	ce 01       	movw	r24, r28
    2724:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2728:	80 91 bd 06 	lds	r24, 0x06BD
    272c:	88 23       	and	r24, r24
    272e:	e9 f4       	brne	.+58     	; 0x276a <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2730:	e8 01       	movw	r28, r16
    2732:	22 96       	adiw	r28, 0x02	; 2
    2734:	ce 01       	movw	r24, r28
    2736:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    273a:	f8 01       	movw	r30, r16
    273c:	86 89       	ldd	r24, Z+22	; 0x16
    273e:	90 91 c2 06 	lds	r25, 0x06C2
    2742:	98 17       	cp	r25, r24
    2744:	10 f4       	brcc	.+4      	; 0x274a <xTaskRemoveFromEventList+0x42>
    2746:	80 93 c2 06 	sts	0x06C2, r24
    274a:	90 e0       	ldi	r25, 0x00	; 0
    274c:	9c 01       	movw	r18, r24
    274e:	22 0f       	add	r18, r18
    2750:	33 1f       	adc	r19, r19
    2752:	22 0f       	add	r18, r18
    2754:	33 1f       	adc	r19, r19
    2756:	22 0f       	add	r18, r18
    2758:	33 1f       	adc	r19, r19
    275a:	82 0f       	add	r24, r18
    275c:	93 1f       	adc	r25, r19
    275e:	84 53       	subi	r24, 0x34	; 52
    2760:	99 4f       	sbci	r25, 0xF9	; 249
    2762:	be 01       	movw	r22, r28
    2764:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
    2768:	05 c0       	rjmp	.+10     	; 0x2774 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    276a:	8d e1       	ldi	r24, 0x1D	; 29
    276c:	97 e0       	ldi	r25, 0x07	; 7
    276e:	be 01       	movw	r22, r28
    2770:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2774:	e0 91 bb 06 	lds	r30, 0x06BB
    2778:	f0 91 bc 06 	lds	r31, 0x06BC
    277c:	d8 01       	movw	r26, r16
    277e:	56 96       	adiw	r26, 0x16	; 22
    2780:	9c 91       	ld	r25, X
    2782:	56 97       	sbiw	r26, 0x16	; 22
    2784:	86 89       	ldd	r24, Z+22	; 0x16
    2786:	89 17       	cp	r24, r25
    2788:	20 f4       	brcc	.+8      	; 0x2792 <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    278a:	81 e0       	ldi	r24, 0x01	; 1
    278c:	80 93 bf 06 	sts	0x06BF, r24
    2790:	01 c0       	rjmp	.+2      	; 0x2794 <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    2792:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2794:	df 91       	pop	r29
    2796:	cf 91       	pop	r28
    2798:	1f 91       	pop	r17
    279a:	0f 91       	pop	r16
    279c:	08 95       	ret

0000279e <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    279e:	0f 93       	push	r16
    27a0:	1f 93       	push	r17
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    27a6:	70 68       	ori	r23, 0x80	; 128
    27a8:	fc 01       	movw	r30, r24
    27aa:	71 83       	std	Z+1, r23	; 0x01
    27ac:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    27ae:	c6 81       	ldd	r28, Z+6	; 0x06
    27b0:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    27b2:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    27b6:	8e 01       	movw	r16, r28
    27b8:	0e 5f       	subi	r16, 0xFE	; 254
    27ba:	1f 4f       	sbci	r17, 0xFF	; 255
    27bc:	c8 01       	movw	r24, r16
    27be:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    27c2:	8e 89       	ldd	r24, Y+22	; 0x16
    27c4:	90 91 c2 06 	lds	r25, 0x06C2
    27c8:	98 17       	cp	r25, r24
    27ca:	10 f4       	brcc	.+4      	; 0x27d0 <xTaskRemoveFromUnorderedEventList+0x32>
    27cc:	80 93 c2 06 	sts	0x06C2, r24
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	9c 01       	movw	r18, r24
    27d4:	22 0f       	add	r18, r18
    27d6:	33 1f       	adc	r19, r19
    27d8:	22 0f       	add	r18, r18
    27da:	33 1f       	adc	r19, r19
    27dc:	22 0f       	add	r18, r18
    27de:	33 1f       	adc	r19, r19
    27e0:	82 0f       	add	r24, r18
    27e2:	93 1f       	adc	r25, r19
    27e4:	84 53       	subi	r24, 0x34	; 52
    27e6:	99 4f       	sbci	r25, 0xF9	; 249
    27e8:	b8 01       	movw	r22, r16
    27ea:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    27ee:	e0 91 bb 06 	lds	r30, 0x06BB
    27f2:	f0 91 bc 06 	lds	r31, 0x06BC
    27f6:	9e 89       	ldd	r25, Y+22	; 0x16
    27f8:	86 89       	ldd	r24, Z+22	; 0x16
    27fa:	89 17       	cp	r24, r25
    27fc:	20 f4       	brcc	.+8      	; 0x2806 <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    27fe:	81 e0       	ldi	r24, 0x01	; 1
    2800:	80 93 bf 06 	sts	0x06BF, r24
    2804:	01 c0       	rjmp	.+2      	; 0x2808 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    2806:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2808:	df 91       	pop	r29
    280a:	cf 91       	pop	r28
    280c:	1f 91       	pop	r17
    280e:	0f 91       	pop	r16
    2810:	08 95       	ret

00002812 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2812:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2814:	80 91 be 06 	lds	r24, 0x06BE
    2818:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    281a:	80 91 c3 06 	lds	r24, 0x06C3
    281e:	90 91 c4 06 	lds	r25, 0x06C4
    2822:	92 83       	std	Z+2, r25	; 0x02
    2824:	81 83       	std	Z+1, r24	; 0x01
}
    2826:	08 95       	ret

00002828 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2828:	fc 01       	movw	r30, r24
    282a:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2832:	40 91 c3 06 	lds	r20, 0x06C3
    2836:	50 91 c4 06 	lds	r21, 0x06C4
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    283a:	80 91 be 06 	lds	r24, 0x06BE
    283e:	90 81       	ld	r25, Z
    2840:	98 17       	cp	r25, r24
    2842:	29 f0       	breq	.+10     	; 0x284e <xTaskCheckForTimeOut+0x26>
    2844:	81 81       	ldd	r24, Z+1	; 0x01
    2846:	92 81       	ldd	r25, Z+2	; 0x02
    2848:	48 17       	cp	r20, r24
    284a:	59 07       	cpc	r21, r25
    284c:	b0 f4       	brcc	.+44     	; 0x287a <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    284e:	81 81       	ldd	r24, Z+1	; 0x01
    2850:	92 81       	ldd	r25, Z+2	; 0x02
    2852:	6d 91       	ld	r22, X+
    2854:	7c 91       	ld	r23, X
    2856:	11 97       	sbiw	r26, 0x01	; 1
    2858:	9a 01       	movw	r18, r20
    285a:	28 1b       	sub	r18, r24
    285c:	39 0b       	sbc	r19, r25
    285e:	26 17       	cp	r18, r22
    2860:	37 07       	cpc	r19, r23
    2862:	68 f4       	brcc	.+26     	; 0x287e <xTaskCheckForTimeOut+0x56>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2864:	84 1b       	sub	r24, r20
    2866:	95 0b       	sbc	r25, r21
    2868:	86 0f       	add	r24, r22
    286a:	97 1f       	adc	r25, r23
    286c:	8d 93       	st	X+, r24
    286e:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2870:	cf 01       	movw	r24, r30
    2872:	0e 94 09 14 	call	0x2812	; 0x2812 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2876:	80 e0       	ldi	r24, 0x00	; 0
    2878:	03 c0       	rjmp	.+6      	; 0x2880 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	01 c0       	rjmp	.+2      	; 0x2880 <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    287e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2880:	0f 90       	pop	r0
    2882:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2884:	08 95       	ret

00002886 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2886:	81 e0       	ldi	r24, 0x01	; 1
    2888:	80 93 bf 06 	sts	0x06BF, r24
}
    288c:	08 95       	ret

0000288e <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    288e:	80 91 bb 06 	lds	r24, 0x06BB
    2892:	90 91 bc 06 	lds	r25, 0x06BC

		return xReturn;
	}
    2896:	08 95       	ret

00002898 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    2898:	0f 93       	push	r16
    289a:	1f 93       	push	r17
    289c:	cf 93       	push	r28
    289e:	df 93       	push	r29
    28a0:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    28a2:	00 97       	sbiw	r24, 0x00	; 0
    28a4:	09 f4       	brne	.+2      	; 0x28a8 <vTaskPriorityInherit+0x10>
    28a6:	51 c0       	rjmp	.+162    	; 0x294a <vTaskPriorityInherit+0xb2>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    28a8:	8e 89       	ldd	r24, Y+22	; 0x16
    28aa:	e0 91 bb 06 	lds	r30, 0x06BB
    28ae:	f0 91 bc 06 	lds	r31, 0x06BC
    28b2:	96 89       	ldd	r25, Z+22	; 0x16
    28b4:	89 17       	cp	r24, r25
    28b6:	08 f0       	brcs	.+2      	; 0x28ba <vTaskPriorityInherit+0x22>
    28b8:	48 c0       	rjmp	.+144    	; 0x294a <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    28ba:	2c 85       	ldd	r18, Y+12	; 0x0c
    28bc:	3d 85       	ldd	r19, Y+13	; 0x0d
    28be:	33 23       	and	r19, r19
    28c0:	5c f0       	brlt	.+22     	; 0x28d8 <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    28c2:	e0 91 bb 06 	lds	r30, 0x06BB
    28c6:	f0 91 bc 06 	lds	r31, 0x06BC
    28ca:	96 89       	ldd	r25, Z+22	; 0x16
    28cc:	27 e0       	ldi	r18, 0x07	; 7
    28ce:	30 e0       	ldi	r19, 0x00	; 0
    28d0:	29 1b       	sub	r18, r25
    28d2:	31 09       	sbc	r19, r1
    28d4:	3d 87       	std	Y+13, r19	; 0x0d
    28d6:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	9c 01       	movw	r18, r24
    28dc:	22 0f       	add	r18, r18
    28de:	33 1f       	adc	r19, r19
    28e0:	22 0f       	add	r18, r18
    28e2:	33 1f       	adc	r19, r19
    28e4:	22 0f       	add	r18, r18
    28e6:	33 1f       	adc	r19, r19
    28e8:	82 0f       	add	r24, r18
    28ea:	93 1f       	adc	r25, r19
    28ec:	84 53       	subi	r24, 0x34	; 52
    28ee:	99 4f       	sbci	r25, 0xF9	; 249
    28f0:	2a 85       	ldd	r18, Y+10	; 0x0a
    28f2:	3b 85       	ldd	r19, Y+11	; 0x0b
    28f4:	28 17       	cp	r18, r24
    28f6:	39 07       	cpc	r19, r25
    28f8:	11 f5       	brne	.+68     	; 0x293e <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    28fa:	8e 01       	movw	r16, r28
    28fc:	0e 5f       	subi	r16, 0xFE	; 254
    28fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2900:	c8 01       	movw	r24, r16
    2902:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2906:	e0 91 bb 06 	lds	r30, 0x06BB
    290a:	f0 91 bc 06 	lds	r31, 0x06BC
    290e:	86 89       	ldd	r24, Z+22	; 0x16
    2910:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    2912:	90 91 c2 06 	lds	r25, 0x06C2
    2916:	98 17       	cp	r25, r24
    2918:	10 f4       	brcc	.+4      	; 0x291e <vTaskPriorityInherit+0x86>
    291a:	80 93 c2 06 	sts	0x06C2, r24
    291e:	90 e0       	ldi	r25, 0x00	; 0
    2920:	9c 01       	movw	r18, r24
    2922:	22 0f       	add	r18, r18
    2924:	33 1f       	adc	r19, r19
    2926:	22 0f       	add	r18, r18
    2928:	33 1f       	adc	r19, r19
    292a:	22 0f       	add	r18, r18
    292c:	33 1f       	adc	r19, r19
    292e:	82 0f       	add	r24, r18
    2930:	93 1f       	adc	r25, r19
    2932:	84 53       	subi	r24, 0x34	; 52
    2934:	99 4f       	sbci	r25, 0xF9	; 249
    2936:	b8 01       	movw	r22, r16
    2938:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>
    293c:	06 c0       	rjmp	.+12     	; 0x294a <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    293e:	e0 91 bb 06 	lds	r30, 0x06BB
    2942:	f0 91 bc 06 	lds	r31, 0x06BC
    2946:	86 89       	ldd	r24, Z+22	; 0x16
    2948:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    294a:	df 91       	pop	r29
    294c:	cf 91       	pop	r28
    294e:	1f 91       	pop	r17
    2950:	0f 91       	pop	r16
    2952:	08 95       	ret

00002954 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2954:	0f 93       	push	r16
    2956:	1f 93       	push	r17
    2958:	cf 93       	push	r28
    295a:	df 93       	push	r29
    295c:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    295e:	00 97       	sbiw	r24, 0x00	; 0
    2960:	81 f1       	breq	.+96     	; 0x29c2 <xTaskPriorityDisinherit+0x6e>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2962:	8e a5       	lds	r24, 0x6e
    2964:	81 50       	subi	r24, 0x01	; 1
    2966:	8e a7       	lds	r24, 0x7e

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2968:	2e 89       	ldd	r18, Y+22	; 0x16
    296a:	9d a5       	lds	r25, 0x6d
    296c:	29 17       	cp	r18, r25
    296e:	59 f1       	breq	.+86     	; 0x29c6 <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2970:	88 23       	and	r24, r24
    2972:	59 f5       	brne	.+86     	; 0x29ca <xTaskPriorityDisinherit+0x76>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2974:	8e 01       	movw	r16, r28
    2976:	0e 5f       	subi	r16, 0xFE	; 254
    2978:	1f 4f       	sbci	r17, 0xFF	; 255
    297a:	c8 01       	movw	r24, r16
    297c:	0e 94 74 07 	call	0xee8	; 0xee8 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    2980:	4d a5       	lds	r20, 0x6d
    2982:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2984:	24 2f       	mov	r18, r20
    2986:	30 e0       	ldi	r19, 0x00	; 0
    2988:	87 e0       	ldi	r24, 0x07	; 7
    298a:	90 e0       	ldi	r25, 0x00	; 0
    298c:	82 1b       	sub	r24, r18
    298e:	93 0b       	sbc	r25, r19
    2990:	9d 87       	std	Y+13, r25	; 0x0d
    2992:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    2994:	80 91 c2 06 	lds	r24, 0x06C2
    2998:	84 17       	cp	r24, r20
    299a:	10 f4       	brcc	.+4      	; 0x29a0 <xTaskPriorityDisinherit+0x4c>
    299c:	40 93 c2 06 	sts	0x06C2, r20
    29a0:	c9 01       	movw	r24, r18
    29a2:	88 0f       	add	r24, r24
    29a4:	99 1f       	adc	r25, r25
    29a6:	88 0f       	add	r24, r24
    29a8:	99 1f       	adc	r25, r25
    29aa:	88 0f       	add	r24, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	28 0f       	add	r18, r24
    29b0:	39 1f       	adc	r19, r25
    29b2:	c9 01       	movw	r24, r18
    29b4:	84 53       	subi	r24, 0x34	; 52
    29b6:	99 4f       	sbci	r25, 0xF9	; 249
    29b8:	b8 01       	movw	r22, r16
    29ba:	0e 94 23 07 	call	0xe46	; 0xe46 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    29be:	81 e0       	ldi	r24, 0x01	; 1
    29c0:	05 c0       	rjmp	.+10     	; 0x29cc <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    29c2:	80 e0       	ldi	r24, 0x00	; 0
    29c4:	03 c0       	rjmp	.+6      	; 0x29cc <xTaskPriorityDisinherit+0x78>
    29c6:	80 e0       	ldi	r24, 0x00	; 0
    29c8:	01 c0       	rjmp	.+2      	; 0x29cc <xTaskPriorityDisinherit+0x78>
    29ca:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    29cc:	df 91       	pop	r29
    29ce:	cf 91       	pop	r28
    29d0:	1f 91       	pop	r17
    29d2:	0f 91       	pop	r16
    29d4:	08 95       	ret

000029d6 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    29d6:	e0 91 bb 06 	lds	r30, 0x06BB
    29da:	f0 91 bc 06 	lds	r31, 0x06BC
    29de:	84 85       	ldd	r24, Z+12	; 0x0c
    29e0:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    29e2:	e0 91 bb 06 	lds	r30, 0x06BB
    29e6:	f0 91 bc 06 	lds	r31, 0x06BC
    29ea:	a0 91 bb 06 	lds	r26, 0x06BB
    29ee:	b0 91 bc 06 	lds	r27, 0x06BC
    29f2:	56 96       	adiw	r26, 0x16	; 22
    29f4:	4c 91       	ld	r20, X
    29f6:	56 97       	sbiw	r26, 0x16	; 22
    29f8:	27 e0       	ldi	r18, 0x07	; 7
    29fa:	30 e0       	ldi	r19, 0x00	; 0
    29fc:	24 1b       	sub	r18, r20
    29fe:	31 09       	sbc	r19, r1
    2a00:	35 87       	std	Z+13, r19	; 0x0d
    2a02:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2a04:	08 95       	ret

00002a06 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2a06:	80 91 bb 06 	lds	r24, 0x06BB
    2a0a:	90 91 bc 06 	lds	r25, 0x06BC
    2a0e:	00 97       	sbiw	r24, 0x00	; 0
    2a10:	39 f0       	breq	.+14     	; 0x2a20 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2a12:	e0 91 bb 06 	lds	r30, 0x06BB
    2a16:	f0 91 bc 06 	lds	r31, 0x06BC
    2a1a:	86 a5       	lds	r24, 0x66
    2a1c:	8f 5f       	subi	r24, 0xFF	; 255
    2a1e:	86 a7       	lds	r24, 0x76
		}

		return pxCurrentTCB;
    2a20:	80 91 bb 06 	lds	r24, 0x06BB
    2a24:	90 91 bc 06 	lds	r25, 0x06BC
	}
    2a28:	08 95       	ret

00002a2a <TAS_DispScreen>:
/* Variables */
u8 digitCounter = 0;
u8 digitValue = 0;

void TAS_DispScreen(SystemState_t state){
	switch (state)
    2a2a:	81 30       	cpi	r24, 0x01	; 1
    2a2c:	91 f0       	breq	.+36     	; 0x2a52 <TAS_DispScreen+0x28>
    2a2e:	81 30       	cpi	r24, 0x01	; 1
    2a30:	18 f0       	brcs	.+6      	; 0x2a38 <TAS_DispScreen+0xe>
    2a32:	82 30       	cpi	r24, 0x02	; 2
    2a34:	39 f5       	brne	.+78     	; 0x2a84 <TAS_DispScreen+0x5a>
    2a36:	1a c0       	rjmp	.+52     	; 0x2a6c <TAS_DispScreen+0x42>
	{
	case SS_MAIN:
		LCD_DispStrXY(1,1,DISP_MAIN_L0);
    2a38:	81 e0       	ldi	r24, 0x01	; 1
    2a3a:	61 e0       	ldi	r22, 0x01	; 1
    2a3c:	4f e7       	ldi	r20, 0x7F	; 127
    2a3e:	50 e0       	ldi	r21, 0x00	; 0
    2a40:	0e 94 b2 01 	call	0x364	; 0x364 <LCD_DispStrXY>
		LCD_DispStrXY(2,1,DISP_MAIN_L1);
    2a44:	82 e0       	ldi	r24, 0x02	; 2
    2a46:	61 e0       	ldi	r22, 0x01	; 1
    2a48:	40 e9       	ldi	r20, 0x90	; 144
    2a4a:	50 e0       	ldi	r21, 0x00	; 0
    2a4c:	0e 94 b2 01 	call	0x364	; 0x364 <LCD_DispStrXY>
		break;
    2a50:	08 95       	ret
	case SS_CONFIG:
		LCD_DispStrXY(1,1,DISP_CONFIG_L0);
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	61 e0       	ldi	r22, 0x01	; 1
    2a56:	41 ea       	ldi	r20, 0xA1	; 161
    2a58:	50 e0       	ldi	r21, 0x00	; 0
    2a5a:	0e 94 b2 01 	call	0x364	; 0x364 <LCD_DispStrXY>
		LCD_DispStrXY(2,1,DISP_CONFIG_L1);
    2a5e:	82 e0       	ldi	r24, 0x02	; 2
    2a60:	61 e0       	ldi	r22, 0x01	; 1
    2a62:	42 eb       	ldi	r20, 0xB2	; 178
    2a64:	50 e0       	ldi	r21, 0x00	; 0
    2a66:	0e 94 b2 01 	call	0x364	; 0x364 <LCD_DispStrXY>
		break;
    2a6a:	08 95       	ret
	case SS_ALARM:
		LCD_DispStrXY(1,1,DISP_ALARM_L0);
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	61 e0       	ldi	r22, 0x01	; 1
    2a70:	43 ec       	ldi	r20, 0xC3	; 195
    2a72:	50 e0       	ldi	r21, 0x00	; 0
    2a74:	0e 94 b2 01 	call	0x364	; 0x364 <LCD_DispStrXY>
		LCD_DispStrXY(2,1,DISP_ALARM_L1);
    2a78:	82 e0       	ldi	r24, 0x02	; 2
    2a7a:	61 e0       	ldi	r22, 0x01	; 1
    2a7c:	44 ed       	ldi	r20, 0xD4	; 212
    2a7e:	50 e0       	ldi	r21, 0x00	; 0
    2a80:	0e 94 b2 01 	call	0x364	; 0x364 <LCD_DispStrXY>
    2a84:	08 95       	ret

00002a86 <T_Alarm>:
	}
}

void T_Alarm(void* ptr)
{
	Uart_SendStr("T_Alarm Started ...\r\n");
    2a86:	85 ee       	ldi	r24, 0xE5	; 229
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
	EventBits_t	ebBits = NULL;
	while(1){
		ebBits = xEventGroupWaitBits(egEvents,(E_ALARM),0,0,portMAX_DELAY);
    2a8e:	80 91 35 07 	lds	r24, 0x0735
    2a92:	90 91 36 07 	lds	r25, 0x0736
    2a96:	60 e8       	ldi	r22, 0x80	; 128
    2a98:	70 e0       	ldi	r23, 0x00	; 0
    2a9a:	40 e0       	ldi	r20, 0x00	; 0
    2a9c:	20 e0       	ldi	r18, 0x00	; 0
    2a9e:	0f ef       	ldi	r16, 0xFF	; 255
    2aa0:	1f ef       	ldi	r17, 0xFF	; 255
    2aa2:	0e 94 b3 04 	call	0x966	; 0x966 <xEventGroupWaitBits>
		if(ebBits&(E_ALARM)){
    2aa6:	87 ff       	sbrs	r24, 7
    2aa8:	f2 cf       	rjmp	.-28     	; 0x2a8e <T_Alarm+0x8>
			Buz_On();
    2aaa:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <Buz_On>
			vTaskDelay(500);
    2aae:	84 ef       	ldi	r24, 0xF4	; 244
    2ab0:	91 e0       	ldi	r25, 0x01	; 1
    2ab2:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskDelay>
			Buz_Off();
    2ab6:	0e 94 d6 00 	call	0x1ac	; 0x1ac <Buz_Off>
			vTaskDelay(500);
    2aba:	84 ef       	ldi	r24, 0xF4	; 244
    2abc:	91 e0       	ldi	r25, 0x01	; 1
    2abe:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskDelay>
    2ac2:	e5 cf       	rjmp	.-54     	; 0x2a8e <T_Alarm+0x8>

00002ac4 <T_Temp>:
		}
	}
}
void T_Temp(void* ptr)
{
	Uart_SendStr("T_Temp Started ...\r\n");
    2ac4:	8b ef       	ldi	r24, 0xFB	; 251
    2ac6:	90 e0       	ldi	r25, 0x00	; 0
    2ac8:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
	u16 temp = 0;
	while(1){
		temp = ADC_Read(ADC_CH0);
		temp = (temp/1023.0)*150;
		if(temp != TAS.CTemp ){
    2acc:	c6 e7       	ldi	r28, 0x76	; 118
    2ace:	d1 e0       	ldi	r29, 0x01	; 1
			TAS.CTemp = temp;
			if(TAS.SysState == SS_MAIN){
    2ad0:	8e 01       	movw	r16, r28
    2ad2:	02 50       	subi	r16, 0x02	; 2
    2ad4:	10 40       	sbci	r17, 0x00	; 0
void T_Temp(void* ptr)
{
	Uart_SendStr("T_Temp Started ...\r\n");
	u16 temp = 0;
	while(1){
		temp = ADC_Read(ADC_CH0);
    2ad6:	80 e0       	ldi	r24, 0x00	; 0
    2ad8:	0e 94 52 00 	call	0xa4	; 0xa4 <ADC_Read>
		temp = (temp/1023.0)*150;
    2adc:	bc 01       	movw	r22, r24
    2ade:	80 e0       	ldi	r24, 0x00	; 0
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatunsisf>
    2ae6:	20 e0       	ldi	r18, 0x00	; 0
    2ae8:	30 ec       	ldi	r19, 0xC0	; 192
    2aea:	4f e7       	ldi	r20, 0x7F	; 127
    2aec:	54 e4       	ldi	r21, 0x44	; 68
    2aee:	0e 94 20 18 	call	0x3040	; 0x3040 <__divsf3>
    2af2:	20 e0       	ldi	r18, 0x00	; 0
    2af4:	30 e0       	ldi	r19, 0x00	; 0
    2af6:	46 e1       	ldi	r20, 0x16	; 22
    2af8:	53 e4       	ldi	r21, 0x43	; 67
    2afa:	0e 94 42 19 	call	0x3284	; 0x3284 <__mulsf3>
    2afe:	46 2f       	mov	r20, r22
    2b00:	57 2f       	mov	r21, r23
    2b02:	68 2f       	mov	r22, r24
    2b04:	79 2f       	mov	r23, r25
    2b06:	cb 01       	movw	r24, r22
    2b08:	ba 01       	movw	r22, r20
    2b0a:	0e 94 88 18 	call	0x3110	; 0x3110 <__fixunssfsi>
		if(temp != TAS.CTemp ){
    2b0e:	88 81       	ld	r24, Y
    2b10:	90 e0       	ldi	r25, 0x00	; 0
    2b12:	86 17       	cp	r24, r22
    2b14:	97 07       	cpc	r25, r23
    2b16:	c1 f0       	breq	.+48     	; 0x2b48 <T_Temp+0x84>
			TAS.CTemp = temp;
    2b18:	68 83       	st	Y, r22
			if(TAS.SysState == SS_MAIN){
    2b1a:	f8 01       	movw	r30, r16
    2b1c:	80 81       	ld	r24, Z
    2b1e:	88 23       	and	r24, r24
    2b20:	41 f4       	brne	.+16     	; 0x2b32 <T_Temp+0x6e>
				xEventGroupSetBits(egEvents,E_CTEMP_UPDATE);
    2b22:	80 91 35 07 	lds	r24, 0x0735
    2b26:	90 91 36 07 	lds	r25, 0x0736
    2b2a:	68 e0       	ldi	r22, 0x08	; 8
    2b2c:	70 e0       	ldi	r23, 0x00	; 0
    2b2e:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
			}
			xSemaphoreGive(bsCheck);
    2b32:	80 91 33 07 	lds	r24, 0x0733
    2b36:	90 91 34 07 	lds	r25, 0x0734
    2b3a:	60 e0       	ldi	r22, 0x00	; 0
    2b3c:	70 e0       	ldi	r23, 0x00	; 0
    2b3e:	40 e0       	ldi	r20, 0x00	; 0
    2b40:	50 e0       	ldi	r21, 0x00	; 0
    2b42:	20 e0       	ldi	r18, 0x00	; 0
    2b44:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
		}
		vTaskDelay(100);
    2b48:	84 e6       	ldi	r24, 0x64	; 100
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskDelay>
	}
    2b50:	c2 cf       	rjmp	.-124    	; 0x2ad6 <T_Temp+0x12>

00002b52 <T_SysCheck>:
}
void T_SysCheck(void* ptr)
{
	Uart_SendStr("T_SysCheck Started ...\r\n");
    2b52:	80 e1       	ldi	r24, 0x10	; 16
    2b54:	91 e0       	ldi	r25, 0x01	; 1
    2b56:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
	while(1){
		if(xSemaphoreTake(bsCheck,portMAX_DELAY)){
			if(TAS.AlarmStatus == 'E' && TAS.CTemp >= TAS.TTemp){
    2b5a:	05 e7       	ldi	r16, 0x75	; 117
    2b5c:	11 e0       	ldi	r17, 0x01	; 1
				TAS.SysState = SS_ALARM;
				xEventGroupSetBits(egEvents,(E_ALARM_SCREEN)); // to T_Display
				xEventGroupSetBits(egEvents,(E_ALARM)); // to T_Alarm
			}
			else if(TAS.SysState == SS_ALARM && (TAS.AlarmStatus == 'D' || TAS.CTemp < TAS.TTemp)){
    2b5e:	c4 e7       	ldi	r28, 0x74	; 116
    2b60:	d1 e0       	ldi	r29, 0x01	; 1
    2b62:	0f 2e       	mov	r0, r31
    2b64:	f6 e7       	ldi	r31, 0x76	; 118
    2b66:	ef 2e       	mov	r14, r31
    2b68:	f1 e0       	ldi	r31, 0x01	; 1
    2b6a:	ff 2e       	mov	r15, r31
    2b6c:	f0 2d       	mov	r31, r0
    2b6e:	67 01       	movw	r12, r14
    2b70:	08 94       	sec
    2b72:	c1 1c       	adc	r12, r1
    2b74:	d1 1c       	adc	r13, r1
{
	Uart_SendStr("T_SysCheck Started ...\r\n");
	while(1){
		if(xSemaphoreTake(bsCheck,portMAX_DELAY)){
			if(TAS.AlarmStatus == 'E' && TAS.CTemp >= TAS.TTemp){
				TAS.SysState = SS_ALARM;
    2b76:	bb 24       	eor	r11, r11
    2b78:	68 94       	set
    2b7a:	b1 f8       	bld	r11, 1
}
void T_SysCheck(void* ptr)
{
	Uart_SendStr("T_SysCheck Started ...\r\n");
	while(1){
		if(xSemaphoreTake(bsCheck,portMAX_DELAY)){
    2b7c:	80 91 33 07 	lds	r24, 0x0733
    2b80:	90 91 34 07 	lds	r25, 0x0734
    2b84:	60 e0       	ldi	r22, 0x00	; 0
    2b86:	70 e0       	ldi	r23, 0x00	; 0
    2b88:	4f ef       	ldi	r20, 0xFF	; 255
    2b8a:	5f ef       	ldi	r21, 0xFF	; 255
    2b8c:	20 e0       	ldi	r18, 0x00	; 0
    2b8e:	0e 94 3f 0c 	call	0x187e	; 0x187e <xQueueGenericReceive>
    2b92:	88 23       	and	r24, r24
    2b94:	99 f3       	breq	.-26     	; 0x2b7c <T_SysCheck+0x2a>
			if(TAS.AlarmStatus == 'E' && TAS.CTemp >= TAS.TTemp){
    2b96:	f8 01       	movw	r30, r16
    2b98:	80 81       	ld	r24, Z
    2b9a:	85 34       	cpi	r24, 0x45	; 69
    2b9c:	c1 f4       	brne	.+48     	; 0x2bce <T_SysCheck+0x7c>
    2b9e:	f7 01       	movw	r30, r14
    2ba0:	20 81       	ld	r18, Z
    2ba2:	f6 01       	movw	r30, r12
    2ba4:	90 81       	ld	r25, Z
    2ba6:	29 17       	cp	r18, r25
    2ba8:	90 f0       	brcs	.+36     	; 0x2bce <T_SysCheck+0x7c>
				TAS.SysState = SS_ALARM;
    2baa:	b8 82       	st	Y, r11
				xEventGroupSetBits(egEvents,(E_ALARM_SCREEN)); // to T_Display
    2bac:	80 91 35 07 	lds	r24, 0x0735
    2bb0:	90 91 36 07 	lds	r25, 0x0736
    2bb4:	62 e0       	ldi	r22, 0x02	; 2
    2bb6:	70 e0       	ldi	r23, 0x00	; 0
    2bb8:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
				xEventGroupSetBits(egEvents,(E_ALARM)); // to T_Alarm
    2bbc:	80 91 35 07 	lds	r24, 0x0735
    2bc0:	90 91 36 07 	lds	r25, 0x0736
    2bc4:	60 e8       	ldi	r22, 0x80	; 128
    2bc6:	70 e0       	ldi	r23, 0x00	; 0
    2bc8:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
    2bcc:	d7 cf       	rjmp	.-82     	; 0x2b7c <T_SysCheck+0x2a>
			}
			else if(TAS.SysState == SS_ALARM && (TAS.AlarmStatus == 'D' || TAS.CTemp < TAS.TTemp)){
    2bce:	98 81       	ld	r25, Y
    2bd0:	92 30       	cpi	r25, 0x02	; 2
    2bd2:	a1 f6       	brne	.-88     	; 0x2b7c <T_SysCheck+0x2a>
    2bd4:	84 34       	cpi	r24, 0x44	; 68
    2bd6:	31 f0       	breq	.+12     	; 0x2be4 <T_SysCheck+0x92>
    2bd8:	f7 01       	movw	r30, r14
    2bda:	90 81       	ld	r25, Z
    2bdc:	f6 01       	movw	r30, r12
    2bde:	80 81       	ld	r24, Z
    2be0:	98 17       	cp	r25, r24
    2be2:	60 f6       	brcc	.-104    	; 0x2b7c <T_SysCheck+0x2a>
				xEventGroupClearBits(egEvents,(E_ALARM)); // stop Alarming in T_Alarm
    2be4:	80 91 35 07 	lds	r24, 0x0735
    2be8:	90 91 36 07 	lds	r25, 0x0736
    2bec:	60 e8       	ldi	r22, 0x80	; 128
    2bee:	70 e0       	ldi	r23, 0x00	; 0
    2bf0:	0e 94 1f 05 	call	0xa3e	; 0xa3e <xEventGroupClearBits>
				TAS.SysState = SS_MAIN;
    2bf4:	18 82       	st	Y, r1
				xEventGroupSetBits(egEvents,(E_MAIN_SCREEN|E_CTEMP_UPDATE|E_TTEMP_UPDATE|E_ALARM_STATUS_UPDATE));
    2bf6:	80 91 35 07 	lds	r24, 0x0735
    2bfa:	90 91 36 07 	lds	r25, 0x0736
    2bfe:	69 e5       	ldi	r22, 0x59	; 89
    2c00:	70 e0       	ldi	r23, 0x00	; 0
    2c02:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
    2c06:	ba cf       	rjmp	.-140    	; 0x2b7c <T_SysCheck+0x2a>

00002c08 <T_Display>:
}

void T_Display(void* ptr)
{
	EventBits_t			ebBits = NULL;
	Uart_SendStr("T_Display Started ...\r\n");
    2c08:	89 e2       	ldi	r24, 0x29	; 41
    2c0a:	91 e0       	ldi	r25, 0x01	; 1
    2c0c:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
		}
		if(ebBits&E_CONFIG_SCREEN){
			TAS_DispScreen(SS_CONFIG);
		}
		if(ebBits&E_CTEMP_UPDATE){
			if(TAS.SysState == SS_MAIN)
    2c10:	0f 2e       	mov	r0, r31
    2c12:	f4 e7       	ldi	r31, 0x74	; 116
    2c14:	ef 2e       	mov	r14, r31
    2c16:	f1 e0       	ldi	r31, 0x01	; 1
    2c18:	ff 2e       	mov	r15, r31
    2c1a:	f0 2d       	mov	r31, r0
			LCD_DispIntXY(DISP_CTEMP_ROW,DISP_CTEMP_COL,TAS.CTemp);
    2c1c:	0f 2e       	mov	r0, r31
    2c1e:	f6 e7       	ldi	r31, 0x76	; 118
    2c20:	af 2e       	mov	r10, r31
    2c22:	f1 e0       	ldi	r31, 0x01	; 1
    2c24:	bf 2e       	mov	r11, r31
    2c26:	f0 2d       	mov	r31, r0
		}
		if(ebBits&E_TTEMP_UPDATE){
			if(TAS.SysState == SS_MAIN)
			LCD_DispIntXY(DISP_TTEMP_ROW,DISP_TTEMP_COL,TAS.TTemp);
    2c28:	0f 2e       	mov	r0, r31
    2c2a:	f7 e7       	ldi	r31, 0x77	; 119
    2c2c:	8f 2e       	mov	r8, r31
    2c2e:	f1 e0       	ldi	r31, 0x01	; 1
    2c30:	9f 2e       	mov	r9, r31
    2c32:	f0 2d       	mov	r31, r0
			if(TAS.SysState == SS_CONFIG)
			LCD_DispCharXY(DISP_TTEMP_ROW, (DISP_TTEMP_COL + digitCounter), digitValue);
		}
		if(ebBits&E_ALARM_STATUS_UPDATE){
			if(TAS.SysState == SS_MAIN)
			LCD_DispCharXY(DISP_AS_ROW,DISP_AS_COL,TAS.AlarmStatus);
    2c34:	0f 2e       	mov	r0, r31
    2c36:	f5 e7       	ldi	r31, 0x75	; 117
    2c38:	cf 2e       	mov	r12, r31
    2c3a:	f1 e0       	ldi	r31, 0x01	; 1
    2c3c:	df 2e       	mov	r13, r31
    2c3e:	f0 2d       	mov	r31, r0
{
	EventBits_t			ebBits = NULL;
	Uart_SendStr("T_Display Started ...\r\n");
	while(1)
	{
		ebBits = xEventGroupWaitBits(egEvents,(E_DISP_EVENTS),1,0,portMAX_DELAY);
    2c40:	80 91 35 07 	lds	r24, 0x0735
    2c44:	90 91 36 07 	lds	r25, 0x0736
    2c48:	6f e7       	ldi	r22, 0x7F	; 127
    2c4a:	70 e0       	ldi	r23, 0x00	; 0
    2c4c:	41 e0       	ldi	r20, 0x01	; 1
    2c4e:	20 e0       	ldi	r18, 0x00	; 0
    2c50:	0f ef       	ldi	r16, 0xFF	; 255
    2c52:	1f ef       	ldi	r17, 0xFF	; 255
    2c54:	0e 94 b3 04 	call	0x966	; 0x966 <xEventGroupWaitBits>
    2c58:	c8 2f       	mov	r28, r24
		if(ebBits&E_MAIN_SCREEN){
    2c5a:	80 ff       	sbrs	r24, 0
    2c5c:	03 c0       	rjmp	.+6      	; 0x2c64 <T_Display+0x5c>
			TAS_DispScreen(SS_MAIN);
    2c5e:	80 e0       	ldi	r24, 0x00	; 0
    2c60:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <TAS_DispScreen>
		}
		if(ebBits&E_ALARM_SCREEN){
    2c64:	c1 ff       	sbrs	r28, 1
    2c66:	03 c0       	rjmp	.+6      	; 0x2c6e <T_Display+0x66>
			TAS_DispScreen(SS_ALARM);
    2c68:	82 e0       	ldi	r24, 0x02	; 2
    2c6a:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <TAS_DispScreen>
		}
		if(ebBits&E_CONFIG_SCREEN){
    2c6e:	c2 ff       	sbrs	r28, 2
    2c70:	03 c0       	rjmp	.+6      	; 0x2c78 <T_Display+0x70>
			TAS_DispScreen(SS_CONFIG);
    2c72:	81 e0       	ldi	r24, 0x01	; 1
    2c74:	0e 94 15 15 	call	0x2a2a	; 0x2a2a <TAS_DispScreen>
		}
		if(ebBits&E_CTEMP_UPDATE){
    2c78:	c3 ff       	sbrs	r28, 3
    2c7a:	0d c0       	rjmp	.+26     	; 0x2c96 <T_Display+0x8e>
			if(TAS.SysState == SS_MAIN)
    2c7c:	f7 01       	movw	r30, r14
    2c7e:	80 81       	ld	r24, Z
    2c80:	88 23       	and	r24, r24
    2c82:	49 f4       	brne	.+18     	; 0x2c96 <T_Display+0x8e>
			LCD_DispIntXY(DISP_CTEMP_ROW,DISP_CTEMP_COL,TAS.CTemp);
    2c84:	f5 01       	movw	r30, r10
    2c86:	20 81       	ld	r18, Z
    2c88:	30 e0       	ldi	r19, 0x00	; 0
    2c8a:	40 e0       	ldi	r20, 0x00	; 0
    2c8c:	50 e0       	ldi	r21, 0x00	; 0
    2c8e:	81 e0       	ldi	r24, 0x01	; 1
    2c90:	63 e0       	ldi	r22, 0x03	; 3
    2c92:	0e 94 e6 01 	call	0x3cc	; 0x3cc <LCD_DispIntXY>
		}
		if(ebBits&E_TTEMP_UPDATE){
    2c96:	c4 ff       	sbrs	r28, 4
    2c98:	0d c0       	rjmp	.+26     	; 0x2cb4 <T_Display+0xac>
			if(TAS.SysState == SS_MAIN)
    2c9a:	f7 01       	movw	r30, r14
    2c9c:	80 81       	ld	r24, Z
    2c9e:	88 23       	and	r24, r24
    2ca0:	49 f4       	brne	.+18     	; 0x2cb4 <T_Display+0xac>
			LCD_DispIntXY(DISP_TTEMP_ROW,DISP_TTEMP_COL,TAS.TTemp);
    2ca2:	f4 01       	movw	r30, r8
    2ca4:	20 81       	ld	r18, Z
    2ca6:	30 e0       	ldi	r19, 0x00	; 0
    2ca8:	40 e0       	ldi	r20, 0x00	; 0
    2caa:	50 e0       	ldi	r21, 0x00	; 0
    2cac:	81 e0       	ldi	r24, 0x01	; 1
    2cae:	69 e0       	ldi	r22, 0x09	; 9
    2cb0:	0e 94 e6 01 	call	0x3cc	; 0x3cc <LCD_DispIntXY>
		}
		if(ebBits&E_TTEMP_DIGIT_DISP){
    2cb4:	c5 ff       	sbrs	r28, 5
    2cb6:	0b c0       	rjmp	.+22     	; 0x2cce <T_Display+0xc6>
			if(TAS.SysState == SS_CONFIG)
    2cb8:	f7 01       	movw	r30, r14
    2cba:	80 81       	ld	r24, Z
    2cbc:	81 30       	cpi	r24, 0x01	; 1
    2cbe:	39 f4       	brne	.+14     	; 0x2cce <T_Display+0xc6>
			LCD_DispCharXY(DISP_TTEMP_ROW, (DISP_TTEMP_COL + digitCounter), digitValue);
    2cc0:	60 91 30 07 	lds	r22, 0x0730
    2cc4:	67 5f       	subi	r22, 0xF7	; 247
    2cc6:	40 91 2f 07 	lds	r20, 0x072F
    2cca:	0e 94 a9 01 	call	0x352	; 0x352 <LCD_DispCharXY>
		}
		if(ebBits&E_ALARM_STATUS_UPDATE){
    2cce:	c6 ff       	sbrs	r28, 6
    2cd0:	b7 cf       	rjmp	.-146    	; 0x2c40 <T_Display+0x38>
			if(TAS.SysState == SS_MAIN)
    2cd2:	f7 01       	movw	r30, r14
    2cd4:	80 81       	ld	r24, Z
    2cd6:	88 23       	and	r24, r24
    2cd8:	09 f0       	breq	.+2      	; 0x2cdc <T_Display+0xd4>
    2cda:	b2 cf       	rjmp	.-156    	; 0x2c40 <T_Display+0x38>
			LCD_DispCharXY(DISP_AS_ROW,DISP_AS_COL,TAS.AlarmStatus);
    2cdc:	81 e0       	ldi	r24, 0x01	; 1
    2cde:	60 e1       	ldi	r22, 0x10	; 16
    2ce0:	f6 01       	movw	r30, r12
    2ce2:	40 81       	ld	r20, Z
    2ce4:	0e 94 a9 01 	call	0x352	; 0x352 <LCD_DispCharXY>
    2ce8:	ab cf       	rjmp	.-170    	; 0x2c40 <T_Display+0x38>

00002cea <T_EventTerm>:
		}
	}
}

void T_EventTerm(void *ptr)
{
    2cea:	cf 93       	push	r28
    2cec:	df 93       	push	r29
    2cee:	00 d0       	rcall	.+0      	; 0x2cf0 <T_EventTerm+0x6>
    2cf0:	cd b7       	in	r28, 0x3d	; 61
    2cf2:	de b7       	in	r29, 0x3e	; 62
	u8 ch;
	u8 recTTemp;
	Int_EEPROM_Read(EEPROM_THRESOLD_ADDRESS , &recTTemp);
    2cf4:	81 e0       	ldi	r24, 0x01	; 1
    2cf6:	90 e0       	ldi	r25, 0x00	; 0
    2cf8:	be 01       	movw	r22, r28
    2cfa:	6e 5f       	subi	r22, 0xFE	; 254
    2cfc:	7f 4f       	sbci	r23, 0xFF	; 255
    2cfe:	0e 94 ef 00 	call	0x1de	; 0x1de <Int_EEPROM_Read>
	Uart_SendStr("T_EventTerm Started ...\r\n");
    2d02:	81 e4       	ldi	r24, 0x41	; 65
    2d04:	91 e0       	ldi	r25, 0x01	; 1
    2d06:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
	while(1)
	{
		if(xQueueReceive(TRM_Queue, &ch, portMAX_DELAY))
		{
			switch (TAS.SysState)
    2d0a:	04 e7       	ldi	r16, 0x74	; 116
    2d0c:	11 e0       	ldi	r17, 0x01	; 1
				break;		
				case SS_CONFIG:
				{
					if(ch == 'O')
					{
						TAS.TTemp = recTTemp;
    2d0e:	0f 2e       	mov	r0, r31
    2d10:	f7 e7       	ldi	r31, 0x77	; 119
    2d12:	cf 2e       	mov	r12, r31
    2d14:	f1 e0       	ldi	r31, 0x01	; 1
    2d16:	df 2e       	mov	r13, r31
    2d18:	f0 2d       	mov	r31, r0
						EEPROM_Update(EEPROM_THRESOLD_ADDRESS,TAS.TTemp);
						TAS.SysState = SS_MAIN;
    2d1a:	0f 2e       	mov	r0, r31
    2d1c:	fd ef       	ldi	r31, 0xFD	; 253
    2d1e:	6f 2e       	mov	r6, r31
    2d20:	ff ef       	ldi	r31, 0xFF	; 255
    2d22:	7f 2e       	mov	r7, r31
    2d24:	f0 2d       	mov	r31, r0
    2d26:	6c 0c       	add	r6, r12
    2d28:	7d 1c       	adc	r7, r13
						recTTemp = 0;
						xEventGroupSetBits(egEvents,E_CONFIG_SCREEN);
					}
					else if (ch == 'T')
					{
						if(TAS.AlarmStatus == 'E')
    2d2a:	0f 2e       	mov	r0, r31
    2d2c:	f5 e7       	ldi	r31, 0x75	; 117
    2d2e:	ef 2e       	mov	r14, r31
    2d30:	f1 e0       	ldi	r31, 0x01	; 1
    2d32:	ff 2e       	mov	r15, r31
    2d34:	f0 2d       	mov	r31, r0
						TAS.AlarmStatus = 'D';
						//
						}
						else
						{
							TAS.AlarmStatus = 'E';
    2d36:	0f 2e       	mov	r0, r31
    2d38:	f5 e4       	ldi	r31, 0x45	; 69
    2d3a:	af 2e       	mov	r10, r31
    2d3c:	f0 2d       	mov	r31, r0
					}
					else if (ch == 'T')
					{
						if(TAS.AlarmStatus == 'E')
						{ // toggle alarm status
						TAS.AlarmStatus = 'D';
    2d3e:	0f 2e       	mov	r0, r31
    2d40:	f4 e4       	ldi	r31, 0x44	; 68
    2d42:	bf 2e       	mov	r11, r31
    2d44:	f0 2d       	mov	r31, r0
			{
				case SS_MAIN:
				{
					if (ch == 'C')
					{
						TAS.SysState = SS_CONFIG;
    2d46:	99 24       	eor	r9, r9
    2d48:	93 94       	inc	r9
	u8 recTTemp;
	Int_EEPROM_Read(EEPROM_THRESOLD_ADDRESS , &recTTemp);
	Uart_SendStr("T_EventTerm Started ...\r\n");
	while(1)
	{
		if(xQueueReceive(TRM_Queue, &ch, portMAX_DELAY))
    2d4a:	80 91 31 07 	lds	r24, 0x0731
    2d4e:	90 91 32 07 	lds	r25, 0x0732
    2d52:	be 01       	movw	r22, r28
    2d54:	6f 5f       	subi	r22, 0xFF	; 255
    2d56:	7f 4f       	sbci	r23, 0xFF	; 255
    2d58:	4f ef       	ldi	r20, 0xFF	; 255
    2d5a:	5f ef       	ldi	r21, 0xFF	; 255
    2d5c:	20 e0       	ldi	r18, 0x00	; 0
    2d5e:	0e 94 3f 0c 	call	0x187e	; 0x187e <xQueueGenericReceive>
    2d62:	88 23       	and	r24, r24
    2d64:	91 f3       	breq	.-28     	; 0x2d4a <T_EventTerm+0x60>
		{
			switch (TAS.SysState)
    2d66:	f8 01       	movw	r30, r16
    2d68:	80 81       	ld	r24, Z
    2d6a:	81 30       	cpi	r24, 0x01	; 1
    2d6c:	09 f4       	brne	.+2      	; 0x2d70 <T_EventTerm+0x86>
    2d6e:	46 c0       	rjmp	.+140    	; 0x2dfc <T_EventTerm+0x112>
    2d70:	81 30       	cpi	r24, 0x01	; 1
    2d72:	18 f0       	brcs	.+6      	; 0x2d7a <T_EventTerm+0x90>
    2d74:	82 30       	cpi	r24, 0x02	; 2
    2d76:	49 f7       	brne	.-46     	; 0x2d4a <T_EventTerm+0x60>
    2d78:	2f c0       	rjmp	.+94     	; 0x2dd8 <T_EventTerm+0xee>
			{
				case SS_MAIN:
				{
					if (ch == 'C')
    2d7a:	89 81       	ldd	r24, Y+1	; 0x01
    2d7c:	83 34       	cpi	r24, 0x43	; 67
    2d7e:	71 f4       	brne	.+28     	; 0x2d9c <T_EventTerm+0xb2>
					{
						TAS.SysState = SS_CONFIG;
    2d80:	f8 01       	movw	r30, r16
    2d82:	90 82       	st	Z, r9
						digitCounter = 0;
    2d84:	10 92 30 07 	sts	0x0730, r1
						recTTemp = 0;
    2d88:	1a 82       	std	Y+2, r1	; 0x02
						xEventGroupSetBits(egEvents,E_CONFIG_SCREEN);
    2d8a:	80 91 35 07 	lds	r24, 0x0735
    2d8e:	90 91 36 07 	lds	r25, 0x0736
    2d92:	64 e0       	ldi	r22, 0x04	; 4
    2d94:	70 e0       	ldi	r23, 0x00	; 0
    2d96:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
    2d9a:	d7 cf       	rjmp	.-82     	; 0x2d4a <T_EventTerm+0x60>
					}
					else if (ch == 'T')
    2d9c:	84 35       	cpi	r24, 0x54	; 84
    2d9e:	a9 f6       	brne	.-86     	; 0x2d4a <T_EventTerm+0x60>
					{
						if(TAS.AlarmStatus == 'E')
    2da0:	f7 01       	movw	r30, r14
    2da2:	80 81       	ld	r24, Z
    2da4:	85 34       	cpi	r24, 0x45	; 69
    2da6:	11 f4       	brne	.+4      	; 0x2dac <T_EventTerm+0xc2>
						{ // toggle alarm status
						TAS.AlarmStatus = 'D';
    2da8:	b0 82       	st	Z, r11
    2daa:	02 c0       	rjmp	.+4      	; 0x2db0 <T_EventTerm+0xc6>
						//
						}
						else
						{
							TAS.AlarmStatus = 'E';
    2dac:	f7 01       	movw	r30, r14
    2dae:	a0 82       	st	Z, r10
							// recheck is a must
						}
						xEventGroupSetBits(egEvents,E_ALARM_STATUS_UPDATE);
    2db0:	80 91 35 07 	lds	r24, 0x0735
    2db4:	90 91 36 07 	lds	r25, 0x0736
    2db8:	60 e4       	ldi	r22, 0x40	; 64
    2dba:	70 e0       	ldi	r23, 0x00	; 0
    2dbc:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
						xSemaphoreGive(bsCheck);
    2dc0:	80 91 33 07 	lds	r24, 0x0733
    2dc4:	90 91 34 07 	lds	r25, 0x0734
    2dc8:	60 e0       	ldi	r22, 0x00	; 0
    2dca:	70 e0       	ldi	r23, 0x00	; 0
    2dcc:	40 e0       	ldi	r20, 0x00	; 0
    2dce:	50 e0       	ldi	r21, 0x00	; 0
    2dd0:	20 e0       	ldi	r18, 0x00	; 0
    2dd2:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    2dd6:	b9 cf       	rjmp	.-142    	; 0x2d4a <T_EventTerm+0x60>
					}					
				}
				break;
				case SS_ALARM:
				{
					if (ch == 'S')
    2dd8:	89 81       	ldd	r24, Y+1	; 0x01
    2dda:	83 35       	cpi	r24, 0x53	; 83
    2ddc:	09 f0       	breq	.+2      	; 0x2de0 <T_EventTerm+0xf6>
    2dde:	b5 cf       	rjmp	.-150    	; 0x2d4a <T_EventTerm+0x60>
					{
						TAS.AlarmStatus = 'D';
    2de0:	f7 01       	movw	r30, r14
    2de2:	b0 82       	st	Z, r11
						xSemaphoreGive(bsCheck);
    2de4:	80 91 33 07 	lds	r24, 0x0733
    2de8:	90 91 34 07 	lds	r25, 0x0734
    2dec:	60 e0       	ldi	r22, 0x00	; 0
    2dee:	70 e0       	ldi	r23, 0x00	; 0
    2df0:	40 e0       	ldi	r20, 0x00	; 0
    2df2:	50 e0       	ldi	r21, 0x00	; 0
    2df4:	20 e0       	ldi	r18, 0x00	; 0
    2df6:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    2dfa:	a7 cf       	rjmp	.-178    	; 0x2d4a <T_EventTerm+0x60>
					}
				}	
				break;		
				case SS_CONFIG:
				{
					if(ch == 'O')
    2dfc:	89 81       	ldd	r24, Y+1	; 0x01
    2dfe:	8f 34       	cpi	r24, 0x4F	; 79
    2e00:	e9 f4       	brne	.+58     	; 0x2e3c <T_EventTerm+0x152>
					{
						TAS.TTemp = recTTemp;
    2e02:	6a 81       	ldd	r22, Y+2	; 0x02
    2e04:	f6 01       	movw	r30, r12
    2e06:	60 83       	st	Z, r22
						EEPROM_Update(EEPROM_THRESOLD_ADDRESS,TAS.TTemp);
    2e08:	81 e0       	ldi	r24, 0x01	; 1
    2e0a:	90 e0       	ldi	r25, 0x00	; 0
    2e0c:	0e 94 ff 00 	call	0x1fe	; 0x1fe <EEPROM_Update>
						TAS.SysState = SS_MAIN;
    2e10:	f3 01       	movw	r30, r6
    2e12:	10 82       	st	Z, r1
						xEventGroupSetBits(egEvents,(E_MAIN_SCREEN|E_CTEMP_UPDATE|E_TTEMP_UPDATE|E_ALARM_STATUS_UPDATE));
    2e14:	80 91 35 07 	lds	r24, 0x0735
    2e18:	90 91 36 07 	lds	r25, 0x0736
    2e1c:	69 e5       	ldi	r22, 0x59	; 89
    2e1e:	70 e0       	ldi	r23, 0x00	; 0
    2e20:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
						xSemaphoreGive(bsCheck);
    2e24:	80 91 33 07 	lds	r24, 0x0733
    2e28:	90 91 34 07 	lds	r25, 0x0734
    2e2c:	60 e0       	ldi	r22, 0x00	; 0
    2e2e:	70 e0       	ldi	r23, 0x00	; 0
    2e30:	40 e0       	ldi	r20, 0x00	; 0
    2e32:	50 e0       	ldi	r21, 0x00	; 0
    2e34:	20 e0       	ldi	r18, 0x00	; 0
    2e36:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    2e3a:	87 cf       	rjmp	.-242    	; 0x2d4a <T_EventTerm+0x60>
					}
					else if(ch == 'C')
    2e3c:	83 34       	cpi	r24, 0x43	; 67
    2e3e:	59 f4       	brne	.+22     	; 0x2e56 <T_EventTerm+0x16c>
					{
						TAS.SysState = SS_MAIN;
    2e40:	f8 01       	movw	r30, r16
    2e42:	10 82       	st	Z, r1
						xEventGroupSetBits(egEvents,(E_MAIN_SCREEN|E_CTEMP_UPDATE|E_TTEMP_UPDATE|E_ALARM_STATUS_UPDATE));
    2e44:	80 91 35 07 	lds	r24, 0x0735
    2e48:	90 91 36 07 	lds	r25, 0x0736
    2e4c:	69 e5       	ldi	r22, 0x59	; 89
    2e4e:	70 e0       	ldi	r23, 0x00	; 0
    2e50:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
    2e54:	7a cf       	rjmp	.-268    	; 0x2d4a <T_EventTerm+0x60>
					}
					else if( ch >= '0' && ch <= '9' && digitCounter < 3)
    2e56:	98 2f       	mov	r25, r24
    2e58:	90 53       	subi	r25, 0x30	; 48
    2e5a:	9a 30       	cpi	r25, 0x0A	; 10
    2e5c:	08 f0       	brcs	.+2      	; 0x2e60 <T_EventTerm+0x176>
    2e5e:	75 cf       	rjmp	.-278    	; 0x2d4a <T_EventTerm+0x60>
    2e60:	20 91 30 07 	lds	r18, 0x0730
    2e64:	23 30       	cpi	r18, 0x03	; 3
    2e66:	08 f0       	brcs	.+2      	; 0x2e6a <T_EventTerm+0x180>
    2e68:	70 cf       	rjmp	.-288    	; 0x2d4a <T_EventTerm+0x60>
					{
						digitCounter++;
    2e6a:	2f 5f       	subi	r18, 0xFF	; 255
    2e6c:	20 93 30 07 	sts	0x0730, r18
						recTTemp = recTTemp*10 + (ch - '0');
    2e70:	2a 81       	ldd	r18, Y+2	; 0x02
    2e72:	22 0f       	add	r18, r18
    2e74:	32 2f       	mov	r19, r18
    2e76:	33 0f       	add	r19, r19
    2e78:	33 0f       	add	r19, r19
    2e7a:	23 0f       	add	r18, r19
    2e7c:	92 0f       	add	r25, r18
    2e7e:	9a 83       	std	Y+2, r25	; 0x02
						digitValue = ch;
    2e80:	80 93 2f 07 	sts	0x072F, r24
						xEventGroupSetBits(egEvents,E_TTEMP_DIGIT_DISP);
    2e84:	80 91 35 07 	lds	r24, 0x0735
    2e88:	90 91 36 07 	lds	r25, 0x0736
    2e8c:	60 e2       	ldi	r22, 0x20	; 32
    2e8e:	70 e0       	ldi	r23, 0x00	; 0
    2e90:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
    2e94:	5a cf       	rjmp	.-332    	; 0x2d4a <T_EventTerm+0x60>

00002e96 <T_UserTerm>:
		}
	}
}

void T_UserTerm(void* ptr)
{
    2e96:	cf 93       	push	r28
    2e98:	df 93       	push	r29
    2e9a:	0f 92       	push	r0
    2e9c:	cd b7       	in	r28, 0x3d	; 61
    2e9e:	de b7       	in	r29, 0x3e	; 62
	u8 ch = 0;
    2ea0:	19 82       	std	Y+1, r1	; 0x01
	Uart_SendStr("T_UserTerm Started ...\r\n");
    2ea2:	8b e5       	ldi	r24, 0x5B	; 91
    2ea4:	91 e0       	ldi	r25, 0x01	; 1
    2ea6:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
	while(1){
		if(Uart_ReceiveByte_Unblock(&ch))
    2eaa:	ce 01       	movw	r24, r28
    2eac:	01 96       	adiw	r24, 0x01	; 1
    2eae:	0e 94 2e 02 	call	0x45c	; 0x45c <Uart_ReceiveByte_Unblock>
    2eb2:	88 23       	and	r24, r24
    2eb4:	61 f0       	breq	.+24     	; 0x2ece <T_UserTerm+0x38>
		{
			xQueueSend(TRM_Queue, &ch, portMAX_DELAY);
    2eb6:	80 91 31 07 	lds	r24, 0x0731
    2eba:	90 91 32 07 	lds	r25, 0x0732
    2ebe:	be 01       	movw	r22, r28
    2ec0:	6f 5f       	subi	r22, 0xFF	; 255
    2ec2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec4:	4f ef       	ldi	r20, 0xFF	; 255
    2ec6:	5f ef       	ldi	r21, 0xFF	; 255
    2ec8:	20 e0       	ldi	r18, 0x00	; 0
    2eca:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
		}
		vTaskDelay(100);
    2ece:	84 e6       	ldi	r24, 0x64	; 100
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	0e 94 83 12 	call	0x2506	; 0x2506 <vTaskDelay>
	}
    2ed6:	e9 cf       	rjmp	.-46     	; 0x2eaa <T_UserTerm+0x14>

00002ed8 <system_init>:
	xEventGroupSetBits(egEvents,(E_MAIN_SCREEN|E_CTEMP_UPDATE|E_TTEMP_UPDATE|E_ALARM_STATUS_UPDATE));
	/* start os */
	vTaskStartScheduler();
}
void system_init(void){
	Buz_Init();
    2ed8:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <Buz_Init>
	ADC_Init();
    2edc:	0e 94 49 00 	call	0x92	; 0x92 <ADC_Init>
	LCD_Init();
    2ee0:	0e 94 73 01 	call	0x2e6	; 0x2e6 <LCD_Init>
	Uart_Init(9600);
    2ee4:	60 e8       	ldi	r22, 0x80	; 128
    2ee6:	75 e2       	ldi	r23, 0x25	; 37
    2ee8:	80 e0       	ldi	r24, 0x00	; 0
    2eea:	90 e0       	ldi	r25, 0x00	; 0
    2eec:	0e 94 f7 01 	call	0x3ee	; 0x3ee <Uart_Init>
	Uart_SendStr("System Started ...\r\n");
    2ef0:	88 e7       	ldi	r24, 0x78	; 120
    2ef2:	91 e0       	ldi	r25, 0x01	; 1
    2ef4:	0e 94 37 02 	call	0x46e	; 0x46e <Uart_SendStr>
	Int_EEPROM_Read(EEPROM_THRESOLD_ADDRESS,&TAS.TTemp);
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	67 e7       	ldi	r22, 0x77	; 119
    2efe:	71 e0       	ldi	r23, 0x01	; 1
    2f00:	0e 94 ef 00 	call	0x1de	; 0x1de <Int_EEPROM_Read>
}
    2f04:	08 95       	ret

00002f06 <main>:
xSemaphoreHandle 	bsCheck 	= NULL;
xQueueHandle		TRM_Queue   = NULL;

extern TAS_t	TAS ;

void main(void){
    2f06:	af 92       	push	r10
    2f08:	bf 92       	push	r11
    2f0a:	cf 92       	push	r12
    2f0c:	df 92       	push	r13
    2f0e:	ef 92       	push	r14
    2f10:	ff 92       	push	r15
    2f12:	0f 93       	push	r16
	/* Init system */
	system_init();
    2f14:	0e 94 6c 17 	call	0x2ed8	; 0x2ed8 <system_init>
	/*Create OS Objects*/
	bsCheck = xSemaphoreCreateBinary();
    2f18:	81 e0       	ldi	r24, 0x01	; 1
    2f1a:	60 e0       	ldi	r22, 0x00	; 0
    2f1c:	43 e0       	ldi	r20, 0x03	; 3
    2f1e:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <xQueueGenericCreate>
    2f22:	90 93 34 07 	sts	0x0734, r25
    2f26:	80 93 33 07 	sts	0x0733, r24
	TRM_Queue = xQueueCreate(10,1);
    2f2a:	8a e0       	ldi	r24, 0x0A	; 10
    2f2c:	61 e0       	ldi	r22, 0x01	; 1
    2f2e:	40 e0       	ldi	r20, 0x00	; 0
    2f30:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <xQueueGenericCreate>
    2f34:	90 93 32 07 	sts	0x0732, r25
    2f38:	80 93 31 07 	sts	0x0731, r24
	egEvents = xEventGroupCreate();
    2f3c:	0e 94 9f 04 	call	0x93e	; 0x93e <xEventGroupCreate>
    2f40:	90 93 36 07 	sts	0x0736, r25
    2f44:	80 93 35 07 	sts	0x0735, r24
	/*Create tasks*/
	xTaskCreate(T_Alarm,	"T_Alarm",		100,NULL,6,&th_T_Alarm);
    2f48:	83 e4       	ldi	r24, 0x43	; 67
    2f4a:	95 e1       	ldi	r25, 0x15	; 21
    2f4c:	6d e8       	ldi	r22, 0x8D	; 141
    2f4e:	71 e0       	ldi	r23, 0x01	; 1
    2f50:	44 e6       	ldi	r20, 0x64	; 100
    2f52:	50 e0       	ldi	r21, 0x00	; 0
    2f54:	20 e0       	ldi	r18, 0x00	; 0
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	06 e0       	ldi	r16, 0x06	; 6
    2f5a:	0f 2e       	mov	r0, r31
    2f5c:	f1 e4       	ldi	r31, 0x41	; 65
    2f5e:	ef 2e       	mov	r14, r31
    2f60:	f7 e0       	ldi	r31, 0x07	; 7
    2f62:	ff 2e       	mov	r15, r31
    2f64:	f0 2d       	mov	r31, r0
    2f66:	cc 24       	eor	r12, r12
    2f68:	dd 24       	eor	r13, r13
    2f6a:	aa 24       	eor	r10, r10
    2f6c:	bb 24       	eor	r11, r11
    2f6e:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	xTaskCreate(T_UserTerm,	"T_UserTerm",	100,NULL,5,&th_T_UserTerm);
    2f72:	8b e4       	ldi	r24, 0x4B	; 75
    2f74:	97 e1       	ldi	r25, 0x17	; 23
    2f76:	65 e9       	ldi	r22, 0x95	; 149
    2f78:	71 e0       	ldi	r23, 0x01	; 1
    2f7a:	44 e6       	ldi	r20, 0x64	; 100
    2f7c:	50 e0       	ldi	r21, 0x00	; 0
    2f7e:	20 e0       	ldi	r18, 0x00	; 0
    2f80:	30 e0       	ldi	r19, 0x00	; 0
    2f82:	05 e0       	ldi	r16, 0x05	; 5
    2f84:	0f 2e       	mov	r0, r31
    2f86:	fb e3       	ldi	r31, 0x3B	; 59
    2f88:	ef 2e       	mov	r14, r31
    2f8a:	f7 e0       	ldi	r31, 0x07	; 7
    2f8c:	ff 2e       	mov	r15, r31
    2f8e:	f0 2d       	mov	r31, r0
    2f90:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	xTaskCreate(T_EventTerm,"T_EventTerm",	100,NULL,4,&th_T_EventTerm);
    2f94:	85 e7       	ldi	r24, 0x75	; 117
    2f96:	96 e1       	ldi	r25, 0x16	; 22
    2f98:	60 ea       	ldi	r22, 0xA0	; 160
    2f9a:	71 e0       	ldi	r23, 0x01	; 1
    2f9c:	44 e6       	ldi	r20, 0x64	; 100
    2f9e:	50 e0       	ldi	r21, 0x00	; 0
    2fa0:	20 e0       	ldi	r18, 0x00	; 0
    2fa2:	30 e0       	ldi	r19, 0x00	; 0
    2fa4:	04 e0       	ldi	r16, 0x04	; 4
    2fa6:	0f 2e       	mov	r0, r31
    2fa8:	fd e3       	ldi	r31, 0x3D	; 61
    2faa:	ef 2e       	mov	r14, r31
    2fac:	f7 e0       	ldi	r31, 0x07	; 7
    2fae:	ff 2e       	mov	r15, r31
    2fb0:	f0 2d       	mov	r31, r0
    2fb2:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	xTaskCreate(T_SysCheck,	"T_SysCheck",	100,NULL,3,&th_T_SysCheck);
    2fb6:	89 ea       	ldi	r24, 0xA9	; 169
    2fb8:	95 e1       	ldi	r25, 0x15	; 21
    2fba:	6c ea       	ldi	r22, 0xAC	; 172
    2fbc:	71 e0       	ldi	r23, 0x01	; 1
    2fbe:	44 e6       	ldi	r20, 0x64	; 100
    2fc0:	50 e0       	ldi	r21, 0x00	; 0
    2fc2:	20 e0       	ldi	r18, 0x00	; 0
    2fc4:	30 e0       	ldi	r19, 0x00	; 0
    2fc6:	03 e0       	ldi	r16, 0x03	; 3
    2fc8:	0f 2e       	mov	r0, r31
    2fca:	ff e3       	ldi	r31, 0x3F	; 63
    2fcc:	ef 2e       	mov	r14, r31
    2fce:	f7 e0       	ldi	r31, 0x07	; 7
    2fd0:	ff 2e       	mov	r15, r31
    2fd2:	f0 2d       	mov	r31, r0
    2fd4:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	xTaskCreate(T_Temp,		"T_Temp",		100,NULL,2,&th_T_Temp);
    2fd8:	82 e6       	ldi	r24, 0x62	; 98
    2fda:	95 e1       	ldi	r25, 0x15	; 21
    2fdc:	67 eb       	ldi	r22, 0xB7	; 183
    2fde:	71 e0       	ldi	r23, 0x01	; 1
    2fe0:	44 e6       	ldi	r20, 0x64	; 100
    2fe2:	50 e0       	ldi	r21, 0x00	; 0
    2fe4:	20 e0       	ldi	r18, 0x00	; 0
    2fe6:	30 e0       	ldi	r19, 0x00	; 0
    2fe8:	02 e0       	ldi	r16, 0x02	; 2
    2fea:	0f 2e       	mov	r0, r31
    2fec:	f9 e3       	ldi	r31, 0x39	; 57
    2fee:	ef 2e       	mov	r14, r31
    2ff0:	f7 e0       	ldi	r31, 0x07	; 7
    2ff2:	ff 2e       	mov	r15, r31
    2ff4:	f0 2d       	mov	r31, r0
    2ff6:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	xTaskCreate(T_Display,	"T_Display",	100,NULL,1,&th_T_Display);
    2ffa:	84 e0       	ldi	r24, 0x04	; 4
    2ffc:	96 e1       	ldi	r25, 0x16	; 22
    2ffe:	6e eb       	ldi	r22, 0xBE	; 190
    3000:	71 e0       	ldi	r23, 0x01	; 1
    3002:	44 e6       	ldi	r20, 0x64	; 100
    3004:	50 e0       	ldi	r21, 0x00	; 0
    3006:	20 e0       	ldi	r18, 0x00	; 0
    3008:	30 e0       	ldi	r19, 0x00	; 0
    300a:	01 e0       	ldi	r16, 0x01	; 1
    300c:	0f 2e       	mov	r0, r31
    300e:	f7 e3       	ldi	r31, 0x37	; 55
    3010:	ef 2e       	mov	r14, r31
    3012:	f7 e0       	ldi	r31, 0x07	; 7
    3014:	ff 2e       	mov	r15, r31
    3016:	f0 2d       	mov	r31, r0
    3018:	0e 94 c4 0e 	call	0x1d88	; 0x1d88 <xTaskGenericCreate>
	/* os services init */
	xEventGroupSetBits(egEvents,(E_MAIN_SCREEN|E_CTEMP_UPDATE|E_TTEMP_UPDATE|E_ALARM_STATUS_UPDATE));
    301c:	80 91 35 07 	lds	r24, 0x0735
    3020:	90 91 36 07 	lds	r25, 0x0736
    3024:	69 e5       	ldi	r22, 0x59	; 89
    3026:	70 e0       	ldi	r23, 0x00	; 0
    3028:	0e 94 32 05 	call	0xa64	; 0xa64 <xEventGroupSetBits>
	/* start os */
	vTaskStartScheduler();
    302c:	0e 94 bb 10 	call	0x2176	; 0x2176 <vTaskStartScheduler>
}
    3030:	0f 91       	pop	r16
    3032:	ff 90       	pop	r15
    3034:	ef 90       	pop	r14
    3036:	df 90       	pop	r13
    3038:	cf 90       	pop	r12
    303a:	bf 90       	pop	r11
    303c:	af 90       	pop	r10
    303e:	08 95       	ret

00003040 <__divsf3>:
    3040:	0c d0       	rcall	.+24     	; 0x305a <__divsf3x>
    3042:	e6 c0       	rjmp	.+460    	; 0x3210 <__fp_round>
    3044:	de d0       	rcall	.+444    	; 0x3202 <__fp_pscB>
    3046:	40 f0       	brcs	.+16     	; 0x3058 <__divsf3+0x18>
    3048:	d5 d0       	rcall	.+426    	; 0x31f4 <__fp_pscA>
    304a:	30 f0       	brcs	.+12     	; 0x3058 <__divsf3+0x18>
    304c:	21 f4       	brne	.+8      	; 0x3056 <__divsf3+0x16>
    304e:	5f 3f       	cpi	r21, 0xFF	; 255
    3050:	19 f0       	breq	.+6      	; 0x3058 <__divsf3+0x18>
    3052:	c7 c0       	rjmp	.+398    	; 0x31e2 <__fp_inf>
    3054:	51 11       	cpse	r21, r1
    3056:	10 c1       	rjmp	.+544    	; 0x3278 <__fp_szero>
    3058:	ca c0       	rjmp	.+404    	; 0x31ee <__fp_nan>

0000305a <__divsf3x>:
    305a:	eb d0       	rcall	.+470    	; 0x3232 <__fp_split3>
    305c:	98 f3       	brcs	.-26     	; 0x3044 <__divsf3+0x4>

0000305e <__divsf3_pse>:
    305e:	99 23       	and	r25, r25
    3060:	c9 f3       	breq	.-14     	; 0x3054 <__divsf3+0x14>
    3062:	55 23       	and	r21, r21
    3064:	b1 f3       	breq	.-20     	; 0x3052 <__divsf3+0x12>
    3066:	95 1b       	sub	r25, r21
    3068:	55 0b       	sbc	r21, r21
    306a:	bb 27       	eor	r27, r27
    306c:	aa 27       	eor	r26, r26
    306e:	62 17       	cp	r22, r18
    3070:	73 07       	cpc	r23, r19
    3072:	84 07       	cpc	r24, r20
    3074:	38 f0       	brcs	.+14     	; 0x3084 <__divsf3_pse+0x26>
    3076:	9f 5f       	subi	r25, 0xFF	; 255
    3078:	5f 4f       	sbci	r21, 0xFF	; 255
    307a:	22 0f       	add	r18, r18
    307c:	33 1f       	adc	r19, r19
    307e:	44 1f       	adc	r20, r20
    3080:	aa 1f       	adc	r26, r26
    3082:	a9 f3       	breq	.-22     	; 0x306e <__divsf3_pse+0x10>
    3084:	33 d0       	rcall	.+102    	; 0x30ec <__divsf3_pse+0x8e>
    3086:	0e 2e       	mov	r0, r30
    3088:	3a f0       	brmi	.+14     	; 0x3098 <__divsf3_pse+0x3a>
    308a:	e0 e8       	ldi	r30, 0x80	; 128
    308c:	30 d0       	rcall	.+96     	; 0x30ee <__divsf3_pse+0x90>
    308e:	91 50       	subi	r25, 0x01	; 1
    3090:	50 40       	sbci	r21, 0x00	; 0
    3092:	e6 95       	lsr	r30
    3094:	00 1c       	adc	r0, r0
    3096:	ca f7       	brpl	.-14     	; 0x308a <__divsf3_pse+0x2c>
    3098:	29 d0       	rcall	.+82     	; 0x30ec <__divsf3_pse+0x8e>
    309a:	fe 2f       	mov	r31, r30
    309c:	27 d0       	rcall	.+78     	; 0x30ec <__divsf3_pse+0x8e>
    309e:	66 0f       	add	r22, r22
    30a0:	77 1f       	adc	r23, r23
    30a2:	88 1f       	adc	r24, r24
    30a4:	bb 1f       	adc	r27, r27
    30a6:	26 17       	cp	r18, r22
    30a8:	37 07       	cpc	r19, r23
    30aa:	48 07       	cpc	r20, r24
    30ac:	ab 07       	cpc	r26, r27
    30ae:	b0 e8       	ldi	r27, 0x80	; 128
    30b0:	09 f0       	breq	.+2      	; 0x30b4 <__divsf3_pse+0x56>
    30b2:	bb 0b       	sbc	r27, r27
    30b4:	80 2d       	mov	r24, r0
    30b6:	bf 01       	movw	r22, r30
    30b8:	ff 27       	eor	r31, r31
    30ba:	93 58       	subi	r25, 0x83	; 131
    30bc:	5f 4f       	sbci	r21, 0xFF	; 255
    30be:	2a f0       	brmi	.+10     	; 0x30ca <__divsf3_pse+0x6c>
    30c0:	9e 3f       	cpi	r25, 0xFE	; 254
    30c2:	51 05       	cpc	r21, r1
    30c4:	68 f0       	brcs	.+26     	; 0x30e0 <__divsf3_pse+0x82>
    30c6:	8d c0       	rjmp	.+282    	; 0x31e2 <__fp_inf>
    30c8:	d7 c0       	rjmp	.+430    	; 0x3278 <__fp_szero>
    30ca:	5f 3f       	cpi	r21, 0xFF	; 255
    30cc:	ec f3       	brlt	.-6      	; 0x30c8 <__divsf3_pse+0x6a>
    30ce:	98 3e       	cpi	r25, 0xE8	; 232
    30d0:	dc f3       	brlt	.-10     	; 0x30c8 <__divsf3_pse+0x6a>
    30d2:	86 95       	lsr	r24
    30d4:	77 95       	ror	r23
    30d6:	67 95       	ror	r22
    30d8:	b7 95       	ror	r27
    30da:	f7 95       	ror	r31
    30dc:	9f 5f       	subi	r25, 0xFF	; 255
    30de:	c9 f7       	brne	.-14     	; 0x30d2 <__divsf3_pse+0x74>
    30e0:	88 0f       	add	r24, r24
    30e2:	91 1d       	adc	r25, r1
    30e4:	96 95       	lsr	r25
    30e6:	87 95       	ror	r24
    30e8:	97 f9       	bld	r25, 7
    30ea:	08 95       	ret
    30ec:	e1 e0       	ldi	r30, 0x01	; 1
    30ee:	66 0f       	add	r22, r22
    30f0:	77 1f       	adc	r23, r23
    30f2:	88 1f       	adc	r24, r24
    30f4:	bb 1f       	adc	r27, r27
    30f6:	62 17       	cp	r22, r18
    30f8:	73 07       	cpc	r23, r19
    30fa:	84 07       	cpc	r24, r20
    30fc:	ba 07       	cpc	r27, r26
    30fe:	20 f0       	brcs	.+8      	; 0x3108 <__divsf3_pse+0xaa>
    3100:	62 1b       	sub	r22, r18
    3102:	73 0b       	sbc	r23, r19
    3104:	84 0b       	sbc	r24, r20
    3106:	ba 0b       	sbc	r27, r26
    3108:	ee 1f       	adc	r30, r30
    310a:	88 f7       	brcc	.-30     	; 0x30ee <__divsf3_pse+0x90>
    310c:	e0 95       	com	r30
    310e:	08 95       	ret

00003110 <__fixunssfsi>:
    3110:	98 d0       	rcall	.+304    	; 0x3242 <__fp_splitA>
    3112:	88 f0       	brcs	.+34     	; 0x3136 <__fixunssfsi+0x26>
    3114:	9f 57       	subi	r25, 0x7F	; 127
    3116:	90 f0       	brcs	.+36     	; 0x313c <__fixunssfsi+0x2c>
    3118:	b9 2f       	mov	r27, r25
    311a:	99 27       	eor	r25, r25
    311c:	b7 51       	subi	r27, 0x17	; 23
    311e:	a0 f0       	brcs	.+40     	; 0x3148 <__fixunssfsi+0x38>
    3120:	d1 f0       	breq	.+52     	; 0x3156 <__fixunssfsi+0x46>
    3122:	66 0f       	add	r22, r22
    3124:	77 1f       	adc	r23, r23
    3126:	88 1f       	adc	r24, r24
    3128:	99 1f       	adc	r25, r25
    312a:	1a f0       	brmi	.+6      	; 0x3132 <__fixunssfsi+0x22>
    312c:	ba 95       	dec	r27
    312e:	c9 f7       	brne	.-14     	; 0x3122 <__fixunssfsi+0x12>
    3130:	12 c0       	rjmp	.+36     	; 0x3156 <__fixunssfsi+0x46>
    3132:	b1 30       	cpi	r27, 0x01	; 1
    3134:	81 f0       	breq	.+32     	; 0x3156 <__fixunssfsi+0x46>
    3136:	9f d0       	rcall	.+318    	; 0x3276 <__fp_zero>
    3138:	b1 e0       	ldi	r27, 0x01	; 1
    313a:	08 95       	ret
    313c:	9c c0       	rjmp	.+312    	; 0x3276 <__fp_zero>
    313e:	67 2f       	mov	r22, r23
    3140:	78 2f       	mov	r23, r24
    3142:	88 27       	eor	r24, r24
    3144:	b8 5f       	subi	r27, 0xF8	; 248
    3146:	39 f0       	breq	.+14     	; 0x3156 <__fixunssfsi+0x46>
    3148:	b9 3f       	cpi	r27, 0xF9	; 249
    314a:	cc f3       	brlt	.-14     	; 0x313e <__fixunssfsi+0x2e>
    314c:	86 95       	lsr	r24
    314e:	77 95       	ror	r23
    3150:	67 95       	ror	r22
    3152:	b3 95       	inc	r27
    3154:	d9 f7       	brne	.-10     	; 0x314c <__fixunssfsi+0x3c>
    3156:	3e f4       	brtc	.+14     	; 0x3166 <__fixunssfsi+0x56>
    3158:	90 95       	com	r25
    315a:	80 95       	com	r24
    315c:	70 95       	com	r23
    315e:	61 95       	neg	r22
    3160:	7f 4f       	sbci	r23, 0xFF	; 255
    3162:	8f 4f       	sbci	r24, 0xFF	; 255
    3164:	9f 4f       	sbci	r25, 0xFF	; 255
    3166:	08 95       	ret

00003168 <__floatunsisf>:
    3168:	e8 94       	clt
    316a:	09 c0       	rjmp	.+18     	; 0x317e <__floatsisf+0x12>

0000316c <__floatsisf>:
    316c:	97 fb       	bst	r25, 7
    316e:	3e f4       	brtc	.+14     	; 0x317e <__floatsisf+0x12>
    3170:	90 95       	com	r25
    3172:	80 95       	com	r24
    3174:	70 95       	com	r23
    3176:	61 95       	neg	r22
    3178:	7f 4f       	sbci	r23, 0xFF	; 255
    317a:	8f 4f       	sbci	r24, 0xFF	; 255
    317c:	9f 4f       	sbci	r25, 0xFF	; 255
    317e:	99 23       	and	r25, r25
    3180:	a9 f0       	breq	.+42     	; 0x31ac <__floatsisf+0x40>
    3182:	f9 2f       	mov	r31, r25
    3184:	96 e9       	ldi	r25, 0x96	; 150
    3186:	bb 27       	eor	r27, r27
    3188:	93 95       	inc	r25
    318a:	f6 95       	lsr	r31
    318c:	87 95       	ror	r24
    318e:	77 95       	ror	r23
    3190:	67 95       	ror	r22
    3192:	b7 95       	ror	r27
    3194:	f1 11       	cpse	r31, r1
    3196:	f8 cf       	rjmp	.-16     	; 0x3188 <__floatsisf+0x1c>
    3198:	fa f4       	brpl	.+62     	; 0x31d8 <__floatsisf+0x6c>
    319a:	bb 0f       	add	r27, r27
    319c:	11 f4       	brne	.+4      	; 0x31a2 <__floatsisf+0x36>
    319e:	60 ff       	sbrs	r22, 0
    31a0:	1b c0       	rjmp	.+54     	; 0x31d8 <__floatsisf+0x6c>
    31a2:	6f 5f       	subi	r22, 0xFF	; 255
    31a4:	7f 4f       	sbci	r23, 0xFF	; 255
    31a6:	8f 4f       	sbci	r24, 0xFF	; 255
    31a8:	9f 4f       	sbci	r25, 0xFF	; 255
    31aa:	16 c0       	rjmp	.+44     	; 0x31d8 <__floatsisf+0x6c>
    31ac:	88 23       	and	r24, r24
    31ae:	11 f0       	breq	.+4      	; 0x31b4 <__floatsisf+0x48>
    31b0:	96 e9       	ldi	r25, 0x96	; 150
    31b2:	11 c0       	rjmp	.+34     	; 0x31d6 <__floatsisf+0x6a>
    31b4:	77 23       	and	r23, r23
    31b6:	21 f0       	breq	.+8      	; 0x31c0 <__floatsisf+0x54>
    31b8:	9e e8       	ldi	r25, 0x8E	; 142
    31ba:	87 2f       	mov	r24, r23
    31bc:	76 2f       	mov	r23, r22
    31be:	05 c0       	rjmp	.+10     	; 0x31ca <__floatsisf+0x5e>
    31c0:	66 23       	and	r22, r22
    31c2:	71 f0       	breq	.+28     	; 0x31e0 <__floatsisf+0x74>
    31c4:	96 e8       	ldi	r25, 0x86	; 134
    31c6:	86 2f       	mov	r24, r22
    31c8:	70 e0       	ldi	r23, 0x00	; 0
    31ca:	60 e0       	ldi	r22, 0x00	; 0
    31cc:	2a f0       	brmi	.+10     	; 0x31d8 <__floatsisf+0x6c>
    31ce:	9a 95       	dec	r25
    31d0:	66 0f       	add	r22, r22
    31d2:	77 1f       	adc	r23, r23
    31d4:	88 1f       	adc	r24, r24
    31d6:	da f7       	brpl	.-10     	; 0x31ce <__floatsisf+0x62>
    31d8:	88 0f       	add	r24, r24
    31da:	96 95       	lsr	r25
    31dc:	87 95       	ror	r24
    31de:	97 f9       	bld	r25, 7
    31e0:	08 95       	ret

000031e2 <__fp_inf>:
    31e2:	97 f9       	bld	r25, 7
    31e4:	9f 67       	ori	r25, 0x7F	; 127
    31e6:	80 e8       	ldi	r24, 0x80	; 128
    31e8:	70 e0       	ldi	r23, 0x00	; 0
    31ea:	60 e0       	ldi	r22, 0x00	; 0
    31ec:	08 95       	ret

000031ee <__fp_nan>:
    31ee:	9f ef       	ldi	r25, 0xFF	; 255
    31f0:	80 ec       	ldi	r24, 0xC0	; 192
    31f2:	08 95       	ret

000031f4 <__fp_pscA>:
    31f4:	00 24       	eor	r0, r0
    31f6:	0a 94       	dec	r0
    31f8:	16 16       	cp	r1, r22
    31fa:	17 06       	cpc	r1, r23
    31fc:	18 06       	cpc	r1, r24
    31fe:	09 06       	cpc	r0, r25
    3200:	08 95       	ret

00003202 <__fp_pscB>:
    3202:	00 24       	eor	r0, r0
    3204:	0a 94       	dec	r0
    3206:	12 16       	cp	r1, r18
    3208:	13 06       	cpc	r1, r19
    320a:	14 06       	cpc	r1, r20
    320c:	05 06       	cpc	r0, r21
    320e:	08 95       	ret

00003210 <__fp_round>:
    3210:	09 2e       	mov	r0, r25
    3212:	03 94       	inc	r0
    3214:	00 0c       	add	r0, r0
    3216:	11 f4       	brne	.+4      	; 0x321c <__fp_round+0xc>
    3218:	88 23       	and	r24, r24
    321a:	52 f0       	brmi	.+20     	; 0x3230 <__fp_round+0x20>
    321c:	bb 0f       	add	r27, r27
    321e:	40 f4       	brcc	.+16     	; 0x3230 <__fp_round+0x20>
    3220:	bf 2b       	or	r27, r31
    3222:	11 f4       	brne	.+4      	; 0x3228 <__fp_round+0x18>
    3224:	60 ff       	sbrs	r22, 0
    3226:	04 c0       	rjmp	.+8      	; 0x3230 <__fp_round+0x20>
    3228:	6f 5f       	subi	r22, 0xFF	; 255
    322a:	7f 4f       	sbci	r23, 0xFF	; 255
    322c:	8f 4f       	sbci	r24, 0xFF	; 255
    322e:	9f 4f       	sbci	r25, 0xFF	; 255
    3230:	08 95       	ret

00003232 <__fp_split3>:
    3232:	57 fd       	sbrc	r21, 7
    3234:	90 58       	subi	r25, 0x80	; 128
    3236:	44 0f       	add	r20, r20
    3238:	55 1f       	adc	r21, r21
    323a:	59 f0       	breq	.+22     	; 0x3252 <__fp_splitA+0x10>
    323c:	5f 3f       	cpi	r21, 0xFF	; 255
    323e:	71 f0       	breq	.+28     	; 0x325c <__fp_splitA+0x1a>
    3240:	47 95       	ror	r20

00003242 <__fp_splitA>:
    3242:	88 0f       	add	r24, r24
    3244:	97 fb       	bst	r25, 7
    3246:	99 1f       	adc	r25, r25
    3248:	61 f0       	breq	.+24     	; 0x3262 <__fp_splitA+0x20>
    324a:	9f 3f       	cpi	r25, 0xFF	; 255
    324c:	79 f0       	breq	.+30     	; 0x326c <__fp_splitA+0x2a>
    324e:	87 95       	ror	r24
    3250:	08 95       	ret
    3252:	12 16       	cp	r1, r18
    3254:	13 06       	cpc	r1, r19
    3256:	14 06       	cpc	r1, r20
    3258:	55 1f       	adc	r21, r21
    325a:	f2 cf       	rjmp	.-28     	; 0x3240 <__fp_split3+0xe>
    325c:	46 95       	lsr	r20
    325e:	f1 df       	rcall	.-30     	; 0x3242 <__fp_splitA>
    3260:	08 c0       	rjmp	.+16     	; 0x3272 <__fp_splitA+0x30>
    3262:	16 16       	cp	r1, r22
    3264:	17 06       	cpc	r1, r23
    3266:	18 06       	cpc	r1, r24
    3268:	99 1f       	adc	r25, r25
    326a:	f1 cf       	rjmp	.-30     	; 0x324e <__fp_splitA+0xc>
    326c:	86 95       	lsr	r24
    326e:	71 05       	cpc	r23, r1
    3270:	61 05       	cpc	r22, r1
    3272:	08 94       	sec
    3274:	08 95       	ret

00003276 <__fp_zero>:
    3276:	e8 94       	clt

00003278 <__fp_szero>:
    3278:	bb 27       	eor	r27, r27
    327a:	66 27       	eor	r22, r22
    327c:	77 27       	eor	r23, r23
    327e:	cb 01       	movw	r24, r22
    3280:	97 f9       	bld	r25, 7
    3282:	08 95       	ret

00003284 <__mulsf3>:
    3284:	0b d0       	rcall	.+22     	; 0x329c <__mulsf3x>
    3286:	c4 cf       	rjmp	.-120    	; 0x3210 <__fp_round>
    3288:	b5 df       	rcall	.-150    	; 0x31f4 <__fp_pscA>
    328a:	28 f0       	brcs	.+10     	; 0x3296 <__mulsf3+0x12>
    328c:	ba df       	rcall	.-140    	; 0x3202 <__fp_pscB>
    328e:	18 f0       	brcs	.+6      	; 0x3296 <__mulsf3+0x12>
    3290:	95 23       	and	r25, r21
    3292:	09 f0       	breq	.+2      	; 0x3296 <__mulsf3+0x12>
    3294:	a6 cf       	rjmp	.-180    	; 0x31e2 <__fp_inf>
    3296:	ab cf       	rjmp	.-170    	; 0x31ee <__fp_nan>
    3298:	11 24       	eor	r1, r1
    329a:	ee cf       	rjmp	.-36     	; 0x3278 <__fp_szero>

0000329c <__mulsf3x>:
    329c:	ca df       	rcall	.-108    	; 0x3232 <__fp_split3>
    329e:	a0 f3       	brcs	.-24     	; 0x3288 <__mulsf3+0x4>

000032a0 <__mulsf3_pse>:
    32a0:	95 9f       	mul	r25, r21
    32a2:	d1 f3       	breq	.-12     	; 0x3298 <__mulsf3+0x14>
    32a4:	95 0f       	add	r25, r21
    32a6:	50 e0       	ldi	r21, 0x00	; 0
    32a8:	55 1f       	adc	r21, r21
    32aa:	62 9f       	mul	r22, r18
    32ac:	f0 01       	movw	r30, r0
    32ae:	72 9f       	mul	r23, r18
    32b0:	bb 27       	eor	r27, r27
    32b2:	f0 0d       	add	r31, r0
    32b4:	b1 1d       	adc	r27, r1
    32b6:	63 9f       	mul	r22, r19
    32b8:	aa 27       	eor	r26, r26
    32ba:	f0 0d       	add	r31, r0
    32bc:	b1 1d       	adc	r27, r1
    32be:	aa 1f       	adc	r26, r26
    32c0:	64 9f       	mul	r22, r20
    32c2:	66 27       	eor	r22, r22
    32c4:	b0 0d       	add	r27, r0
    32c6:	a1 1d       	adc	r26, r1
    32c8:	66 1f       	adc	r22, r22
    32ca:	82 9f       	mul	r24, r18
    32cc:	22 27       	eor	r18, r18
    32ce:	b0 0d       	add	r27, r0
    32d0:	a1 1d       	adc	r26, r1
    32d2:	62 1f       	adc	r22, r18
    32d4:	73 9f       	mul	r23, r19
    32d6:	b0 0d       	add	r27, r0
    32d8:	a1 1d       	adc	r26, r1
    32da:	62 1f       	adc	r22, r18
    32dc:	83 9f       	mul	r24, r19
    32de:	a0 0d       	add	r26, r0
    32e0:	61 1d       	adc	r22, r1
    32e2:	22 1f       	adc	r18, r18
    32e4:	74 9f       	mul	r23, r20
    32e6:	33 27       	eor	r19, r19
    32e8:	a0 0d       	add	r26, r0
    32ea:	61 1d       	adc	r22, r1
    32ec:	23 1f       	adc	r18, r19
    32ee:	84 9f       	mul	r24, r20
    32f0:	60 0d       	add	r22, r0
    32f2:	21 1d       	adc	r18, r1
    32f4:	82 2f       	mov	r24, r18
    32f6:	76 2f       	mov	r23, r22
    32f8:	6a 2f       	mov	r22, r26
    32fa:	11 24       	eor	r1, r1
    32fc:	9f 57       	subi	r25, 0x7F	; 127
    32fe:	50 40       	sbci	r21, 0x00	; 0
    3300:	8a f0       	brmi	.+34     	; 0x3324 <__mulsf3_pse+0x84>
    3302:	e1 f0       	breq	.+56     	; 0x333c <__mulsf3_pse+0x9c>
    3304:	88 23       	and	r24, r24
    3306:	4a f0       	brmi	.+18     	; 0x331a <__mulsf3_pse+0x7a>
    3308:	ee 0f       	add	r30, r30
    330a:	ff 1f       	adc	r31, r31
    330c:	bb 1f       	adc	r27, r27
    330e:	66 1f       	adc	r22, r22
    3310:	77 1f       	adc	r23, r23
    3312:	88 1f       	adc	r24, r24
    3314:	91 50       	subi	r25, 0x01	; 1
    3316:	50 40       	sbci	r21, 0x00	; 0
    3318:	a9 f7       	brne	.-22     	; 0x3304 <__mulsf3_pse+0x64>
    331a:	9e 3f       	cpi	r25, 0xFE	; 254
    331c:	51 05       	cpc	r21, r1
    331e:	70 f0       	brcs	.+28     	; 0x333c <__mulsf3_pse+0x9c>
    3320:	60 cf       	rjmp	.-320    	; 0x31e2 <__fp_inf>
    3322:	aa cf       	rjmp	.-172    	; 0x3278 <__fp_szero>
    3324:	5f 3f       	cpi	r21, 0xFF	; 255
    3326:	ec f3       	brlt	.-6      	; 0x3322 <__mulsf3_pse+0x82>
    3328:	98 3e       	cpi	r25, 0xE8	; 232
    332a:	dc f3       	brlt	.-10     	; 0x3322 <__mulsf3_pse+0x82>
    332c:	86 95       	lsr	r24
    332e:	77 95       	ror	r23
    3330:	67 95       	ror	r22
    3332:	b7 95       	ror	r27
    3334:	f7 95       	ror	r31
    3336:	e7 95       	ror	r30
    3338:	9f 5f       	subi	r25, 0xFF	; 255
    333a:	c1 f7       	brne	.-16     	; 0x332c <__mulsf3_pse+0x8c>
    333c:	fe 2b       	or	r31, r30
    333e:	88 0f       	add	r24, r24
    3340:	91 1d       	adc	r25, r1
    3342:	96 95       	lsr	r25
    3344:	87 95       	ror	r24
    3346:	97 f9       	bld	r25, 7
    3348:	08 95       	ret

0000334a <__udivmodsi4>:
    334a:	a1 e2       	ldi	r26, 0x21	; 33
    334c:	1a 2e       	mov	r1, r26
    334e:	aa 1b       	sub	r26, r26
    3350:	bb 1b       	sub	r27, r27
    3352:	fd 01       	movw	r30, r26
    3354:	0d c0       	rjmp	.+26     	; 0x3370 <__udivmodsi4_ep>

00003356 <__udivmodsi4_loop>:
    3356:	aa 1f       	adc	r26, r26
    3358:	bb 1f       	adc	r27, r27
    335a:	ee 1f       	adc	r30, r30
    335c:	ff 1f       	adc	r31, r31
    335e:	a2 17       	cp	r26, r18
    3360:	b3 07       	cpc	r27, r19
    3362:	e4 07       	cpc	r30, r20
    3364:	f5 07       	cpc	r31, r21
    3366:	20 f0       	brcs	.+8      	; 0x3370 <__udivmodsi4_ep>
    3368:	a2 1b       	sub	r26, r18
    336a:	b3 0b       	sbc	r27, r19
    336c:	e4 0b       	sbc	r30, r20
    336e:	f5 0b       	sbc	r31, r21

00003370 <__udivmodsi4_ep>:
    3370:	66 1f       	adc	r22, r22
    3372:	77 1f       	adc	r23, r23
    3374:	88 1f       	adc	r24, r24
    3376:	99 1f       	adc	r25, r25
    3378:	1a 94       	dec	r1
    337a:	69 f7       	brne	.-38     	; 0x3356 <__udivmodsi4_loop>
    337c:	60 95       	com	r22
    337e:	70 95       	com	r23
    3380:	80 95       	com	r24
    3382:	90 95       	com	r25
    3384:	9b 01       	movw	r18, r22
    3386:	ac 01       	movw	r20, r24
    3388:	bd 01       	movw	r22, r26
    338a:	cf 01       	movw	r24, r30
    338c:	08 95       	ret

0000338e <__divmodsi4>:
    338e:	97 fb       	bst	r25, 7
    3390:	09 2e       	mov	r0, r25
    3392:	05 26       	eor	r0, r21
    3394:	0e d0       	rcall	.+28     	; 0x33b2 <__divmodsi4_neg1>
    3396:	57 fd       	sbrc	r21, 7
    3398:	04 d0       	rcall	.+8      	; 0x33a2 <__divmodsi4_neg2>
    339a:	d7 df       	rcall	.-82     	; 0x334a <__udivmodsi4>
    339c:	0a d0       	rcall	.+20     	; 0x33b2 <__divmodsi4_neg1>
    339e:	00 1c       	adc	r0, r0
    33a0:	38 f4       	brcc	.+14     	; 0x33b0 <__divmodsi4_exit>

000033a2 <__divmodsi4_neg2>:
    33a2:	50 95       	com	r21
    33a4:	40 95       	com	r20
    33a6:	30 95       	com	r19
    33a8:	21 95       	neg	r18
    33aa:	3f 4f       	sbci	r19, 0xFF	; 255
    33ac:	4f 4f       	sbci	r20, 0xFF	; 255
    33ae:	5f 4f       	sbci	r21, 0xFF	; 255

000033b0 <__divmodsi4_exit>:
    33b0:	08 95       	ret

000033b2 <__divmodsi4_neg1>:
    33b2:	f6 f7       	brtc	.-4      	; 0x33b0 <__divmodsi4_exit>
    33b4:	90 95       	com	r25
    33b6:	80 95       	com	r24
    33b8:	70 95       	com	r23
    33ba:	61 95       	neg	r22
    33bc:	7f 4f       	sbci	r23, 0xFF	; 255
    33be:	8f 4f       	sbci	r24, 0xFF	; 255
    33c0:	9f 4f       	sbci	r25, 0xFF	; 255
    33c2:	08 95       	ret

000033c4 <memcpy>:
    33c4:	fb 01       	movw	r30, r22
    33c6:	dc 01       	movw	r26, r24
    33c8:	02 c0       	rjmp	.+4      	; 0x33ce <memcpy+0xa>
    33ca:	01 90       	ld	r0, Z+
    33cc:	0d 92       	st	X+, r0
    33ce:	41 50       	subi	r20, 0x01	; 1
    33d0:	50 40       	sbci	r21, 0x00	; 0
    33d2:	d8 f7       	brcc	.-10     	; 0x33ca <memcpy+0x6>
    33d4:	08 95       	ret

000033d6 <itoa>:
    33d6:	fb 01       	movw	r30, r22
    33d8:	9f 01       	movw	r18, r30
    33da:	e8 94       	clt
    33dc:	42 30       	cpi	r20, 0x02	; 2
    33de:	c4 f0       	brlt	.+48     	; 0x3410 <itoa+0x3a>
    33e0:	45 32       	cpi	r20, 0x25	; 37
    33e2:	b4 f4       	brge	.+44     	; 0x3410 <itoa+0x3a>
    33e4:	4a 30       	cpi	r20, 0x0A	; 10
    33e6:	29 f4       	brne	.+10     	; 0x33f2 <itoa+0x1c>
    33e8:	97 fb       	bst	r25, 7
    33ea:	1e f4       	brtc	.+6      	; 0x33f2 <itoa+0x1c>
    33ec:	90 95       	com	r25
    33ee:	81 95       	neg	r24
    33f0:	9f 4f       	sbci	r25, 0xFF	; 255
    33f2:	64 2f       	mov	r22, r20
    33f4:	77 27       	eor	r23, r23
    33f6:	0e 94 1c 1a 	call	0x3438	; 0x3438 <__udivmodhi4>
    33fa:	80 5d       	subi	r24, 0xD0	; 208
    33fc:	8a 33       	cpi	r24, 0x3A	; 58
    33fe:	0c f0       	brlt	.+2      	; 0x3402 <itoa+0x2c>
    3400:	89 5d       	subi	r24, 0xD9	; 217
    3402:	81 93       	st	Z+, r24
    3404:	cb 01       	movw	r24, r22
    3406:	00 97       	sbiw	r24, 0x00	; 0
    3408:	a1 f7       	brne	.-24     	; 0x33f2 <itoa+0x1c>
    340a:	16 f4       	brtc	.+4      	; 0x3410 <itoa+0x3a>
    340c:	5d e2       	ldi	r21, 0x2D	; 45
    340e:	51 93       	st	Z+, r21
    3410:	10 82       	st	Z, r1
    3412:	c9 01       	movw	r24, r18
    3414:	0c 94 0c 1a 	jmp	0x3418	; 0x3418 <strrev>

00003418 <strrev>:
    3418:	dc 01       	movw	r26, r24
    341a:	fc 01       	movw	r30, r24
    341c:	67 2f       	mov	r22, r23
    341e:	71 91       	ld	r23, Z+
    3420:	77 23       	and	r23, r23
    3422:	e1 f7       	brne	.-8      	; 0x341c <strrev+0x4>
    3424:	32 97       	sbiw	r30, 0x02	; 2
    3426:	04 c0       	rjmp	.+8      	; 0x3430 <strrev+0x18>
    3428:	7c 91       	ld	r23, X
    342a:	6d 93       	st	X+, r22
    342c:	70 83       	st	Z, r23
    342e:	62 91       	ld	r22, -Z
    3430:	ae 17       	cp	r26, r30
    3432:	bf 07       	cpc	r27, r31
    3434:	c8 f3       	brcs	.-14     	; 0x3428 <strrev+0x10>
    3436:	08 95       	ret

00003438 <__udivmodhi4>:
    3438:	aa 1b       	sub	r26, r26
    343a:	bb 1b       	sub	r27, r27
    343c:	51 e1       	ldi	r21, 0x11	; 17
    343e:	07 c0       	rjmp	.+14     	; 0x344e <__udivmodhi4_ep>

00003440 <__udivmodhi4_loop>:
    3440:	aa 1f       	adc	r26, r26
    3442:	bb 1f       	adc	r27, r27
    3444:	a6 17       	cp	r26, r22
    3446:	b7 07       	cpc	r27, r23
    3448:	10 f0       	brcs	.+4      	; 0x344e <__udivmodhi4_ep>
    344a:	a6 1b       	sub	r26, r22
    344c:	b7 0b       	sbc	r27, r23

0000344e <__udivmodhi4_ep>:
    344e:	88 1f       	adc	r24, r24
    3450:	99 1f       	adc	r25, r25
    3452:	5a 95       	dec	r21
    3454:	a9 f7       	brne	.-22     	; 0x3440 <__udivmodhi4_loop>
    3456:	80 95       	com	r24
    3458:	90 95       	com	r25
    345a:	bc 01       	movw	r22, r24
    345c:	cd 01       	movw	r24, r26
    345e:	08 95       	ret

00003460 <_exit>:
    3460:	f8 94       	cli

00003462 <__stop_program>:
    3462:	ff cf       	rjmp	.-2      	; 0x3462 <__stop_program>
